# Issue #179 分析: マイク入力時の類似度0スパイク問題

## 問題の概要

マイクで人の声を入力すると、類似度0のスパイクが1秒に10回前後発生する。
WAVファイルで単純波形を入力した場合は問題ない。

## コード分析の結果

### 類似度計算の処理フロー

`signal-processor-wasm/src/lib.rs` の `process_frame` メソッドにおいて、以下の流れで類似度が計算される：

1. **周波数推定** (line 177-183)
   ```rust
   let estimated_frequency = self.frequency_estimator.estimate_frequency(
       &data,
       freq_data.as_deref(),
       sample_rate,
       fft_size,
       is_signal_above_noise_gate,
   );
   ```

2. **サイクル長の計算** (line 186-190)
   ```rust
   let cycle_length = if estimated_frequency > 0.0 && sample_rate > 0.0 {
       sample_rate / estimated_frequency
   } else {
       0.0
   };
   ```

3. **類似度検索の実行** (line 197-213)
   - 前回の波形が存在し、かつ `cycle_length > 0.0` の場合のみ実行
   - 検索に失敗した場合、内部で `update_similarity_history(0.0)` が呼ばれる
   - 前回の波形が存在するが `cycle_length` が無効な場合、`record_no_search()` が呼ばれ、類似度が0.0になる

### 類似度が0になる条件

`waveform_searcher.rs` を分析した結果、以下の条件で類似度が0.0になることが判明：

1. **cycle_length <= 0.0 の場合** (line 86-89)
   - 周波数推定が失敗した場合
   - 推定周波数が0以下の場合

2. **current_frame.len() < waveform_length の場合** (line 94-97)
   - バッファサイズが4サイクル分に満たない場合

3. **prev_waveform.len() != waveform_length の場合** (line 99-102)
   - 前回のサイクル長と今回のサイクル長が異なる場合
   - **これが最も可能性の高い原因**

4. **前回の波形が存在しない場合** (line 84)
   - 初回フレームなど

## 仮説の洗い出し

### 仮説1: 周波数推定の不安定性（最も可能性が高い）

**内容:**
人の声は複雑で非周期的な信号であり、周波数推定アルゴリズムが安定した値を返せない。特に：
- 音声の無声子音（s, f, t など）は周期性が低い
- 音声の過渡状態（音の立ち上がり、音の変化）で周波数が急変する
- 周波数が急変すると、cycle_length が変化し、前回の波形長と一致しなくなる

**根拠:**
- `waveform_searcher.rs:99-102` で、`prev_waveform.len() != waveform_length` の場合に類似度が0になる
- 人の声は0.1秒〜0.2秒程度で音素が変化するため、1秒に10回程度のスパイクは音素の変化頻度と一致する
- 単純波形（正弦波など）は周波数が安定しているため、この問題が発生しない

**検証方法:**
1. 周波数推定値とサイクル長の履歴をログ出力
2. 類似度が0になるタイミングでのサイクル長の変化を観察
3. 周波数推定方法を変更した場合の影響を確認

**修正案:**
1. **サイクル長の許容範囲の導入**: 前回のサイクル長から±10%程度の変化は同じ長さとして扱う
2. **周波数推定のスムージング強化**: 急激な周波数変化を抑制する（既に `smooth_frequency` が実装されているが、さらに強化）
3. **可変長波形比較**: サイクル長が変化した場合でも、補間やリサンプリングで比較できるようにする

### 仮説2: ノイズゲートによる信号カット

**内容:**
人の声の音量が変動し、ノイズゲート閾値を下回る瞬間がある。ノイズゲートが有効な場合、信号が0で埋められ、類似度計算が失敗する可能性がある。

**根拠:**
- `gain_controller.rs:112-116` で、ノイズゲート閾値を下回ると `data.fill(0.0)` される
- デフォルト閾値は `-48dB` (0.003981072)
- 人の声は音量の変動が大きい（特に子音と母音の間）

**検証方法:**
1. ノイズゲートを無効化した場合の動作を確認
2. 類似度が0になるタイミングで `is_signal_above_noise_gate` の値を確認

**修正案:**
1. ノイズゲート適用後も前回の波形情報を保持し、信号が復帰したときにスムーズに類似度計算を再開
2. ノイズゲート閾値の自動調整（環境ノイズレベルに応じて）

### 仮説3: バッファサイズ不足

**内容:**
マイク入力のバッファサイズが、低周波の人声（100Hz〜300Hz程度）に対して4サイクル分を保持するのに不十分な場合がある。

**根拠:**
- `waveform_searcher.rs:94-97` で、`current_frame.len() < waveform_length` の場合に類似度が0になる
- FFTサイズは4096サンプル（`COPILOT_INSTRUCTIONS.md`より）
- サンプルレート48000Hzの場合、4096サンプル = 約85ms
- 100Hzの音声の4サイクル = 40ms なので通常は問題ないが、バッファサイズマルチプライヤーが適用されていない場合は不足する可能性がある

**検証方法:**
1. バッファサイズとサイクル長の関係をログ出力
2. バッファサイズマルチプライヤーの設定を確認

**修正案:**
1. デフォルトのバッファサイズマルチプライヤーを16倍に設定（既にデフォルト値は16になっている）
2. バッファサイズ不足を検出した場合の警告表示

### 仮説4: 自動ゲイン制御の影響

**内容:**
自動ゲイン制御により、波形の振幅が急激に変化し、相関係数の計算が不安定になる可能性がある。

**根拠:**
- `gain_controller.rs:36-83` で自動ゲイン計算が実施される
- 相関係数は振幅に依存しない（平均を引くため）はずだが、実装の詳細による

**検証方法:**
1. 自動ゲインを無効化した場合の動作を確認
2. ゲイン値の変化と類似度の関係を観察

**修正案:**
1. 類似度計算前に正規化を強化
2. ゲイン変化の平滑化

### 仮説5: ゼロクロス検出の失敗

**内容:**
類似度検索に失敗した場合、ゼロクロス検出にフォールバックするが、この処理が不安定で、次フレームの類似度計算に影響を与える。

**根拠:**
- `lib.rs:216-236` でゼロクロス検出へのフォールバック処理がある
- `lib.rs:243-246` で、計算された display range を使って波形を保存する
- ゼロクロス検出が失敗すると、保存される波形の範囲が不適切になる可能性がある

**検証方法:**
1. ゼロクロス検出の成功/失敗をログ出力
2. 保存される波形の範囲を確認

**修正案:**
1. ゼロクロス検出失敗時の波形保存をスキップ
2. ゼロクロス検出の精度向上

## 推奨される対応順序

1. **仮説1の検証と修正（優先度: 高）**
   - 最も可能性が高く、修正効果も大きい
   - サイクル長の許容範囲導入は比較的容易に実装可能

2. **仮説2の検証（優先度: 中）**
   - ノイズゲートの影響を確認
   - 必要に応じて修正

3. **仮説3, 4, 5の検証（優先度: 低）**
   - 上記で解決しない場合に検証

## 実装上の注意点

- すべてのデータ処理アルゴリズムはRust/WASMで実装されているため、修正はRust側で行う
- TypeScript側は設定の保持とレンダリングのみを担当
- テストは `src/__tests__/` に追加
- WASMのビルドには `npm run build:wasm` を使用（wasm-packが必要）
