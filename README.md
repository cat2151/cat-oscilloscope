# cat-oscilloscope

An oscilloscope-style waveform visualizer that runs in your browser.

## üåê Live Demo

**[https://cat2151.github.io/cat-oscilloscope/](https://cat2151.github.io/cat-oscilloscope/)**

You can try the application at the URL above. Microphone access permission is required.

‚Äª This document is a placeholder and largely generated by an LLM. It will be revised in the future.

## Current Status
- Most major bugs have been addressed.
- There are still minor glitches.
- When using sound from a microphone, phase synchronization is unstable, making its practical use limited.
- It is highly practical when using simple monaural waveforms from chiptune WAV files.
- We plan to verify how easily it can be used as a library.

## üìö Usage as a Library

cat-oscilloscope can be used as an npm library in your own projects. For detailed instructions, please see [LIBRARY_USAGE.md](./LIBRARY_USAGE.md).

```typescript
import { Oscilloscope } from 'cat-oscilloscope';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const oscilloscope = new Oscilloscope(canvas);
await oscilloscope.start();
```

## Features

### Frequency Estimation

cat-oscilloscope supports 5 frequency estimation algorithms:

1.  **Zero-Crossing**: Simple and fast. Suitable for simple waveforms.
2.  **Autocorrelation**: Default. Good balance of accuracy for complex waveforms.
3.  **FFT (Fast Fourier Transform)**: Frequency spectrum analysis. Strong with high frequencies.
4.  **STFT (Short-Time Fourier Transform)**: Improved low-frequency detection accuracy with variable window lengths.
5.  **CQT (Constant Q Transform)**: High frequency resolution in the low-frequency range. Suitable for music analysis.

### Buffer Size Multiplier

Supports extended buffers using past frame buffers to improve low-frequency detection accuracy:

-   **1x (Standard)**: Standard buffer size (approx. 1/60 second)
-   **4x (Better Low Freq)**: 4x extended buffer for improved low-frequency detection
-   **16x (Best Low Freq)**: 16x extended buffer for the best low-frequency detection accuracy

**Usage Example**: For detecting low frequencies between 20-50Hz, selecting STFT or CQT and setting the Buffer Size to 16x is optimal.

**Important Notes:**
-   Changing the buffer size will not take effect until the history accumulates (up to 16 frames)
-   With a large buffer size (16x), initial frequency detection may take approximately 0.3 seconds.

### Detectable Frequency Range

The minimum detectable frequency varies depending on the buffer size:

-   **1x (4096 samples @ 48kHz)**: Approx. 80Hz and above (standard use)
-   **4x (16384 samples)**: Approx. 30Hz and above (improved low frequency)
-   **16x (65536 samples)**: Approx. 20Hz and above (best low frequency detection)

## Notes

-   Frequency Estimation
    -   Sometimes FFT is accurate, and sometimes other methods are.
    -   STFT and CQT are particularly good at detecting low frequencies (20-100Hz).
    -   Increasing the buffer size multiplier improves low-frequency accuracy but slightly increases responsiveness delay.
    -   **Performance**: With a 16x buffer size, STFT/CQT calculations can take time (due to an implementation for educational purposes).

## About Data Processing Implementation

All data processing (waveform searching, frequency estimation, zero-crossing detection, etc.) is **implemented in Rust/WASM**.

-   High processing performance
-   Type-safe and reliable implementation
-   TypeScript is only responsible for configuration management and rendering

### Building the WASM Implementation

The WASM implementation is located in the `wasm-processor` directory.

```bash
# Build the WASM implementation (requires wasm-pack)
npm run build:wasm

# Build the entire application (including WASM)
npm run build
```

**Required Tools**:
-   Rust toolchain (rustc, cargo)
-   wasm-pack (`cargo install wasm-pack`)

## Features

-   üé§ **Microphone Input** - Real-time audio capture from the microphone
-   üéØ **Zero-Crossing Detection** - Automatically detects points where the audio crosses from negative to positive
-   üìä **Stable Display** - Aligns waveform display based on zero-crossing points for stable viewing
-   üîä **Auto Gain** - Automatically adjusts waveform amplitude to optimally utilize canvas height
-   ‚ö° **Real-time Rendering** - Continuously updates waveform visualization
-   üé® **Classic Design** - Green waveform and grid overlay on a black background
-   üõ°Ô∏è **Error Handling** - Gracefully handles microphone access permission issues
-   üîç **Waveform Similarity Search** - Calculates similarity with previous frames for stable waveform display
-   ü¶Ä **Rust/WASM Implementation** - All data processing algorithms implemented in Rust/WASM

## Getting Started

### Prerequisites

-   Node.js (v16 or higher recommended)
-   npm or yarn

### Installation

```bash
npm install
```

### Development

Start the development server:

```bash
npm run dev
```

Open `http://localhost:3000/` in your browser.

### Build

Build for production:

```bash
npm run build
```

Built files will be output to the `dist` directory.

### Preview Production Build

```bash
npm run preview
```

### Testing

Run tests:

```bash
npm test
```

Generate coverage report:

```bash
npm run test:coverage
```

Launch test UI:

```bash
npm run test:ui
```

For more details, refer to [TESTING.md](TESTING.md).

## How It Works

### Zero-Crossing Detection Algorithm

This oscilloscope implements a zero-crossing detection algorithm as follows:

1.  Scans the audio buffer to detect points where the waveform crosses from negative (or zero) to positive.
2.  Identifies the first zero-crossing point.
3.  Finds the next zero-crossing point to determine one complete waveform cycle.
4.  Displays the waveform with a slight padding before and after the zero-crossing points.

This achieves a stable, non-scrolling display.

### Technical Details

-   **FFT Size**: 4096 samples for high resolution
-   **Smoothing**: Disabled (0) for accurate waveform representation
-   **Display Padding**: 20 samples before and after zero-crossing points
-   **Auto Gain**:
    -   Automatically adjusts to target 80% of canvas height
    -   Smooth transitions via peak tracking (decay rate: 0.95)
    -   Gain range: 0.5x to 99x
    -   Interpolation factor: 0.1 (gradual adjustment)
    -   Toggleable via UI checkbox (default: enabled)
-   **Canvas Resolution**: 800x400 pixels
-   **Refresh Rate**: Synchronized with browser's requestAnimationFrame (approx. 60 FPS)

## Technology Stack

-   **TypeScript** - Type-safe JavaScript
-   **Vite** - Fast build tool and development server
-   **Web Audio API** - Audio capture and analysis
-   **HTML Canvas** - 2D waveform rendering

## Browser Requirements

This application requires:
-   A modern browser that supports the Web Audio API (Chrome, Firefox, Safari, Edge)
-   User permission for microphone access
-   HTTPS or localhost (required for microphone access)

## Constraints When Using Microphone Input

When using input from a microphone, there are the following constraints:

### Impact of Ambient Noise

The microphone picks up all surrounding sounds, so ambient noises like the following can affect the waveform:

-   **Mouse Clicks**: Mechanical sounds from clicking the mouse will appear in the waveform. Especially when clicking the pause button with the mouse, the waveform may appear distorted at that moment.
-   **Keyboard Typing Sounds**: Keyboard typing sounds also affect the waveform. However, if using a silent keyboard, the impact will be minimal.
-   **Other Ambient Sounds**: Speaking voices, indoor air conditioning sounds, and external noise can also appear in the waveform.

### Practical Tips

-   **Pausing**: To minimize the impact on the waveform when pausing, use the spacebar on a silent keyboard instead of clicking the mouse.
-   **Sound Source Selection**: Since microphone input is susceptible to ambient noise, it is recommended to use audio files like WAV files if you wish to observe a noise-free waveform.
-   **Measurement Environment**: Using the application in as quiet an environment as possible will allow for more accurate waveform observation.

These are not limitations of the application itself, but rather characteristics of the microphone device.

## License

MIT License - see [LICENSE](LICENSE) file for details

*Big Brother is listening to you. Now it‚Äôs the cat.* üê±