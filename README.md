# cat-oscilloscope

<p align="left">
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
  <a href="https://deepwiki.com/cat2151/cat-oscilloscope"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
  <a href="https://cat2151.github.io/cat-oscilloscope/"><img src="https://img.shields.io/badge/üåê-Live_Demo-green.svg" alt="Live Demo"></a>
</p>

A browser-based, oscilloscope-style waveform visualizer.

## üåê Live Demo

**[https://cat2151.github.io/cat-oscilloscope/](https://cat2151.github.io/cat-oscilloscope/)**

You can try the application at the URL above. Microphone access permission is required.

Note: This document is a placeholder, and most of it was generated by an LLM. It will be revised in the future.

## Current Status
- Major bugs have largely been resolved.
- Minor issues may still exist.
- When using audio from a microphone, phase alignment is unstable (sometimes aligned, sometimes not), resulting in low practical utility.
- For simple monaural waveforms from chiptune WAV files, practical utility is high.
- Ease of use as a library will be verified in the future.

## üìö Usage as a Library

cat-oscilloscope can be used as an npm library in your own projects. For detailed instructions, please see [LIBRARY_USAGE.md](./LIBRARY_USAGE.md).

```typescript
import { Oscilloscope } from 'cat-oscilloscope';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const oscilloscope = new Oscilloscope(canvas);
await oscilloscope.start();
```

## Features

### Frequency Estimation

cat-oscilloscope supports five frequency estimation algorithms:

1.  **Zero-Crossing**: Simple and fast. Suitable for simple waveforms.
2.  **Autocorrelation**: Default. Provides balanced accuracy for complex waveforms.
3.  **FFT (Fast Fourier Transform)**: Frequency spectrum analysis. Strong for high frequencies.
4.  **STFT (Short-Time Fourier Transform)**: Improves low-frequency detection accuracy with variable window length.
5.  **CQT (Constant-Q Transform)**: Offers high frequency resolution in the low-frequency range. Suitable for music analysis.

### Buffer Size Multiplier

To improve low-frequency detection accuracy, extended buffers utilizing past frame buffers are supported:

-   **1x (Standard)**: Standard buffer size (approx. 1/60 second)
-   **4x (Better Low Freq)**: 4x extended buffer for improved low-frequency detection accuracy
-   **16x (Best Low Freq)**: 16x extended buffer for best low-frequency detection accuracy

**Usage Example**: For detecting low frequencies between 20-50Hz, selecting STFT or CQT and setting the Buffer Size to 16x is optimal.

**Important Notes:**
- When changing the buffer size, the new buffer size will not become effective until history has accumulated (up to 16 frames).
- With large buffer sizes (16x), initial frequency detection may take approximately 0.3 seconds.

### Detectable Frequency Range

The minimum detectable frequency varies depending on the buffer size:

-   **1x (4096 samples @ 48kHz)**: Approx. 80Hz or higher (standard use)
-   **4x (16384 samples)**: Approx. 30Hz or higher (improved low frequency)
-   **16x (65536 samples)**: Approx. 20Hz or higher (best low frequency detection)

## Notes

-   Frequency Estimation
    -   There are cases where FFT is accurate, and cases where other methods are more accurate.
    -   STFT and CQT are particularly good at detecting low frequencies (20-100Hz).
    -   Increasing the buffer size multiplier improves low-frequency accuracy but slightly delays responsiveness.
    -   **Performance**: With a 16x buffer size, STFT/CQT calculations may take longer (due to its educational implementation).

## About Data Processing Implementation

All data processing (waveform search, frequency estimation, zero-crossing detection, etc.) is **implemented in Rust/WASM**.

-   High processing performance
-   Type-safe and reliable implementation
-   TypeScript is only responsible for configuration management and rendering.

### Building the WASM Implementation

The WASM implementation is located in the `wasm-processor` directory.

```bash
# Build the WASM implementation (requires wasm-pack)
npm run build:wasm

# Build the entire application (including WASM)
npm run build
```

**Required Tools**:
-   Rust toolchain (rustc, cargo)
-   wasm-pack (`cargo install wasm-pack`)

## Features

-   üé§ **Microphone Input** - Captures audio from the microphone in real-time
-   üìÇ **Audio File** - Supports loop playback of WAV files
-   üìä **Frequency Estimation** - Five methods: Zero-Crossing, Autocorrelation, FFT, STFT, CQT
-   üéπ **Piano Keyboard Display** - Displays detected frequencies on a piano keyboard
-   üéöÔ∏è **Auto Gain** - Automatically adjusts waveform amplitude
-   üîá **Noise Gate** - Cuts signals below a set threshold
-   üéØ **Three Alignment Modes**
    -   **Zero-Cross**: Synchronizes at zero-crossing points (default)
    -   **Peak**: Synchronizes at peak points (for high frequencies)
    -   **Phase**: Phase synchronization (for subharmonics, addresses Issue #139)
-   üìà **FFT Spectrum** - Overlays frequency spectrum display
-   üîç **Waveform Comparison Panel** - Displays similarity between current and previous waveforms
-   ‚è∏Ô∏è **Pause Drawing** - Allows observation of a static waveform

### About Alignment Modes

**Phase Alignment Mode** was added to resolve phase instability in waveforms containing subharmonics, such as 1/4 overtones.

-   **Zero-Cross**: Lightest. Suitable for simple waveforms.
-   **Peak**: Stable in high-frequency or noisy environments.
-   **Phase**: DFT-based phase detection enables stable display even for complex waveforms containing subharmonics.

For more details, please refer to [docs/PHASE_ALIGNMENT.md](./docs/PHASE_ALIGNMENT.md).

## Getting Started

### Prerequisites

-   Node.js (v16 or higher recommended)
-   npm or yarn

### Installation

```bash
npm install
```

### Development

Start the development server:

```bash
npm run dev
```

Open `http://localhost:3000/` in your browser.

### Build

Build for production:

```bash
npm run build
```

Built files will be output to the `dist` directory.

### Preview Production Build

```bash
npm run preview
```

### Testing

Run tests:

```bash
npm test
```

Generate coverage report:

```bash
npm run test:coverage
```

Launch test UI:

```bash
npm run test:ui
```

For more details, refer to [TESTING.md](TESTING.md).

## How It Works

### Zero-Cross Detection Algorithm

This oscilloscope implements a zero-cross detection algorithm as follows:

1.  Scans the audio buffer to detect points where the waveform crosses from negative (or zero) to positive.
2.  Identifies the first zero-crossing point.
3.  Finds the next zero-crossing point to determine one complete waveform cycle.
4.  Displays the waveform with slight padding before and after the zero-crossing points.

This achieves a stable, non-scrolling display.

### Technical Details

-   **FFT Size**: 4096 samples for high resolution
-   **Smoothing**: Disabled (0) for accurate waveform representation
-   **Display Padding**: 20 samples before and after zero-crossing points
-   **Auto Gain**:
    -   Automatically adjusts to target 80% of canvas height
    -   Smooth transitions via peak tracking (decay rate: 0.95)
    -   Gain range: 0.5x to 99x
    -   Interpolation coefficient: 0.1 (gradual adjustment)
    -   Can be enabled/disabled via UI checkbox (default: enabled)
-   **Canvas Resolution**: 800x400 pixels
-   **Refresh Rate**: Synchronized with browser's requestAnimationFrame (approx. 60 FPS)

## Tech Stack

-   **TypeScript** - Type-safe JavaScript
-   **Vite** - Fast build tool and development server
-   **Web Audio API** - Audio capture and analysis
-   **HTML Canvas** - 2D waveform rendering

## Browser Requirements

This application requires:
-   A modern browser supporting Web Audio API (Chrome, Firefox, Safari, Edge)
-   User permission for microphone access
-   HTTPS or localhost (required for microphone access)

## Limitations of Microphone Input

When using input from a microphone, the following limitations apply:

### Impact of Ambient Noise

Since microphones pick up all ambient sounds, the following environmental noises can affect the waveform:

-   **Mouse Click Sounds**: Mechanical sounds from clicking the mouse will appear in the waveform. Specifically, the waveform may appear distorted the moment the pause button is clicked with the mouse.
-   **Keyboard Typing Sounds**: Keyboard typing sounds also affect the waveform. However, the impact will be less if a quiet keyboard is used.
-   **Other Ambient Sounds**: Speaking voices, indoor air conditioning sounds, and external noise will also appear in the waveform.

### Practical Tips

-   **How to Pause**: To minimize the impact on the waveform when pausing, use the space key on a quiet keyboard instead of a mouse click.
-   **Sound Source Selection**: Since microphone input is susceptible to ambient noise, it is recommended to use audio files such as WAV files if you want to observe a noise-free waveform.
-   **Measurement Environment**: Using the application in as quiet an environment as possible will allow for more accurate waveform observation.

These are not limitations of the application itself, but rather characteristics of the microphone device.

## License

MIT License - See the [LICENSE](LICENSE) file for details.

*Big Brother is listening to you. Now it‚Äôs the cat.* üê±