# cat-oscilloscope

An oscilloscope-like waveform visualizer that runs in the browser.

## üåê Live Demo

**[https://cat2151.github.io/cat-oscilloscope/](https://cat2151.github.io/cat-oscilloscope/)**

You can try the application at the URL above. Microphone access permission is required.

*Note: This document is a placeholder and most of it was generated by an LLM. It will be revised in the future.*

## Current Status
- Major bugs have largely been resolved.
- Minor issues still exist.
- When using sound from a microphone, the phase alignment is unstable, making its practical use limited.
- It has high practical utility for simple monaural chip-tune waveforms from WAV files.
- The ease of use as a library will be verified in the future.

## üìö Usage as a Library

cat-oscilloscope can be used as an npm library in your own projects. For detailed instructions, please refer to [LIBRARY_USAGE.md](./LIBRARY_USAGE.md).

```typescript
import { Oscilloscope } from 'cat-oscilloscope';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const oscilloscope = new Oscilloscope(canvas);
await oscilloscope.start();
```

## Features

### Frequency Estimation

cat-oscilloscope supports 5 frequency estimation algorithms:

1.  **Zero-Crossing**: Simple and fast. Suitable for simple waveforms.
2.  **Autocorrelation**: Default. Good balance of accuracy for complex waveforms.
3.  **FFT (Fast Fourier Transform)**: Frequency spectrum analysis. Strong for high frequencies.
4.  **STFT (Short-Time Fourier Transform)**: Improved low-frequency detection accuracy with variable window length.
5.  **CQT (Constant-Q Transform)**: High frequency resolution in the low-frequency range. Suitable for music analysis.

### Buffer Size Multiplier

To improve low-frequency detection accuracy, extended buffers utilizing past frame buffers are supported:

-   **1x (Standard)**: Standard buffer size (approx. 1/60th of a second)
-   **4x (Better Low Freq)**: 4x extended buffer improves low-frequency detection accuracy
-   **16x (Best Low Freq)**: 16x extended buffer for the best low-frequency detection accuracy

**Example Use Case**: To detect low frequencies between 20-50Hz, it is optimal to select STFT or CQT and set the Buffer Size to 16x.

**Important Notes:**
-   When changing the buffer size, the new buffer size will not take effect until the history accumulates (up to 16 frames).
-   With a large buffer size (16x), initial frequency detection may take approximately 0.3 seconds.

### Detectable Frequency Range

The minimum detectable frequency varies depending on the buffer size:

-   **1x (4096 samples @ 48kHz)**: Approx. 80Hz or higher (standard use)
-   **4x (16384 samples)**: Approx. 30Hz or higher (improved low frequency)
-   **16x (65536 samples)**: Approx. 20Hz or higher (best low-frequency detection)

## Notes

-   Frequency Estimation
    -   Sometimes FFT is accurate, and other times non-FFT methods are accurate.
    -   STFT and CQT are particularly good at detecting low frequencies (20-100Hz).
    -   Increasing the Buffer Size Multiplier improves low-frequency accuracy but slightly slows down responsiveness.
    -   **Performance**: With a 16x buffer size, STFT/CQT calculations may take longer (due to implementation for educational purposes).

## About WASM Implementation

The data processing parts (waveform searching, frequency estimation, zero-crossing detection, etc.) are also implemented in Rust/WASM.

-   **TypeScript Implementation**: Used by default. High compatibility and easy debugging.
-   **Rust/WASM Implementation**: Expected to provide faster processing. Can be toggled with the "Use WASM" checkbox.

Both implementations return the exact same `WaveformRenderData` structure, so the rendering logic is common.

### Building the WASM Implementation

The WASM implementation is located in the `wasm-processor` directory.

```bash
# Build WASM implementation (requires wasm-pack)
npm run build:wasm

# Build the entire application (including WASM)
npm run build
```

**Required Tools**:
-   Rust toolchain (rustc, cargo)
-   wasm-pack (`cargo install wasm-pack`)

## Features

-   üé§ **Microphone Input** - Real-time capture of audio from the microphone
-   üéØ **Zero-Crossing Detection** - Automatic detection of points where audio crosses from negative to positive
-   üìä **Stable Display** - Waveform display aligned based on zero-crossing points for stable visualization
-   üîä **Auto Gain** - Automatic adjustment of waveform amplitude to optimally utilize canvas height
-   ‚ö° **Real-time Rendering** - Continuous updates for waveform visualization
-   üé® **Classic Design** - Black background with green waveform and grid overlay
-   üõ°Ô∏è **Error Handling** - Proper handling of microphone access permission issues
-   üîç **Waveform Similarity Search** - Calculates similarity with the previous frame to achieve a stable waveform display
-   ü¶Ä **Rust/WASM Support** - Data processing implemented in Rust/WASM, toggleable via checkbox

## Getting Started

### Prerequisites

-   Node.js (v16 or higher recommended)
-   npm or yarn

### Installation

```bash
npm install
```

### Development

Start the development server:

```bash
npm run dev
```

Open `http://localhost:3000/` in your browser.

### Build

Build for production:

```bash
npm run build
```

The built files will be output to the `dist` directory.

### Preview Production Build

```bash
npm run preview
```

### Testing

Run tests:

```bash
npm test
```

Generate coverage report:

```bash
npm run test:coverage
```

Start the test UI:

```bash
npm run test:ui
```

For more details, refer to [TESTING.md](TESTING.md).

## How It Works

### Zero-Crossing Detection Algorithm

This oscilloscope implements a zero-crossing detection algorithm as follows:

1.  Scans the audio buffer to detect points where the waveform crosses from negative (or zero) to positive.
2.  Identifies the first zero-crossing point.
3.  Finds the next zero-crossing point to determine one complete waveform cycle.
4.  Displays the waveform with a slight padding before and after the zero-crossing points.

This ensures a stable, non-scrolling display.

### Technical Details

-   **FFT Size**: 4096 samples for high resolution
-   **Smoothing**: Disabled (0) for accurate waveform representation
-   **Display Padding**: 20 samples before and after the zero-crossing point
-   **Auto Gain**:
    -   Automatically adjusts to target 80% of canvas height
    -   Smooth transitions via peak tracking (decay rate: 0.95)
    -   Gain range: 0.5x to 99x
    -   Interpolation factor: 0.1 (gradual adjustment)
    -   Toggleable via UI checkbox (default: enabled)
-   **Canvas Resolution**: 800x400 pixels
-   **Refresh Rate**: Synchronized with browser's requestAnimationFrame (approx. 60 FPS)

## Technology Stack

-   **TypeScript** - Type-safe JavaScript
-   **Vite** - Fast build tool and development server
-   **Web Audio API** - Audio capture and analysis
-   **HTML Canvas** - 2D waveform rendering

## Browser Requirements

This application requires:
-   A modern browser supporting the Web Audio API (Chrome, Firefox, Safari, Edge)
-   User permission for microphone access
-   HTTPS or localhost (required for microphone access)

## License

MIT License - See the [LICENSE](LICENSE) file for details

*Big Brother is listening to you. Now it‚Äôs the cat.* üê±