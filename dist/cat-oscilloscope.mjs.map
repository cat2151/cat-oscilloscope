{"version":3,"file":"cat-oscilloscope.mjs","sources":["../src/utils.ts","../src/FrameBufferHistory.ts","../src/AudioManager.ts","../src/GainController.ts","../src/FrequencyEstimator.ts","../src/OverlayLayout.ts","../src/renderers/BaseOverlayRenderer.ts","../src/renderers/GridRenderer.ts","../src/renderers/WaveformLineRenderer.ts","../src/renderers/FFTOverlayRenderer.ts","../src/renderers/HarmonicAnalysisRenderer.ts","../src/renderers/FrequencyPlotRenderer.ts","../src/renderers/PhaseMarkerRenderer.ts","../src/WaveformRenderer.ts","../src/ZeroCrossDetector.ts","../src/WaveformSearcher.ts","../src/comparison-renderers/WaveformPanelRenderer.ts","../src/comparison-renderers/SimilarityPlotRenderer.ts","../src/comparison-renderers/PositionMarkerRenderer.ts","../src/comparison-renderers/OffsetOverlayRenderer.ts","../src/ComparisonPanelRenderer.ts","../src/CycleSimilarityRenderer.ts","../src/BasePathResolver.ts","../src/WasmModuleLoader.ts","../src/WaveformDataProcessor.ts","../src/Oscilloscope.ts","../src/PianoKeyboardRenderer.ts","../src/BufferSource.ts"],"sourcesContent":["/**\n * Utility functions for threshold conversions and audio processing\n */\n\n/**\n * Convert dB value to amplitude (linear)\n * @param db - Decibel value (typically -60 to 0)\n * @returns Amplitude value (typically 0.001 to 1.0)\n */\nexport function dbToAmplitude(db: number): number {\n  return Math.pow(10, db / 20);\n}\n\n/**\n * Convert amplitude (linear) to dB value\n * @param amplitude - Amplitude value (typically 0.001 to infinity)\n * @returns Decibel value\n */\nexport function amplitudeToDb(amplitude: number): number {\n  if (amplitude <= 0) {\n    return -Infinity;\n  }\n  return 20 * Math.log10(amplitude);\n}\n\n/**\n * Convert frequency to musical note name and cent deviation\n * @param frequency - Frequency in Hz\n * @returns Object with note name (e.g., \"A4\") and cent deviation (e.g., 0), or null if frequency is invalid\n */\nexport function frequencyToNote(frequency: number): { noteName: string; cents: number } | null {\n  if (frequency <= 0 || !isFinite(frequency)) {\n    return null;\n  }\n\n  // A4 = 440 Hz is our reference\n  const A4 = 440;\n  // C0 is 4 octaves and 9 semitones (4.75 octaves) below A4\n  // Each octave is a factor of 2, so C0 = A4 / 2^4.75\n  const C0 = A4 * Math.pow(2, -4.75);\n\n  // Calculate the number of half steps from C0\n  const halfSteps = 12 * Math.log2(frequency / C0);\n  \n  // Round to nearest half step to get the note\n  const noteIndex = Math.round(halfSteps);\n  \n  // Calculate cent deviation from the nearest note (-50 to +50)\n  const cents = Math.round((halfSteps - noteIndex) * 100);\n  \n  // Note names in chromatic scale\n  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n  \n  // Calculate octave and note name\n  const octave = Math.floor(noteIndex / 12);\n  // Use ((noteIndex % 12) + 12) % 12 to handle negative values correctly\n  const note = noteNames[((noteIndex % 12) + 12) % 12];\n  \n  return {\n    noteName: `${note}${octave}`,\n    cents: cents\n  };\n}\n\n/**\n * Silence threshold in dB relative to peak amplitude\n * Samples below this level relative to the peak are considered silence\n */\nconst SILENCE_THRESHOLD_DB = -48;\n\n/**\n * Trim silence from the beginning and end of an AudioBuffer\n * The threshold is calculated as -48dB relative to the peak amplitude of the entire buffer\n * @param audioBuffer - The audio buffer to trim\n * @returns A new AudioBuffer with silence trimmed, or the original if no trimming is needed\n */\nexport function trimSilence(audioBuffer: AudioBuffer): AudioBuffer {\n  const numberOfChannels = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const length = audioBuffer.length;\n  \n  // Cache channel data for reuse and calculate peak amplitude\n  const channelDataCache: Float32Array[] = [];\n  let peakAmplitude = 0;\n  \n  for (let channel = 0; channel < numberOfChannels; channel++) {\n    const data = audioBuffer.getChannelData(channel);\n    channelDataCache.push(data);\n    \n    for (let i = 0; i < length; i++) {\n      const amplitude = Math.abs(data[i]);\n      if (amplitude > peakAmplitude) {\n        peakAmplitude = amplitude;\n      }\n    }\n  }\n  \n  // If the entire buffer is silent (peak is zero), return the original\n  if (peakAmplitude === 0) {\n    return audioBuffer;\n  }\n  \n  // Calculate threshold as SILENCE_THRESHOLD_DB relative to peak amplitude\n  const threshold = peakAmplitude * Math.pow(10, SILENCE_THRESHOLD_DB / 20);\n  \n  // Find the start index (first non-silent sample across all channels)\n  let startIndex = length; // Initialize to length to detect if no non-silent sample found\n  for (let i = 0; i < length; i++) {\n    let isSilent = true;\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n      if (Math.abs(channelDataCache[channel][i]) > threshold) {\n        isSilent = false;\n        break;\n      }\n    }\n    if (!isSilent) {\n      startIndex = i;\n      break;\n    }\n  }\n  \n  // If entire buffer is silent, return the original\n  if (startIndex >= length) {\n    return audioBuffer;\n  }\n  \n  // Find the end index (last non-silent sample across all channels)\n  let endIndex = length - 1;\n  for (let i = length - 1; i >= startIndex; i--) {\n    let isSilent = true;\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n      if (Math.abs(channelDataCache[channel][i]) > threshold) {\n        isSilent = false;\n        break;\n      }\n    }\n    if (!isSilent) {\n      endIndex = i;\n      break;\n    }\n  }\n  \n  // If no trimming is needed, return the original\n  if (startIndex === 0 && endIndex === length - 1) {\n    return audioBuffer;\n  }\n  \n  // Create a new buffer with the trimmed length\n  const trimmedLength = endIndex - startIndex + 1;\n  const trimmedBuffer = new AudioBuffer({\n    numberOfChannels: numberOfChannels,\n    length: trimmedLength,\n    sampleRate: sampleRate\n  });\n  \n  // Copy the non-silent samples to the new buffer\n  for (let channel = 0; channel < numberOfChannels; channel++) {\n    const sourceData = channelDataCache[channel];\n    const destData = trimmedBuffer.getChannelData(channel);\n    for (let i = 0; i < trimmedLength; i++) {\n      destData[i] = sourceData[startIndex + i];\n    }\n  }\n  \n  return trimmedBuffer;\n}\n","/**\n * FrameBufferHistory - Manages history of frame buffers for extended FFT\n * Responsible for:\n * - Storing past frame buffers\n * - Providing concatenated buffers with specified multiplier\n * - Efficient buffer reuse to avoid allocations in updateHistory\n */\nexport class FrameBufferHistory {\n  private frameBufferHistory: Float32Array[] = [];\n  private readonly MAX_FRAME_HISTORY = 16; // Support up to 16x buffer size\n  private extendedBufferCache: Map<number, Float32Array> = new Map(); // Cache for reused extended buffers\n\n  /**\n   * Update frame buffer history with the current frame\n   * Reuses existing buffers to avoid allocating a new Float32Array every frame\n   */\n  updateHistory(currentBuffer: Float32Array): void {\n    let buffer: Float32Array;\n\n    if (this.frameBufferHistory.length < this.MAX_FRAME_HISTORY) {\n      // Warm-up phase: allocate new buffers until we reach MAX_FRAME_HISTORY\n      buffer = new Float32Array(currentBuffer.length);\n    } else {\n      // Steady state: reuse the oldest buffer\n      buffer = this.frameBufferHistory.shift() as Float32Array;\n      // If FFT size (and thus buffer length) has changed, reallocate\n      if (buffer.length !== currentBuffer.length) {\n        buffer = new Float32Array(currentBuffer.length);\n      }\n    }\n\n    // Copy current data into the buffer\n    buffer.set(currentBuffer);\n\n    // Add updated buffer as most recent\n    this.frameBufferHistory.push(buffer);\n  }\n\n  /**\n   * Get extended time-domain data by concatenating past frame buffers\n   * Reuses cached buffers to avoid allocation on every call\n   * @param multiplier - Buffer size multiplier (1, 4, or 16)\n   * @param currentBuffer - Current frame buffer for 1x multiplier\n   * @returns Combined buffer or null if insufficient history\n   */\n  getExtendedBuffer(multiplier: 1 | 4 | 16, currentBuffer: Float32Array | null): Float32Array | null {\n    if (multiplier === 1) {\n      // Return current buffer for 1x\n      return currentBuffer;\n    }\n\n    if (!currentBuffer || this.frameBufferHistory.length < multiplier) {\n      return null; // Not enough history yet\n    }\n\n    // Get the most recent 'multiplier' buffers\n    const recentBuffers = this.frameBufferHistory.slice(-multiplier);\n\n    // Calculate total length\n    const totalLength = recentBuffers.reduce((sum, buf) => sum + buf.length, 0);\n    \n    // Get or create cached buffer\n    let extendedBuffer = this.extendedBufferCache.get(multiplier);\n    if (!extendedBuffer || extendedBuffer.length !== totalLength) {\n      // Allocate new buffer only if size changed or doesn't exist\n      extendedBuffer = new Float32Array(totalLength);\n      this.extendedBufferCache.set(multiplier, extendedBuffer);\n    }\n\n    // Concatenate buffers into the cached buffer\n    let offset = 0;\n    for (const buffer of recentBuffers) {\n      extendedBuffer.set(buffer, offset);\n      offset += buffer.length;\n    }\n\n    return extendedBuffer;\n  }\n\n  /**\n   * Clear frame buffer history\n   */\n  clear(): void {\n    this.frameBufferHistory = [];\n    this.extendedBufferCache.clear();\n  }\n}\n","import { trimSilence } from './utils';\nimport { BufferSource } from './BufferSource';\nimport { FrameBufferHistory } from './FrameBufferHistory';\n\n/**\n * AudioManager handles Web Audio API integration\n * Responsible for:\n * - AudioContext lifecycle management\n * - MediaStream management\n * - AnalyserNode configuration\n * - Audio data retrieval\n * - BufferSource support for static buffer visualization\n */\nexport class AudioManager {\n  private audioContext: AudioContext | null = null;\n  private analyser: AnalyserNode | null = null;\n  private mediaStream: MediaStream | null = null;\n  private audioBufferSource: AudioBufferSourceNode | null = null;\n  private bufferSource: BufferSource | null = null;\n  private dataArray: Float32Array | null = null;\n  private frequencyData: Uint8Array | null = null;\n  private frameBufferHistory: FrameBufferHistory = new FrameBufferHistory();\n\n  /**\n   * Initialize analyser node and data arrays\n   */\n  private initializeAnalyser(): void {\n    if (!this.audioContext) {\n      throw new Error('AudioContext must be initialized before creating analyser');\n    }\n\n    // Create analyser node with high resolution\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = 4096; // Higher resolution for better waveform\n    this.analyser.smoothingTimeConstant = 0; // No smoothing for accurate waveform\n    \n    // Create data array for time domain data\n    const bufferLength = this.analyser.fftSize;\n    this.dataArray = new Float32Array(bufferLength);\n    \n    // Create frequency data array for FFT\n    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);\n  }\n\n  /**\n   * Start audio capture and analysis\n   */\n  async start(): Promise<void> {\n    try {\n      // Request microphone access\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n      // Set up Web Audio API\n      this.audioContext = new AudioContext();\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n      \n      // Initialize analyser and data arrays\n      this.initializeAnalyser();\n      \n      // Connect nodes\n      source.connect(this.analyser!);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start audio playback from file\n   */\n  async startFromFile(file: File): Promise<void> {\n    try {\n      // Read file as ArrayBuffer\n      const arrayBuffer = await file.arrayBuffer();\n      \n      // Close existing AudioContext if present to avoid resource leak\n      if (this.audioContext && this.audioContext.state !== 'closed') {\n        await this.audioContext.close();\n      }\n\n      // Set up Web Audio API\n      this.audioContext = new AudioContext();\n      \n      // Decode audio data\n      let audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n      \n      // Trim silence from the beginning and end to avoid gaps in loop playback\n      audioBuffer = trimSilence(audioBuffer);\n      \n      // Initialize analyser and data arrays\n      this.initializeAnalyser();\n      \n      // Create buffer source for looping playback\n      this.audioBufferSource = this.audioContext.createBufferSource();\n      this.audioBufferSource.buffer = audioBuffer;\n      this.audioBufferSource.loop = true;\n      \n      // Connect nodes: source -> analyser -> destination\n      this.audioBufferSource.connect(this.analyser!);\n      this.analyser!.connect(this.audioContext.destination);\n      \n      // Start playback\n      this.audioBufferSource.start(0);\n    } catch (error) {\n      console.error('Error loading audio file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start visualization from a static buffer without audio playback\n   * Useful for visualizing pre-recorded audio data or processing results\n   * @param bufferSource - BufferSource instance containing audio data\n   */\n  async startFromBuffer(bufferSource: BufferSource): Promise<void> {\n    try {\n      // Close existing AudioContext if present to avoid resource leak\n      if (this.audioContext && this.audioContext.state !== 'closed') {\n        await this.audioContext.close();\n      }\n\n      // Buffer mode does not use AudioContext - it provides data directly\n      this.audioContext = null;\n      \n      // Store the buffer source\n      this.bufferSource = bufferSource;\n      \n      // Set chunk size to match our FFT size\n      this.bufferSource.setChunkSize(4096);\n      \n      // Initialize data arrays manually (no analyser node needed for buffer mode)\n      this.dataArray = new Float32Array(4096);\n      this.frequencyData = new Uint8Array(2048); // Half of FFT size\n      \n      // Note: We don't create an analyser node in buffer mode\n      // The data will be provided directly from the BufferSource\n    } catch (error) {\n      console.error('Error starting from buffer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop audio capture and clean up resources\n   */\n  async stop(): Promise<void> {\n    if (this.audioBufferSource) {\n      try {\n        this.audioBufferSource.stop();\n      } catch (error) {\n        // Ignore error if already stopped or in invalid state\n      }\n      try {\n        this.audioBufferSource.disconnect();\n      } catch (error) {\n        // Ignore disconnect errors\n      }\n      this.audioBufferSource = null;\n    }\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n    if (this.bufferSource) {\n      this.bufferSource.reset();\n      this.bufferSource = null;\n    }\n    if (this.audioContext) {\n      try {\n        await this.audioContext.close();\n      } catch (error) {\n        console.error('Error closing AudioContext:', error);\n      }\n      this.audioContext = null;\n    }\n    this.analyser = null;\n    this.dataArray = null;\n    this.frequencyData = null;\n    this.frameBufferHistory.clear();\n  }\n\n  /**\n   * Get time-domain data (waveform)\n   * Also updates the frame buffer history for extended FFT\n   */\n  getTimeDomainData(): Float32Array | null {\n    // Buffer mode: get data directly from BufferSource\n    if (this.bufferSource && this.dataArray) {\n      const chunk = this.bufferSource.getNextChunk();\n      if (chunk) {\n        this.dataArray.set(chunk);\n        this.frameBufferHistory.updateHistory(this.dataArray);\n        return this.dataArray;\n      }\n      return null;\n    }\n    \n    // Normal mode: get data from analyser node\n    if (!this.analyser || !this.dataArray) {\n      return null;\n    }\n    // @ts-ignore - Web Audio API type definitions issue\n    this.analyser.getFloatTimeDomainData(this.dataArray);\n    \n    // Store a copy of the current frame buffer for history\n    this.frameBufferHistory.updateHistory(this.dataArray);\n    \n    return this.dataArray;\n  }\n  \n  /**\n   * Get extended time-domain data by concatenating past frame buffers\n   * @param multiplier - Buffer size multiplier (1, 4, or 16)\n   * @returns Combined buffer or null if insufficient history\n   */\n  getExtendedTimeDomainData(multiplier: 1 | 4 | 16): Float32Array | null {\n    return this.frameBufferHistory.getExtendedBuffer(multiplier, this.dataArray);\n  }\n\n  /**\n   * Get frequency-domain data (FFT)\n   * In buffer mode, FFT is computed from time-domain data\n   */\n  getFrequencyData(): Uint8Array | null {\n    // Buffer mode: FFT is not currently supported\n    // Note: FFT could be implemented in the future by computing it from time-domain data\n    // using the same WASM-based FFT that's used for frequency estimation.\n    // This would require integrating with the WaveformDataProcessor's FFT capabilities.\n    // For now, buffer mode focuses on time-domain visualization.\n    if (this.bufferSource && this.dataArray && this.frequencyData) {\n      return null;\n    }\n    \n    // Normal mode: get data from analyser node\n    if (!this.analyser || !this.frequencyData) {\n      return null;\n    }\n    // @ts-ignore - Web Audio API type definitions issue\n    this.analyser.getByteFrequencyData(this.frequencyData);\n    return this.frequencyData;\n  }\n\n  /**\n   * Get sample rate\n   */\n  getSampleRate(): number {\n    if (this.bufferSource) {\n      return this.bufferSource.getSampleRate();\n    }\n    return this.audioContext?.sampleRate || 0;\n  }\n\n  /**\n   * Get FFT size\n   */\n  getFFTSize(): number {\n    if (this.bufferSource) {\n      return 4096; // Fixed FFT size for buffer mode\n    }\n    return this.analyser?.fftSize || 0;\n  }\n\n  /**\n   * Get frequency bin count\n   */\n  getFrequencyBinCount(): number {\n    if (this.bufferSource) {\n      return 2048; // Half of FFT size\n    }\n    return this.analyser?.frequencyBinCount || 0;\n  }\n\n  /**\n   * Check if audio system is ready\n   */\n  isReady(): boolean {\n    // Buffer mode: check if buffer source and data array are ready\n    if (this.bufferSource) {\n      return this.dataArray !== null;\n    }\n    // Normal mode: check if audio context and analyser are ready\n    return this.audioContext !== null && this.analyser !== null;\n  }\n}\n","import { dbToAmplitude } from './utils';\n\n/**\n * GainController - Configuration holder for gain control\n * \n * This class only holds configuration state. All actual gain control\n * and noise gate algorithms are implemented in Rust WASM (signal-processor-wasm module).\n * \n * Responsible for:\n * - Storing auto-gain enabled/disabled state\n * - Storing noise gate enabled/disabled state\n * - Storing noise gate threshold\n * - Holding current gain value (updated by WASM processor)\n */\nexport class GainController {\n  private autoGainEnabled = true;\n  private currentGain = 1.0;\n  \n  private noiseGateEnabled = true;\n  private noiseGateThreshold = dbToAmplitude(-60); // Default threshold (-60dB)\n\n  setAutoGain(enabled: boolean): void {\n    this.autoGainEnabled = enabled;\n  }\n\n  getAutoGainEnabled(): boolean {\n    return this.autoGainEnabled;\n  }\n\n  setNoiseGate(enabled: boolean): void {\n    this.noiseGateEnabled = enabled;\n  }\n\n  getNoiseGateEnabled(): boolean {\n    return this.noiseGateEnabled;\n  }\n\n  setNoiseGateThreshold(threshold: number): void {\n    // Clamp threshold between 0 and 1\n    this.noiseGateThreshold = Math.min(Math.max(threshold, 0), 1);\n  }\n\n  getNoiseGateThreshold(): number {\n    return this.noiseGateThreshold;\n  }\n\n  getCurrentGain(): number {\n    return this.currentGain;\n  }\n}\n","/**\n * FrequencyEstimator - Configuration holder for frequency estimation\n * \n * This class only holds configuration state. All actual frequency estimation\n * algorithms are implemented in Rust WASM (signal-processor-wasm module).\n * \n * Responsible for:\n * - Storing frequency estimation method configuration\n * - Storing buffer size multiplier setting\n * - Holding estimated frequency value (updated by WASM processor)\n * - Holding frequency plot history (updated by WASM processor)\n */\nexport class FrequencyEstimator {\n  private frequencyEstimationMethod: 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt' = 'fft';\n  private estimatedFrequency = 0;\n  private readonly MIN_FREQUENCY_HZ = 20; // Minimum detectable frequency (Hz)\n  private readonly MAX_FREQUENCY_HZ = 5000; // Maximum detectable frequency (Hz)\n  private bufferSizeMultiplier: 1 | 4 | 16 = 16; // Buffer size multiplier for extended FFT\n  private frequencyPlotHistory: number[] = []; // プロット用の推定周波数の履歴\n\n  /**\n   * Clear frequency history (e.g., when stopping)\n   */\n  clearHistory(): void {\n    this.frequencyPlotHistory = [];\n    this.estimatedFrequency = 0;\n  }\n\n  // Getters and setters\n  setFrequencyEstimationMethod(method: 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt'): void {\n    // Only clear frequency history if the method actually changes\n    if (this.frequencyEstimationMethod !== method) {\n      this.frequencyEstimationMethod = method;\n      // Clear frequency history when changing methods\n      this.frequencyPlotHistory = [];\n    }\n  }\n\n  getFrequencyEstimationMethod(): string {\n    return this.frequencyEstimationMethod;\n  }\n\n  setBufferSizeMultiplier(multiplier: 1 | 4 | 16): void {\n    this.bufferSizeMultiplier = multiplier;\n  }\n\n  getBufferSizeMultiplier(): 1 | 4 | 16 {\n    return this.bufferSizeMultiplier;\n  }\n\n  getEstimatedFrequency(): number {\n    return this.estimatedFrequency;\n  }\n\n  getMinFrequency(): number {\n    return this.MIN_FREQUENCY_HZ;\n  }\n\n  getMaxFrequency(): number {\n    return this.MAX_FREQUENCY_HZ;\n  }\n  \n  getFrequencyPlotHistory(): number[] {\n    return this.frequencyPlotHistory;\n  }\n}\n","/**\n * Layout configuration for overlay panels\n * Allows external applications to control the position and size of debug overlays\n */\n\n/**\n * Position configuration for an overlay\n */\nexport interface OverlayPosition {\n  /** X coordinate (in pixels or percentage string like '10%') */\n  x: number | string;\n  /** Y coordinate (in pixels or percentage string like '10%') */\n  y: number | string;\n}\n\n/**\n * Size configuration for an overlay\n */\nexport interface OverlaySize {\n  /** Width (in pixels or percentage string like '35%') */\n  width: number | string;\n  /** Height (in pixels or percentage string like '35%') */\n  height: number | string;\n}\n\n/**\n * Complete layout configuration for an overlay\n */\nexport interface OverlayLayout {\n  position: OverlayPosition;\n  size: OverlaySize;\n}\n\n/**\n * Layout configuration for all overlays\n */\nexport interface OverlaysLayoutConfig {\n  /** FFT spectrum overlay (bottom-left by default) */\n  fftOverlay?: OverlayLayout;\n  /** Harmonic analysis overlay (top-left by default) */\n  harmonicAnalysis?: OverlayLayout;\n  /** Frequency plot overlay (top-right by default) */\n  frequencyPlot?: OverlayLayout;\n}\n\n/**\n * Helper function to resolve position/size value\n * Converts percentage strings to actual pixel values based on canvas dimensions\n * @param value - Value to resolve (number or string)\n * @param canvasSize - Canvas dimension (width or height) in pixels\n * @returns Resolved pixel value\n */\nexport function resolveValue(value: number | string, canvasSize: number): number {\n  if (typeof value === 'string' && value.endsWith('%')) {\n    const percentage = parseFloat(value);\n    // Validate percentage value\n    if (isNaN(percentage)) {\n      console.warn(`Invalid percentage value: ${value}, using 0`);\n      return 0;\n    }\n    if (percentage < 0) {\n      console.warn(`Negative percentage value: ${value}, clamping to 0`);\n      return 0;\n    }\n    return Math.floor(canvasSize * (percentage / 100));\n  }\n  \n  if (typeof value === 'string') {\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed)) {\n      console.warn(`Invalid numeric string: ${value}, using 0`);\n      return 0;\n    }\n    return Math.max(0, parsed); // Clamp negative values to 0\n  }\n  \n  if (typeof value === 'number') {\n    if (isNaN(value)) {\n      console.warn(`Invalid number value: ${value}, using 0`);\n      return 0;\n    }\n    return Math.max(0, Math.floor(value)); // Clamp negative values to 0\n  }\n  \n  return 0;\n}\n\n/**\n * Default layout configuration\n */\nexport const DEFAULT_OVERLAYS_LAYOUT: OverlaysLayoutConfig = {\n  fftOverlay: {\n    position: { x: 10, y: '65%' },\n    size: { width: '35%', height: '35%' }\n  },\n  harmonicAnalysis: {\n    position: { x: 10, y: 10 },\n    size: { width: 500, height: 'auto' }\n  },\n  frequencyPlot: {\n    position: { x: 'right-10', y: 10 },\n    size: { width: 280, height: 120 }\n  }\n};\n","import { OverlayLayout, resolveValue } from '../OverlayLayout';\n\n/**\n * BaseOverlayRenderer provides common functionality for overlay renderers\n * Handles overlay dimension calculations based on layout configuration\n */\nexport abstract class BaseOverlayRenderer {\n  protected ctx: CanvasRenderingContext2D;\n  protected canvasWidth: number;\n  protected canvasHeight: number;\n\n  constructor(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {\n    this.ctx = ctx;\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n  }\n\n  /**\n   * Update canvas dimensions (call when canvas size changes)\n   */\n  updateDimensions(width: number, height: number): void {\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n\n  /**\n   * Helper method to calculate overlay dimensions based on layout config\n   */\n  protected calculateOverlayDimensions(\n    layout: OverlayLayout | undefined,\n    defaultX: number,\n    defaultY: number,\n    defaultWidth: number,\n    defaultHeight: number\n  ): { x: number; y: number; width: number; height: number } {\n    if (!layout) {\n      return { x: defaultX, y: defaultY, width: defaultWidth, height: defaultHeight };\n    }\n\n    let x = defaultX;\n    let y = defaultY;\n    let width = defaultWidth;\n    let height = defaultHeight;\n\n    // Resolve X position\n    if (layout.position.x !== undefined) {\n      if (typeof layout.position.x === 'string' && layout.position.x.startsWith('right-')) {\n        const offset = parseInt(layout.position.x.substring(6), 10);\n        const resolvedWidth =\n          layout.size.width !== undefined && layout.size.width !== 'auto'\n            ? resolveValue(layout.size.width, this.canvasWidth)\n            : defaultWidth;\n        x = this.canvasWidth - resolvedWidth - offset;\n      } else {\n        x = resolveValue(layout.position.x, this.canvasWidth);\n      }\n    }\n\n    // Resolve Y position\n    if (layout.position.y !== undefined) {\n      y = resolveValue(layout.position.y, this.canvasHeight);\n    }\n\n    // Resolve width\n    if (layout.size.width !== undefined && layout.size.width !== 'auto') {\n      width = resolveValue(layout.size.width, this.canvasWidth);\n    }\n\n    // Resolve height\n    if (layout.size.height !== undefined && layout.size.height !== 'auto') {\n      height = resolveValue(layout.size.height, this.canvasHeight);\n    }\n\n    return { x, y, width, height };\n  }\n}\n","import { amplitudeToDb } from '../utils';\n\n/**\n * GridRenderer handles grid and measurement label rendering\n * Responsible for:\n * - Grid line rendering\n * - Time axis labels\n * - Amplitude axis labels (in dB format)\n */\nexport class GridRenderer {\n  private ctx: CanvasRenderingContext2D;\n  private canvasWidth: number;\n  private canvasHeight: number;\n\n  constructor(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {\n    this.ctx = ctx;\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n  }\n\n  /**\n   * Update canvas dimensions (call when canvas size changes)\n   */\n  updateDimensions(width: number, height: number): void {\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n\n  /**\n   * Draw grid lines with measurement labels\n   * @param sampleRate - Audio sample rate in Hz (optional)\n   * @param displaySamples - Number of samples displayed on screen (optional)\n   * @param gain - Current gain multiplier (optional)\n   */\n  drawGrid(sampleRate?: number, displaySamples?: number, gain?: number): void {\n    this.ctx.strokeStyle = '#222222';\n    this.ctx.lineWidth = 1;\n    this.ctx.beginPath();\n\n    // Horizontal lines (amplitude divisions)\n    const horizontalLines = 5;\n    for (let i = 0; i <= horizontalLines; i++) {\n      const y = (this.canvasHeight / horizontalLines) * i;\n      this.ctx.moveTo(0, y);\n      this.ctx.lineTo(this.canvasWidth, y);\n    }\n\n    // Vertical lines (time divisions)\n    const verticalLines = 10;\n    for (let i = 0; i <= verticalLines; i++) {\n      const x = (this.canvasWidth / verticalLines) * i;\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.canvasHeight);\n    }\n\n    this.ctx.stroke();\n\n    // Center line (zero line)\n    this.ctx.strokeStyle = '#444444';\n    this.ctx.lineWidth = 1;\n    this.ctx.beginPath();\n    this.ctx.moveTo(0, this.canvasHeight / 2);\n    this.ctx.lineTo(this.canvasWidth, this.canvasHeight / 2);\n    this.ctx.stroke();\n\n    // Draw measurement labels if data is available and valid\n    if (sampleRate && sampleRate > 0 && displaySamples && displaySamples > 0 && gain !== undefined && gain > 0) {\n      this.drawGridLabels(sampleRate, displaySamples, gain);\n    }\n  }\n\n  /**\n   * Draw grid measurement labels\n   * @param sampleRate - Audio sample rate in Hz\n   * @param displaySamples - Number of samples displayed on screen\n   * @param gain - Current gain multiplier\n   */\n  private drawGridLabels(sampleRate: number, displaySamples: number, gain: number): void {\n    this.ctx.save();\n    this.ctx.font = '11px monospace';\n    this.ctx.fillStyle = '#666666';\n\n    // Calculate time per division (vertical grid spacing)\n    const displayTimeMs = (displaySamples / sampleRate) * 1000; // Total display time in ms\n    const verticalLines = 10;\n    const timePerDivision = displayTimeMs / verticalLines;\n\n    // Draw time labels at the bottom of the canvas\n    for (let i = 0; i <= verticalLines; i++) {\n      const x = (this.canvasWidth / verticalLines) * i;\n      const timeMs = timePerDivision * i;\n      \n      let label: string;\n      if (timeMs >= 1000) {\n        label = `${(timeMs / 1000).toFixed(2)}s`;\n      } else if (timeMs >= 1) {\n        label = `${timeMs.toFixed(1)}ms`;\n      } else {\n        label = `${(timeMs * 1000).toFixed(0)}μs`;\n      }\n      \n      // Draw label at bottom, slightly offset to avoid overlap\n      const textWidth = this.ctx.measureText(label).width;\n      const labelX = Math.max(2, Math.min(x - textWidth / 2, this.canvasWidth - textWidth - 2));\n      this.ctx.fillText(label, labelX, this.canvasHeight - 3);\n    }\n\n    // Calculate amplitude per division (horizontal grid spacing)\n    // The canvas height represents ±1.0 raw amplitude scaled by gain\n    // Each division from center represents: (canvasHeight/2) / (horizontalLines/2) pixels\n    const horizontalLines = 5;\n    const divisionsFromCenter = horizontalLines / 2; // 2.5 divisions from center to edge\n    const amplitudePerDivision = 1.0 / (divisionsFromCenter * gain); // Raw amplitude per division\n\n    // Draw amplitude labels on the left side (in dB format)\n    for (let i = 0; i <= horizontalLines; i++) {\n      const y = (this.canvasHeight / horizontalLines) * i;\n      // Calculate amplitude: center is 0, top is positive, bottom is negative\n      const divisionsFromCenterLine = (horizontalLines / 2) - i;\n      const amplitude = divisionsFromCenterLine * amplitudePerDivision;\n      \n      let label: string;\n      if (amplitude === 0) {\n        // Center line is -Infinity dB in theory, but we show it as a reference\n        label = '0dB*';\n      } else {\n        const db = amplitudeToDb(Math.abs(amplitude));\n        // The sign indicates waveform polarity (top=positive, bottom=negative)\n        // The dB magnitude is calculated from absolute amplitude\n        const sign = amplitude > 0 ? '+' : '-';\n        const absDb = Math.abs(db);\n        if (absDb >= 100) {\n          label = `${sign}${absDb.toFixed(0)}dB`;\n        } else {\n          label = `${sign}${absDb.toFixed(1)}dB`;\n        }\n      }\n      \n      // Draw label on left side with padding\n      this.ctx.fillText(label, 3, y + 10);\n    }\n\n    this.ctx.restore();\n  }\n}\n","/**\n * WaveformLineRenderer handles waveform line drawing\n * Responsible for:\n * - Drawing the main waveform signal as a line\n */\nexport class WaveformLineRenderer {\n  private ctx: CanvasRenderingContext2D;\n  private canvasWidth: number;\n  private canvasHeight: number;\n\n  constructor(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {\n    this.ctx = ctx;\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n  }\n\n  /**\n   * Update canvas dimensions (call when canvas size changes)\n   */\n  updateDimensions(width: number, height: number): void {\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n\n  /**\n   * Draw waveform\n   */\n  drawWaveform(data: Float32Array, startIndex: number, endIndex: number, gain: number): void {\n    const dataLength = endIndex - startIndex;\n    if (dataLength <= 0) return;\n\n    this.ctx.strokeStyle = '#00ff00';\n    this.ctx.lineWidth = 2;\n    this.ctx.beginPath();\n\n    const sliceWidth = this.canvasWidth / dataLength;\n    const centerY = this.canvasHeight / 2;\n    const baseAmplitude = this.canvasHeight / 2;\n    const amplitude = baseAmplitude * gain;\n\n    for (let i = 0; i < dataLength; i++) {\n      const dataIndex = startIndex + i;\n      const value = data[dataIndex];\n      const rawY = centerY - (value * amplitude);\n      const y = Math.min(this.canvasHeight, Math.max(0, rawY));\n      const x = i * sliceWidth;\n\n      if (i === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n\n    this.ctx.stroke();\n  }\n}\n","import { OverlayLayout } from '../OverlayLayout';\nimport { BaseOverlayRenderer } from './BaseOverlayRenderer';\n\n/**\n * FFTOverlayRenderer handles FFT spectrum overlay rendering\n * Responsible for:\n * - Drawing FFT spectrum bars\n * - Drawing fundamental frequency marker\n */\nexport class FFTOverlayRenderer extends BaseOverlayRenderer {\n  private readonly FFT_OVERLAY_HEIGHT_RATIO = 0.9; // Spectrum bar height ratio within overlay (90%)\n  private readonly FFT_MIN_BAR_WIDTH = 1; // Minimum bar width in pixels\n\n  /**\n   * Draw FFT spectrum overlay (position and size configurable via layout)\n   */\n  drawFFTOverlay(\n    frequencyData: Uint8Array,\n    estimatedFrequency: number,\n    sampleRate: number,\n    fftSize: number,\n    maxFrequency: number,\n    layout?: OverlayLayout\n  ): void {\n    const binFrequency = sampleRate / fftSize;\n\n    // Calculate overlay dimensions using layout config\n    const defaultOverlayWidth = Math.floor(this.canvasWidth * 0.35);\n    const defaultOverlayHeight = Math.floor(this.canvasHeight * 0.35);\n    const defaultOverlayX = 10;\n    const defaultOverlayY = this.canvasHeight - defaultOverlayHeight - 10;\n\n    const { x: overlayX, y: overlayY, width: overlayWidth, height: overlayHeight } = this.calculateOverlayDimensions(\n      layout,\n      defaultOverlayX,\n      defaultOverlayY,\n      defaultOverlayWidth,\n      defaultOverlayHeight\n    );\n\n    // Draw semi-transparent background\n    this.ctx.save();\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // Draw border\n    this.ctx.strokeStyle = '#00aaff';\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // Draw spectrum bars (only up to maxFrequency)\n    const maxBin = Math.min(\n      frequencyData.length,\n      Math.ceil(maxFrequency / binFrequency)\n    );\n    const barWidth = overlayWidth / maxBin;\n\n    this.ctx.fillStyle = '#00aaff';\n    for (let i = 0; i < maxBin; i++) {\n      const magnitude = frequencyData[i];\n      const barHeight = (magnitude / 255) * overlayHeight * this.FFT_OVERLAY_HEIGHT_RATIO;\n      const x = overlayX + i * barWidth;\n      const y = overlayY + overlayHeight - barHeight;\n\n      this.ctx.fillRect(x, y, Math.max(barWidth - 1, this.FFT_MIN_BAR_WIDTH), barHeight);\n    }\n\n    // Draw fundamental frequency marker\n    if (estimatedFrequency > 0 && estimatedFrequency <= maxFrequency) {\n      const frequencyBin = estimatedFrequency / binFrequency;\n      const markerX = overlayX + frequencyBin * barWidth;\n\n      this.ctx.strokeStyle = '#ff00ff';\n      this.ctx.lineWidth = 2;\n      this.ctx.beginPath();\n      this.ctx.moveTo(markerX, overlayY);\n      this.ctx.lineTo(markerX, overlayY + overlayHeight);\n      this.ctx.stroke();\n\n      // Draw frequency label\n      this.ctx.fillStyle = '#ff00ff';\n      this.ctx.font = 'bold 12px Arial';\n      const label = `${estimatedFrequency.toFixed(1)} Hz`;\n      const textWidth = this.ctx.measureText(label).width;\n      \n      // Position label to avoid going off canvas\n      let labelX = markerX + 3;\n      if (labelX + textWidth > overlayX + overlayWidth - 5) {\n        labelX = markerX - textWidth - 3;\n      }\n      \n      this.ctx.fillText(label, labelX, overlayY + 15);\n    }\n\n    this.ctx.restore();\n  }\n}\n","import { OverlayLayout } from '../OverlayLayout';\nimport { BaseOverlayRenderer } from './BaseOverlayRenderer';\n\n/**\n * HarmonicAnalysisRenderer handles harmonic analysis overlay rendering\n * Responsible for:\n * - Displaying debugging information about frequency estimation\n */\nexport class HarmonicAnalysisRenderer extends BaseOverlayRenderer {\n\n  /**\n   * Draw harmonic analysis information overlay\n   * Displays debugging information about frequency estimation when FFT method is used\n   * Position and size configurable via layout\n   */\n  drawHarmonicAnalysis(\n    halfFreqPeakStrengthPercent?: number,\n    candidate1Harmonics?: number[],\n    candidate2Harmonics?: number[],\n    candidate1WeightedScore?: number,\n    candidate2WeightedScore?: number,\n    selectionReason?: string,\n    estimatedFrequency?: number,\n    layout?: OverlayLayout\n  ): void {\n    // Only display if we have data to show\n    if (halfFreqPeakStrengthPercent === undefined && !candidate1Harmonics && !candidate2Harmonics && !selectionReason) {\n      return;\n    }\n    \n    // Calculate overlay dimensions using layout config\n    const lineHeight = 16;\n    const numLines = 1 + // Title\n                     (halfFreqPeakStrengthPercent !== undefined ? 1 : 0) +\n                     (candidate1Harmonics ? 1 : 0) +\n                     (candidate2Harmonics ? 1 : 0) +\n                     (selectionReason ? 2 : 0); // Selection reason might wrap\n    const defaultOverlayHeight = numLines * lineHeight + 10;\n\n    const { x: overlayX, y: overlayY, width: overlayWidth, height: overlayHeight } = this.calculateOverlayDimensions(\n      layout,\n      10,\n      10,\n      500,\n      defaultOverlayHeight\n    );\n\n    let currentY = overlayY;\n    \n    this.ctx.save();\n    \n    // Semi-transparent background\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n    \n    // Border\n    this.ctx.strokeStyle = '#ffaa00';\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n    \n    // Title\n    this.ctx.fillStyle = '#ffaa00';\n    this.ctx.font = 'bold 12px monospace';\n    currentY += 15;\n    this.ctx.fillText('倍音分析 (Harmonic Analysis)', overlayX + 5, currentY);\n    \n    // Half frequency peak strength\n    if (halfFreqPeakStrengthPercent !== undefined && estimatedFrequency) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#00ff00';\n      this.ctx.font = '11px monospace';\n      const halfFreq = estimatedFrequency / 2.0;\n      this.ctx.fillText(\n        `1/2周波数 (${halfFreq.toFixed(1)}Hz) のpeak強度: ${halfFreqPeakStrengthPercent.toFixed(1)}%`,\n        overlayX + 5,\n        currentY\n      );\n    }\n    \n    // Candidate 1 harmonics\n    if (candidate1Harmonics && estimatedFrequency) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#ff00ff';\n      this.ctx.font = '11px monospace';\n      const harmonicsStr = candidate1Harmonics.map((v, i) => `${i+1}x:${v.toFixed(2)}`).join(' ');\n      const weightedStr = candidate1WeightedScore !== undefined ? ` (重み付け: ${candidate1WeightedScore.toFixed(1)})` : '';\n      this.ctx.fillText(\n        `候補1 (${estimatedFrequency.toFixed(1)}Hz) 倍音: ${harmonicsStr}${weightedStr}`,\n        overlayX + 5,\n        currentY\n      );\n    }\n    \n    // Candidate 2 harmonics\n    if (candidate2Harmonics && estimatedFrequency) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#00aaff';\n      this.ctx.font = '11px monospace';\n      const halfFreq = estimatedFrequency / 2.0;\n      const harmonicsStr = candidate2Harmonics.map((v, i) => `${i+1}x:${v.toFixed(2)}`).join(' ');\n      const weightedStr = candidate2WeightedScore !== undefined ? ` (重み付け: ${candidate2WeightedScore.toFixed(1)})` : '';\n      this.ctx.fillText(\n        `候補2 (${halfFreq.toFixed(1)}Hz) 倍音: ${harmonicsStr}${weightedStr}`,\n        overlayX + 5,\n        currentY\n      );\n    }\n    \n    // Selection reason\n    if (selectionReason) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#aaaaaa';\n      this.ctx.font = '10px monospace';\n      // Wrap text if too long\n      const maxWidth = overlayWidth - 10;\n      const words = selectionReason.split(' ');\n      let line = '';\n      \n      for (const word of words) {\n        const testLine = line + (line ? ' ' : '') + word;\n        const metrics = this.ctx.measureText(testLine);\n        \n        if (metrics.width > maxWidth && line) {\n          this.ctx.fillText(line, overlayX + 5, currentY);\n          currentY += lineHeight;\n          line = word;\n        } else {\n          line = testLine;\n        }\n      }\n      \n      if (line) {\n        this.ctx.fillText(line, overlayX + 5, currentY);\n      }\n    }\n    \n    this.ctx.restore();\n  }\n}\n","import { frequencyToNote } from '../utils';\nimport { OverlayLayout } from '../OverlayLayout';\nimport { BaseOverlayRenderer } from './BaseOverlayRenderer';\n\n/**\n * FrequencyPlotRenderer handles frequency plot overlay rendering\n * Responsible for:\n * - Displaying frequency history plot\n * - Detecting frequency spikes\n */\nexport class FrequencyPlotRenderer extends BaseOverlayRenderer {\n  private readonly FREQ_PLOT_MIN_RANGE_PADDING_HZ = 50; // 周波数範囲の最小パディング (Hz)\n  private readonly FREQ_PLOT_RANGE_PADDING_RATIO = 0.1; // 周波数範囲のパディング比率 (10%)\n\n  /**\n   * Draw frequency plot overlay\n   * Position and size configurable via layout\n   * Displays frequency history to detect frequency spikes\n   * One data point is added per frame\n   */\n  drawFrequencyPlot(\n    frequencyHistory: number[],\n    minFrequency: number,\n    maxFrequency: number,\n    layout?: OverlayLayout\n  ): void {\n    if (!frequencyHistory || frequencyHistory.length === 0) {\n      return;\n    }\n\n    // Calculate overlay dimensions using layout config\n    const { x: overlayX, y: overlayY, width: overlayWidth, height: overlayHeight } = this.calculateOverlayDimensions(\n      layout,\n      this.canvasWidth - 280 - 10,\n      10,\n      280,\n      120\n    );\n\n    // Draw semi-transparent background\n    this.ctx.save();\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // Draw border\n    this.ctx.strokeStyle = '#ffaa00';\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // タイトルを描画（フレーム数を含む）\n    this.ctx.fillStyle = '#ffaa00';\n    this.ctx.font = 'bold 12px Arial';\n    this.ctx.fillText(`周波数推移 (${frequencyHistory.length}frame)`, overlayX + 5, overlayY + 15);\n\n    // プロット領域を計算（タイトルと軸ラベルのためのスペースを確保）\n    const plotX = overlayX + 35;\n    const plotY = overlayY + 25;\n    const plotWidth = overlayWidth - 45;\n    const plotHeight = overlayHeight - 45; // X軸ラベル用にスペースを増やす\n\n    // データ内の周波数範囲を検出（ゼロ値を除外）\n    const validFrequencies = frequencyHistory.filter(f => f > 0);\n    if (validFrequencies.length === 0) {\n      this.ctx.restore();\n      return;\n    }\n\n    const dataMin = Math.min(...validFrequencies);\n    const dataMax = Math.max(...validFrequencies);\n    \n    // データ範囲にパディングを追加し、最小/最大周波数制限で制約\n    const rangePadding = (dataMax - dataMin) * this.FREQ_PLOT_RANGE_PADDING_RATIO || this.FREQ_PLOT_MIN_RANGE_PADDING_HZ;\n    const displayMin = Math.max(minFrequency, dataMin - rangePadding);\n    const displayMax = Math.min(maxFrequency, dataMax + rangePadding);\n\n    // グリッド線を描画（実データ範囲に基づく）\n    this.ctx.strokeStyle = '#333333';\n    this.ctx.lineWidth = 1;\n    this.ctx.beginPath();\n    \n    // 水平グリッド線（周波数軸に対応）\n    for (let i = 0; i <= 4; i++) {\n      const y = plotY + (plotHeight / 4) * i;\n      this.ctx.moveTo(plotX, y);\n      this.ctx.lineTo(plotX + plotWidth, y);\n    }\n    \n    // 垂直グリッド線\n    for (let i = 0; i <= 4; i++) {\n      const x = plotX + (plotWidth / 4) * i;\n      this.ctx.moveTo(x, plotY);\n      this.ctx.lineTo(x, plotY + plotHeight);\n    }\n    \n    this.ctx.stroke();\n\n    // Y軸ラベルを描画（周波数値 - 左側）\n    this.ctx.fillStyle = '#aaaaaa';\n    this.ctx.font = '10px monospace';\n    this.ctx.textAlign = 'right';\n    this.ctx.textBaseline = 'middle';\n    \n    for (let i = 0; i <= 4; i++) {\n      const freq = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const label = freq >= 1000 ? `${(freq / 1000).toFixed(1)}k` : `${freq.toFixed(0)}`;\n      this.ctx.fillText(label, plotX - 5, y);\n    }\n\n    // 右Y軸ラベルを描画（cent単位 - 各周波数の最寄り音符からの偏差）\n    this.ctx.fillStyle = '#88ccff';\n    this.ctx.font = '9px monospace';\n    this.ctx.textAlign = 'right';\n    this.ctx.textBaseline = 'middle';\n    \n    for (let i = 0; i <= 4; i++) {\n      const freq = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const noteInfo = frequencyToNote(freq);\n      if (noteInfo) {\n        const centsSign = noteInfo.cents >= 0 ? '+' : '';\n        this.ctx.fillText(`${centsSign}${noteInfo.cents}¢`, plotX + plotWidth - 5, y);\n      }\n    }\n\n    // 周波数プロットの線を描画\n    this.ctx.strokeStyle = '#00ff00';\n    this.ctx.lineWidth = 2;\n    this.ctx.beginPath();\n\n    const xStep = plotWidth / Math.max(frequencyHistory.length - 1, 1);\n    \n    // X軸ラベルのフォント設定を事前に準備\n    const labelInterval = Math.max(1, Math.floor(frequencyHistory.length / 4));\n    \n    // Helper function: 周波数値をY座標に変換\n    const frequencyToY = (freq: number): number => {\n      const clampedFreq = Math.max(displayMin, Math.min(displayMax, freq));\n      const normalizedFreq = (clampedFreq - displayMin) / (displayMax - displayMin);\n      return plotY + plotHeight - (normalizedFreq * plotHeight);\n    };\n    \n    // 線を描画（状態管理が必要なため独立ループ）\n    let hasValidPoint = false;\n    for (let i = 0; i < frequencyHistory.length; i++) {\n      const freq = frequencyHistory[i];\n      const x = plotX + i * xStep;\n      \n      // ゼロ値（無信号）はスキップして描画しない\n      if (freq === 0) {\n        hasValidPoint = false;\n        continue;\n      }\n      \n      const y = frequencyToY(freq);\n      \n      // 線の描画\n      if (!hasValidPoint) {\n        this.ctx.moveTo(x, y);\n        hasValidPoint = true;\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n    \n    this.ctx.stroke();\n    \n    // データポイントマーカーとX軸ラベルを描画（統合ループ）\n    this.ctx.font = '9px monospace';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'top';\n    \n    for (let i = 0; i < frequencyHistory.length; i++) {\n      const freq = frequencyHistory[i];\n      const x = plotX + i * xStep;\n      \n      // データポイントマーカーを描画（周波数値が0でない場合）\n      if (freq !== 0) {\n        const y = frequencyToY(freq);\n        \n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, 2, 0, Math.PI * 2);\n        this.ctx.fill();\n      }\n      \n      // X軸ラベルを描画（labelIntervalごと、または最新フレーム）\n      const isLatestFrame = i === frequencyHistory.length - 1;\n      const shouldDrawLabel = (i % labelInterval === 0) || isLatestFrame;\n      \n      if (shouldDrawLabel) {\n        this.ctx.fillStyle = '#aaaaaa';\n        // 最新のフレームからの相対位置を表示（例：-50, -25, 0）\n        const frameOffset = i - frequencyHistory.length + 1;\n        this.ctx.fillText(`${frameOffset}`, x, plotY + plotHeight + 2);\n      }\n    }\n\n    // 現在の周波数値とcent偏差を描画 (inside plot area at bottom)\n    const currentFreq = frequencyHistory[frequencyHistory.length - 1];\n    if (currentFreq > 0) {\n      const noteInfo = frequencyToNote(currentFreq);\n      this.ctx.fillStyle = '#00ff00';\n      this.ctx.font = 'bold 11px Arial';\n      this.ctx.textAlign = 'left';\n      this.ctx.textBaseline = 'bottom';\n      \n      let displayText = `${currentFreq.toFixed(1)} Hz`;\n      if (noteInfo) {\n        const centsSign = noteInfo.cents >= 0 ? '+' : '';\n        displayText += ` (${noteInfo.noteName} ${centsSign}${noteInfo.cents}¢)`;\n      }\n      this.ctx.fillText(displayText, plotX + 2, plotY + plotHeight - 2);\n    }\n\n    this.ctx.restore();\n  }\n}\n","/**\n * PhaseMarkerRenderer handles phase marker rendering\n * Responsible for:\n * - Drawing phase markers on the waveform\n * - Drawing debug information for phase tracking\n */\nexport class PhaseMarkerRenderer {\n  private ctx: CanvasRenderingContext2D;\n  private canvasWidth: number;\n  private canvasHeight: number;\n  private debugOverlaysEnabled: boolean;\n\n  constructor(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number, debugOverlaysEnabled = true) {\n    this.ctx = ctx;\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n    this.debugOverlaysEnabled = debugOverlaysEnabled;\n  }\n\n  /**\n   * Update canvas dimensions (call when canvas size changes)\n   */\n  updateDimensions(width: number, height: number): void {\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n\n  /**\n   * Set debug overlays enabled state\n   */\n  setDebugOverlaysEnabled(enabled: boolean): void {\n    this.debugOverlaysEnabled = enabled;\n  }\n\n  /**\n   * Draw phase markers on the waveform\n   * @param phaseZeroIndex - Sample index for phase 0 (red line)\n   * @param phaseTwoPiIndex - Sample index for phase 2π (red line)\n   * @param phaseMinusQuarterPiIndex - Sample index for phase -π/4 (orange line)\n   * @param phaseTwoPiPlusQuarterPiIndex - Sample index for phase 2π+π/4 (orange line)\n   * @param displayStartIndex - Start index of the displayed region\n   * @param displayEndIndex - End index of the displayed region\n   * @param debugInfo - Optional debug information for phase tracking\n   */\n  drawPhaseMarkers(\n    phaseZeroIndex?: number,\n    phaseTwoPiIndex?: number,\n    phaseMinusQuarterPiIndex?: number,\n    phaseTwoPiPlusQuarterPiIndex?: number,\n    displayStartIndex?: number,\n    displayEndIndex?: number,\n    debugInfo?: {\n      phaseZeroSegmentRelative?: number;\n      phaseZeroHistory?: number;\n      phaseZeroTolerance?: number;\n      zeroCrossModeName?: string;\n    }\n  ): void {\n    if (displayStartIndex === undefined || displayEndIndex === undefined) {\n      return;\n    }\n\n    const displayLength = displayEndIndex - displayStartIndex;\n    if (displayLength <= 0) {\n      return;\n    }\n\n    this.ctx.save();\n\n    // Helper function to draw a vertical line at a given sample index\n    const drawVerticalLine = (sampleIndex: number, color: string, lineWidth: number) => {\n      // Convert sample index to canvas x coordinate\n      const relativeIndex = sampleIndex - displayStartIndex;\n      if (relativeIndex < 0 || relativeIndex >= displayLength) {\n        return; // Index is outside the displayed region\n      }\n\n      const x = (relativeIndex / displayLength) * this.canvasWidth;\n\n      this.ctx.strokeStyle = color;\n      this.ctx.lineWidth = lineWidth;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.canvasHeight);\n      this.ctx.stroke();\n    };\n\n    // Draw orange lines first (so red lines appear on top)\n    if (phaseMinusQuarterPiIndex !== undefined) {\n      drawVerticalLine(phaseMinusQuarterPiIndex, '#ff8800', 2);\n    }\n\n    if (phaseTwoPiPlusQuarterPiIndex !== undefined) {\n      drawVerticalLine(phaseTwoPiPlusQuarterPiIndex, '#ff8800', 2);\n    }\n\n    // Draw red lines\n    if (phaseZeroIndex !== undefined) {\n      drawVerticalLine(phaseZeroIndex, '#ff0000', 2);\n      \n      // Add debug information if available (issue #220)\n      if (this.debugOverlaysEnabled && debugInfo?.phaseZeroSegmentRelative !== undefined) {\n        const relativeIndex = phaseZeroIndex - displayStartIndex;\n        const x = (relativeIndex / displayLength) * this.canvasWidth;\n        const y = 20; // Position near top\n        \n        this.ctx.save();\n        this.ctx.fillStyle = '#ff0000';\n        this.ctx.font = '12px monospace';\n        this.ctx.textAlign = 'left';\n        \n        const segRel = debugInfo.phaseZeroSegmentRelative;\n        const history = debugInfo.phaseZeroHistory ?? '?';\n        const tolerance = debugInfo.phaseZeroTolerance ?? '?';\n        const mode = debugInfo.zeroCrossModeName ?? 'Unknown';\n        \n        const debugText = [\n          `Mode: ${mode}`,\n          `Seg Rel: ${segRel}`,\n          `History: ${history}`,\n          `Tolerance: ±${tolerance}`,\n          `Range: ${typeof history === 'number' && typeof tolerance === 'number' \n            ? `${history - tolerance}~${history + tolerance}` : '?'}`\n        ];\n        \n        debugText.forEach((text, i) => {\n          this.ctx.fillText(text, x + 5, y + i * 14);\n        });\n        \n        this.ctx.restore();\n      }\n    }\n\n    if (phaseTwoPiIndex !== undefined) {\n      drawVerticalLine(phaseTwoPiIndex, '#ff0000', 2);\n    }\n\n    this.ctx.restore();\n  }\n}\n","import { OverlaysLayoutConfig, DEFAULT_OVERLAYS_LAYOUT } from './OverlayLayout';\nimport {\n  GridRenderer,\n  WaveformLineRenderer,\n  FFTOverlayRenderer,\n  HarmonicAnalysisRenderer,\n  FrequencyPlotRenderer,\n  PhaseMarkerRenderer,\n} from './renderers';\n\n/**\n * WaveformRenderer coordinates all canvas drawing operations\n * Acts as a facade that delegates to specialized renderer classes\n * Responsible for:\n * - Coordinating multiple renderer components\n * - Managing canvas state\n * - Providing a unified API for rendering\n */\nexport class WaveformRenderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private fftDisplayEnabled = true;\n  private harmonicAnalysisEnabled = false; // Control harmonic analysis overlay independently\n  private debugOverlaysEnabled = true; // Control debug overlays (harmonic analysis, frequency plot)\n  private overlaysLayout: OverlaysLayoutConfig; // Layout configuration for overlays\n\n  // Specialized renderers\n  private gridRenderer: GridRenderer;\n  private waveformLineRenderer: WaveformLineRenderer;\n  private fftOverlayRenderer: FFTOverlayRenderer;\n  private harmonicAnalysisRenderer: HarmonicAnalysisRenderer;\n  private frequencyPlotRenderer: FrequencyPlotRenderer;\n  private phaseMarkerRenderer: PhaseMarkerRenderer;\n\n  constructor(canvas: HTMLCanvasElement, overlaysLayout?: OverlaysLayoutConfig) {\n    this.canvas = canvas;\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get 2D context');\n    }\n    this.ctx = context;\n    this.overlaysLayout = overlaysLayout || DEFAULT_OVERLAYS_LAYOUT;\n    \n    // Initialize specialized renderers\n    this.gridRenderer = new GridRenderer(this.ctx, canvas.width, canvas.height);\n    this.waveformLineRenderer = new WaveformLineRenderer(this.ctx, canvas.width, canvas.height);\n    this.fftOverlayRenderer = new FFTOverlayRenderer(this.ctx, canvas.width, canvas.height);\n    this.harmonicAnalysisRenderer = new HarmonicAnalysisRenderer(this.ctx, canvas.width, canvas.height);\n    this.frequencyPlotRenderer = new FrequencyPlotRenderer(this.ctx, canvas.width, canvas.height);\n    this.phaseMarkerRenderer = new PhaseMarkerRenderer(this.ctx, canvas.width, canvas.height, this.debugOverlaysEnabled);\n    \n    // Warn if canvas is using default dimensions (300x150)\n    // This causes layout issues when CSS dimensions differ from canvas resolution\n    if (canvas.width === 300 && canvas.height === 150) {\n      console.warn(\n        'Canvas element is using default dimensions (300x150). ' +\n        'Set explicit width and height attributes on the canvas element to match desired resolution. ' +\n        'Example: <canvas id=\"oscilloscope\" width=\"1800\" height=\"1000\"></canvas>'\n      );\n    }\n  }\n\n  /**\n   * Clear canvas and draw grid with measurement labels\n   * @param sampleRate - Audio sample rate in Hz (optional)\n   * @param displaySamples - Number of samples displayed on screen (optional)\n   * @param gain - Current gain multiplier (optional)\n   */\n  clearAndDrawGrid(sampleRate?: number, displaySamples?: number, gain?: number): void {\n    // Update renderer dimensions if canvas size changed\n    this.updateRendererDimensions();\n    \n    // Clear canvas\n    this.ctx.fillStyle = '#000000';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Draw grid with labels using GridRenderer\n    this.gridRenderer.drawGrid(sampleRate, displaySamples, gain);\n  }\n\n  /**\n   * Update all renderer dimensions (call when canvas size changes)\n   */\n  private updateRendererDimensions(): void {\n    const width = this.canvas.width;\n    const height = this.canvas.height;\n    \n    this.gridRenderer.updateDimensions(width, height);\n    this.waveformLineRenderer.updateDimensions(width, height);\n    this.fftOverlayRenderer.updateDimensions(width, height);\n    this.harmonicAnalysisRenderer.updateDimensions(width, height);\n    this.frequencyPlotRenderer.updateDimensions(width, height);\n    this.phaseMarkerRenderer.updateDimensions(width, height);\n  }\n\n  /**\n   * Draw waveform\n   */\n  drawWaveform(data: Float32Array, startIndex: number, endIndex: number, gain: number): void {\n    this.updateRendererDimensions();\n    this.waveformLineRenderer.drawWaveform(data, startIndex, endIndex, gain);\n  }\n\n  /**\n   * Draw FFT spectrum overlay (position and size configurable via overlaysLayout)\n   */\n  drawFFTOverlay(frequencyData: Uint8Array, estimatedFrequency: number, sampleRate: number, fftSize: number, maxFrequency: number): void {\n    if (!this.fftDisplayEnabled) {\n      return;\n    }\n\n    this.updateRendererDimensions();\n    this.fftOverlayRenderer.drawFFTOverlay(\n      frequencyData,\n      estimatedFrequency,\n      sampleRate,\n      fftSize,\n      maxFrequency,\n      this.overlaysLayout.fftOverlay\n    );\n  }\n\n  /**\n   * Draw harmonic analysis information overlay\n   * Displays debugging information about frequency estimation when FFT method is used\n   * Position and size configurable via overlaysLayout\n   */\n  drawHarmonicAnalysis(\n    halfFreqPeakStrengthPercent?: number,\n    candidate1Harmonics?: number[],\n    candidate2Harmonics?: number[],\n    candidate1WeightedScore?: number,\n    candidate2WeightedScore?: number,\n    selectionReason?: string,\n    estimatedFrequency?: number\n  ): void {\n    // Skip if harmonic analysis display is disabled\n    if (!this.harmonicAnalysisEnabled) {\n      return;\n    }\n    \n    // Skip if debug overlays are disabled\n    if (!this.debugOverlaysEnabled) {\n      return;\n    }\n    \n    if (!this.fftDisplayEnabled) {\n      return;\n    }\n\n    this.updateRendererDimensions();\n    this.harmonicAnalysisRenderer.drawHarmonicAnalysis(\n      halfFreqPeakStrengthPercent,\n      candidate1Harmonics,\n      candidate2Harmonics,\n      candidate1WeightedScore,\n      candidate2WeightedScore,\n      selectionReason,\n      estimatedFrequency,\n      this.overlaysLayout.harmonicAnalysis\n    );\n  }\n\n  /**\n   * Draw frequency plot overlay\n   * Position and size configurable via overlaysLayout\n   * Displays frequency history to detect frequency spikes\n   * One data point is added per frame\n   */\n  drawFrequencyPlot(frequencyHistory: number[], minFrequency: number, maxFrequency: number): void {\n    // Skip if debug overlays are disabled\n    if (!this.debugOverlaysEnabled) {\n      return;\n    }\n\n    this.updateRendererDimensions();\n    this.frequencyPlotRenderer.drawFrequencyPlot(\n      frequencyHistory,\n      minFrequency,\n      maxFrequency,\n      this.overlaysLayout.frequencyPlot\n    );\n  }\n\n  /**\n   * Draw phase markers on the waveform\n   * @param phaseZeroIndex - Sample index for phase 0 (red line)\n   * @param phaseTwoPiIndex - Sample index for phase 2π (red line)\n   * @param phaseMinusQuarterPiIndex - Sample index for phase -π/4 (orange line)\n   * @param phaseTwoPiPlusQuarterPiIndex - Sample index for phase 2π+π/4 (orange line)\n   * @param displayStartIndex - Start index of the displayed region\n   * @param displayEndIndex - End index of the displayed region\n   * @param debugInfo - Optional debug information for phase tracking\n   */\n  drawPhaseMarkers(\n    phaseZeroIndex?: number,\n    phaseTwoPiIndex?: number,\n    phaseMinusQuarterPiIndex?: number,\n    phaseTwoPiPlusQuarterPiIndex?: number,\n    displayStartIndex?: number,\n    displayEndIndex?: number,\n    debugInfo?: {\n      phaseZeroSegmentRelative?: number;\n      phaseZeroHistory?: number;\n      phaseZeroTolerance?: number;\n      zeroCrossModeName?: string;\n    }\n  ): void {\n    this.updateRendererDimensions();\n    this.phaseMarkerRenderer.drawPhaseMarkers(\n      phaseZeroIndex,\n      phaseTwoPiIndex,\n      phaseMinusQuarterPiIndex,\n      phaseTwoPiPlusQuarterPiIndex,\n      displayStartIndex,\n      displayEndIndex,\n      debugInfo\n    );\n  }\n\n\n  // Getters and setters\n  setFFTDisplay(enabled: boolean): void {\n    this.fftDisplayEnabled = enabled;\n  }\n\n  getFFTDisplayEnabled(): boolean {\n    return this.fftDisplayEnabled;\n  }\n\n  /**\n   * Enable or disable harmonic analysis overlay\n   * When disabled, the yellow-bordered harmonic analysis panel is hidden\n   * @param enabled - true to show harmonic analysis overlay, false to hide it\n   */\n  setHarmonicAnalysisEnabled(enabled: boolean): void {\n    this.harmonicAnalysisEnabled = enabled;\n  }\n\n  /**\n   * Get the current state of harmonic analysis overlay\n   * @returns true if harmonic analysis overlay is enabled, false otherwise\n   */\n  getHarmonicAnalysisEnabled(): boolean {\n    return this.harmonicAnalysisEnabled;\n  }\n\n  /**\n   * Enable or disable debug overlays (harmonic analysis, frequency plot)\n   * When disabled, yellow-bordered debug information panels are hidden\n   * Recommended: Set to false when using as a library for cleaner display\n   * @param enabled - true to show debug overlays, false to hide them\n   */\n  setDebugOverlaysEnabled(enabled: boolean): void {\n    this.debugOverlaysEnabled = enabled;\n    this.phaseMarkerRenderer.setDebugOverlaysEnabled(enabled);\n  }\n\n  /**\n   * Get the current state of debug overlays\n   * @returns true if debug overlays are enabled, false otherwise\n   */\n  getDebugOverlaysEnabled(): boolean {\n    return this.debugOverlaysEnabled;\n  }\n\n  /**\n   * Set the layout configuration for overlays\n   * Allows external applications to control the position and size of debug overlays\n   * @param layout - Layout configuration for overlays\n   */\n  setOverlaysLayout(layout: OverlaysLayoutConfig): void {\n    this.overlaysLayout = { ...this.overlaysLayout, ...layout };\n  }\n\n  /**\n   * Get the current overlays layout configuration\n   * @returns Current overlays layout configuration\n   */\n  getOverlaysLayout(): OverlaysLayoutConfig {\n    return this.overlaysLayout;\n  }\n}\n","/**\n * ZeroCrossDetector - Configuration holder for zero-cross/peak detection\n * \n * This class only holds configuration state. All actual zero-crossing and peak\n * detection algorithms are implemented in Rust WASM (signal-processor-wasm module).\n * \n * Responsible for:\n * - Storing peak mode configuration (legacy compatibility)\n * - Storing zero-cross detection mode configuration\n */\nexport class ZeroCrossDetector {\n  private usePeakMode: boolean = false;\n  private zeroCrossMode: 'standard' | 'peak-backtrack-history' | 'bidirectional-nearest' | 'gradient-based' | 'adaptive-step' | 'hysteresis' | 'closest-to-zero' = 'hysteresis';\n\n  /**\n   * Set whether to use peak mode instead of zero-crossing mode\n   */\n  setUsePeakMode(enabled: boolean): void {\n    this.usePeakMode = enabled;\n  }\n\n  /**\n   * Get whether peak mode is enabled\n   */\n  getUsePeakMode(): boolean {\n    return this.usePeakMode;\n  }\n\n  /**\n   * Set zero-cross detection mode\n   * @param mode - Zero-cross detection algorithm to use\n   */\n  setZeroCrossMode(mode: 'standard' | 'peak-backtrack-history' | 'bidirectional-nearest' | 'gradient-based' | 'adaptive-step' | 'hysteresis' | 'closest-to-zero'): void {\n    this.zeroCrossMode = mode;\n  }\n\n  /**\n   * Get current zero-cross detection mode\n   */\n  getZeroCrossMode(): 'standard' | 'peak-backtrack-history' | 'bidirectional-nearest' | 'gradient-based' | 'adaptive-step' | 'hysteresis' | 'closest-to-zero' {\n    return this.zeroCrossMode;\n  }\n\n  /**\n   * Reset state (e.g., when stopping)\n   */\n  reset(): void {\n    // State is maintained in WASM, but this method is kept for API compatibility\n  }\n}\n","/**\n * Constants for waveform storage and search\n */\n\n/** Store 4 cycles worth of waveform data */\nexport const CYCLES_TO_STORE = 4;\n\n/** Search within 4 cycles range */\nexport const CYCLES_TO_SEARCH = 4;\n\n/**\n * WaveformSearcher - Configuration and state holder for waveform similarity search\n * \n * This class only holds state. All actual waveform similarity search\n * algorithms are implemented in Rust WASM (signal-processor-wasm module).\n * \n * Responsible for:\n * - Holding previous waveform data (updated by WASM processor)\n * - Holding last similarity score (updated by WASM processor)\n */\nexport class WaveformSearcher {\n  private previousWaveform: Float32Array | null = null;\n  private lastSimilarity: number = 0;\n\n  /**\n   * Get the last calculated similarity score\n   */\n  getLastSimilarity(): number {\n    return this.lastSimilarity;\n  }\n\n  /**\n   * Reset state (e.g., when stopping)\n   */\n  reset(): void {\n    this.previousWaveform = null;\n    this.lastSimilarity = 0;\n  }\n\n  /**\n   * Check if previous waveform exists\n   */\n  hasPreviousWaveform(): boolean {\n    return this.previousWaveform !== null;\n  }\n\n  /**\n   * Get the previous waveform (for debugging/visualization)\n   */\n  getPreviousWaveform(): Float32Array | null {\n    return this.previousWaveform;\n  }\n}\n","/**\n * WaveformPanelRenderer - Responsible for drawing waveforms on comparison panels\n * Handles auto-scaling and center line drawing\n */\nexport class WaveformPanelRenderer {\n  // Auto-scaling constants\n  private readonly TARGET_FILL_RATIO = 0.9;    // Target 90% of distance from center to edge (canvas half-height) for auto-scaled waveforms\n  private readonly MIN_PEAK_THRESHOLD = 0.001; // Minimum peak to trigger auto-scaling (below this uses default)\n  private readonly DEFAULT_AMPLITUDE_RATIO = 0.4; // Default scaling factor when peak is too small\n\n  /**\n   * Calculate peak amplitude in a given range of data\n   * Used for auto-scaling waveforms to fill the vertical space\n   */\n  private findPeakAmplitude(\n    data: Float32Array,\n    startIndex: number,\n    endIndex: number\n  ): number {\n    let peak = 0;\n    const clampedStart = Math.max(0, startIndex);\n    const clampedEnd = Math.min(data.length, endIndex);\n\n    for (let i = clampedStart; i < clampedEnd; i++) {\n      const value = Math.abs(data[i]);\n      if (value > peak) {\n        peak = value;\n      }\n    }\n\n    return peak;\n  }\n\n  /**\n   * Draw a waveform on a canvas with auto-scaling\n   * Waveforms are automatically scaled so that peaks reach 90% of the distance\n   * from the vertical center line to the top/bottom edge (i.e. 90% of half the height).\n   * For example, if peak amplitude is 0.01, it will be scaled 90x relative to that center-to-edge range.\n   */\n  drawWaveform(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    data: Float32Array,\n    startIndex: number,\n    endIndex: number,\n    color: string\n  ): void {\n    const dataLength = endIndex - startIndex;\n    if (dataLength <= 0) return;\n\n    // Find peak amplitude for auto-scaling\n    const peak = this.findPeakAmplitude(data, startIndex, endIndex);\n    \n    ctx.strokeStyle = color;\n    ctx.lineWidth = 1.5;\n    ctx.beginPath();\n\n    const sliceWidth = width / dataLength;\n    const centerY = height / 2;\n    \n    // Auto-scale so peaks reach 90% of distance from center to edge (90% of half-height)\n    // If peak is 0 or very small (< MIN_PEAK_THRESHOLD), use default scaling to avoid division by zero\n    let amplitude: number;\n    \n    if (peak > this.MIN_PEAK_THRESHOLD) {\n      // Calculate scaling factor so peak reaches TARGET_FILL_RATIO of the distance from center to edge\n      const scalingFactor = this.TARGET_FILL_RATIO / peak;\n      amplitude = (height / 2) * scalingFactor;\n    } else {\n      // For very small or zero signals, use default scaling\n      amplitude = height * this.DEFAULT_AMPLITUDE_RATIO;\n    }\n\n    for (let i = 0; i < dataLength; i++) {\n      const dataIndex = startIndex + i;\n      if (dataIndex >= data.length) break;\n      \n      const value = data[dataIndex];\n      const rawY = centerY - (value * amplitude);\n      const y = Math.min(height, Math.max(0, rawY));\n      const x = i * sliceWidth;\n\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    ctx.stroke();\n  }\n\n  /**\n   * Draw center line on canvas\n   */\n  drawCenterLine(ctx: CanvasRenderingContext2D, width: number, height: number): void {\n    ctx.strokeStyle = '#444444';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(0, height / 2);\n    ctx.lineTo(width, height / 2);\n    ctx.stroke();\n  }\n\n  /**\n   * Clear a canvas\n   */\n  clearCanvas(ctx: CanvasRenderingContext2D, width: number, height: number): void {\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, width, height);\n  }\n}\n","/**\n * SimilarityPlotRenderer - Responsible for drawing similarity history plots\n * Displays time-series changes in similarity to detect instantaneous drops\n */\nexport class SimilarityPlotRenderer {\n  /**\n   * Draw similarity history plot on similarity canvas\n   * 類似度の時系列変化を表示し、瞬間的な類似度低下を検出しやすくする\n   * \n   * @param ctx - Canvas 2D rendering context\n   * @param width - Canvas width\n   * @param height - Canvas height\n   * @param similarityHistory - Array of correlation coefficients (-1.0 to 1.0).\n   *                            Values are ordered chronologically from oldest to newest.\n   */\n  drawSimilarityPlot(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    similarityHistory: number[]\n  ): void {\n    if (!similarityHistory || similarityHistory.length === 0) {\n      return;\n    }\n\n    // Clear and draw background\n    ctx.save();\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw border\n    ctx.strokeStyle = '#00aaff';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, 0, width, height);\n\n    // Title\n    ctx.fillStyle = '#00aaff';\n    ctx.font = 'bold 12px Arial';\n    ctx.fillText('類似度推移 (Similarity)', 5, 15);\n\n    // Calculate plot area (reserve space for title and axis labels)\n    const plotX = 40;\n    const plotY = 25;\n    const plotWidth = width - 50;\n    const plotHeight = height - 35;\n\n    // Similarity range is -1.0 to 1.0 (correlation coefficient range)\n    const displayMin = -1.0;\n    const displayMax = 1.0;\n\n    // Draw grid lines\n    ctx.strokeStyle = '#333333';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    \n    // Horizontal grid lines (corresponding to similarity axis)\n    for (let i = 0; i <= 4; i++) {\n      const y = plotY + (plotHeight / 4) * i;\n      ctx.moveTo(plotX, y);\n      ctx.lineTo(plotX + plotWidth, y);\n    }\n    \n    // Vertical grid lines\n    for (let i = 0; i <= 4; i++) {\n      const x = plotX + (plotWidth / 4) * i;\n      ctx.moveTo(x, plotY);\n      ctx.lineTo(x, plotY + plotHeight);\n    }\n    \n    ctx.stroke();\n\n    // Draw Y-axis labels (similarity values)\n    ctx.fillStyle = '#aaaaaa';\n    ctx.font = '10px monospace';\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'middle';\n    \n    for (let i = 0; i <= 4; i++) {\n      const similarity = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const label = similarity.toFixed(2);\n      ctx.fillText(label, plotX - 5, y);\n    }\n\n    // Draw similarity plot line\n    ctx.strokeStyle = '#00aaff';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n\n    const xStep = plotWidth / Math.max(similarityHistory.length - 1, 1);\n    \n    for (let i = 0; i < similarityHistory.length; i++) {\n      const similarity = similarityHistory[i];\n      const x = plotX + i * xStep;\n      \n      // Clamp similarity to display range\n      const clampedSimilarity = Math.max(displayMin, Math.min(displayMax, similarity));\n      \n      // Map similarity to Y coordinate (inverted: high similarity = top)\n      const normalizedSimilarity = (clampedSimilarity - displayMin) / (displayMax - displayMin);\n      const y = plotY + plotHeight - (normalizedSimilarity * plotHeight);\n      \n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n    \n    ctx.stroke();\n\n    // Draw current similarity value (inside plot area at bottom left)\n    const currentSimilarity = similarityHistory[similarityHistory.length - 1];\n    ctx.fillStyle = '#00aaff';\n    ctx.font = 'bold 11px Arial';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'bottom';\n    ctx.fillText(`${currentSimilarity.toFixed(3)}`, plotX + 2, plotY + plotHeight - 2);\n\n    ctx.restore();\n  }\n\n  /**\n   * Draw similarity score text on a canvas\n   */\n  drawSimilarityText(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    similarity: number\n  ): void {\n    ctx.fillStyle = '#00aaff';\n    ctx.font = 'bold 14px Arial';\n    const text = `Similarity: ${similarity.toFixed(3)}`;\n    const textWidth = ctx.measureText(text).width;\n    const x = (width - textWidth) / 2;\n    ctx.fillText(text, x, 20);\n  }\n}\n","/**\n * PositionMarkerRenderer - Responsible for drawing position markers\n * Displays start and end positions on the buffer canvas\n */\nexport class PositionMarkerRenderer {\n  /**\n   * Draw vertical position markers\n   */\n  drawPositionMarkers(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    startIndex: number,\n    endIndex: number,\n    totalLength: number\n  ): void {\n    if (totalLength <= 0) return;\n\n    // Calculate x positions for start and end markers\n    const startX = (startIndex / totalLength) * width;\n    const endX = (endIndex / totalLength) * width;\n\n    // Draw start marker (red line)\n    ctx.strokeStyle = '#ff0000';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(startX, 0);\n    ctx.lineTo(startX, height);\n    ctx.stroke();\n\n    // Draw end marker (red line)\n    ctx.beginPath();\n    ctx.moveTo(endX, 0);\n    ctx.lineTo(endX, height);\n    ctx.stroke();\n\n    // Draw labels\n    ctx.fillStyle = '#ff0000';\n    ctx.font = '10px Arial';\n    ctx.fillText('S', startX + 2, 12);\n    ctx.fillText('E', endX + 2, 12);\n  }\n}\n","/**\n * OffsetOverlayRenderer - Responsible for drawing phase marker offset overlay graphs\n * Displays frame-to-frame delta of phase markers on current waveform canvas\n * Fixed for issue #254: Now shows deltas instead of absolute positions to avoid spikes\n */\nexport class OffsetOverlayRenderer {\n  /**\n   * Draw phase marker offset overlay graphs on current waveform canvas\n   * Displays two line graphs showing the frame-to-frame delta of phase markers\n   * @param ctx - Canvas 2D rendering context\n   * @param width - Canvas width\n   * @param height - Canvas height\n   * @param phaseZeroOffsetHistory - Array of frame-to-frame delta percentages for phase zero (start red line)\n   * @param phaseTwoPiOffsetHistory - Array of frame-to-frame delta percentages for phase 2π (end red line)\n   */\n  drawOffsetOverlayGraphs(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    phaseZeroOffsetHistory: number[] = [],\n    phaseTwoPiOffsetHistory: number[] = []\n  ): void {\n    if (phaseZeroOffsetHistory.length === 0 && phaseTwoPiOffsetHistory.length === 0) {\n      return;\n    }\n\n    ctx.save();\n\n    // Define plot area - position at top right corner\n    const plotWidth = Math.min(120, width * 0.4);\n    const plotHeight = Math.min(60, height * 0.4);\n    const plotX = width - plotWidth - 5;\n    const plotY = 5;\n\n    // Draw semi-transparent background\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    ctx.fillRect(plotX, plotY, plotWidth, plotHeight);\n\n    // Draw border\n    ctx.strokeStyle = '#00aaff';\n    ctx.lineWidth = 1;\n    ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);\n\n    // Title\n    ctx.fillStyle = '#00aaff';\n    ctx.font = '9px Arial';\n    ctx.fillText('Δ Offset %', plotX + 2, plotY + 9);\n\n    // Calculate plot area inside border\n    const innerPadding = 2;\n    const innerPlotX = plotX + innerPadding;\n    const innerPlotY = plotY + 12;\n    const innerPlotWidth = plotWidth - innerPadding * 2;\n    const innerPlotHeight = plotHeight - 12 - innerPadding;\n\n    // Determine Y-axis range: -5% to +5% (expecting ±1% per frame)\n    // Expanded range to accommodate occasional larger deltas during mode switches\n    const minPercent = -5;\n    const maxPercent = 5;\n    const zeroLine = innerPlotY + innerPlotHeight / 2; // Middle of plot\n\n    // Draw zero reference line\n    ctx.strokeStyle = '#444444';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(innerPlotX, zeroLine);\n    ctx.lineTo(innerPlotX + innerPlotWidth, zeroLine);\n    ctx.stroke();\n\n    // Helper function to draw offset line\n    const drawOffsetLine = (offsetHistory: number[], color: string) => {\n      if (offsetHistory.length < 2) return;\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 1.5;\n      ctx.beginPath();\n\n      const xStep = innerPlotWidth / Math.max(offsetHistory.length - 1, 1);\n\n      for (let i = 0; i < offsetHistory.length; i++) {\n        const percent = offsetHistory[i];\n        const x = innerPlotX + i * xStep;\n\n        // Clamp to display range\n        const clampedPercent = Math.max(minPercent, Math.min(maxPercent, percent));\n\n        // Map percentage to Y coordinate (inverted: positive = top, negative = bottom)\n        const normalizedPercent = (clampedPercent - minPercent) / (maxPercent - minPercent);\n        const y = innerPlotY + innerPlotHeight - (normalizedPercent * innerPlotHeight);\n\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n\n      ctx.stroke();\n    };\n\n    // Draw phase zero offset line (red)\n    drawOffsetLine(phaseZeroOffsetHistory, '#ff0000');\n\n    // Draw phase 2π offset line (orange)\n    drawOffsetLine(phaseTwoPiOffsetHistory, '#ff8800');\n\n    // Draw current values\n    ctx.font = '8px monospace';\n    ctx.textAlign = 'left';\n\n    if (phaseZeroOffsetHistory.length > 0) {\n      const currentZeroOffset = phaseZeroOffsetHistory[phaseZeroOffsetHistory.length - 1];\n      ctx.fillStyle = '#ff0000';\n      // Show + or - sign explicitly (but not for zero)\n      const sign = currentZeroOffset > 0 ? '+' : '';\n      ctx.fillText(`S:${sign}${currentZeroOffset.toFixed(1)}%`, plotX + 2, plotY + plotHeight - 11);\n    }\n\n    if (phaseTwoPiOffsetHistory.length > 0) {\n      const currentTwoPiOffset = phaseTwoPiOffsetHistory[phaseTwoPiOffsetHistory.length - 1];\n      ctx.fillStyle = '#ff8800';\n      const sign = currentTwoPiOffset > 0 ? '+' : '';\n      ctx.fillText(`E:${sign}${currentTwoPiOffset.toFixed(1)}%`, plotX + 2, plotY + plotHeight - 2);\n    }\n\n    ctx.restore();\n  }\n}\n","import {\n  WaveformPanelRenderer,\n  SimilarityPlotRenderer,\n  PositionMarkerRenderer,\n  OffsetOverlayRenderer,\n} from './comparison-renderers';\n\n/**\n * ComparisonPanelRenderer handles rendering of the comparison panels\n * Acts as a coordinator that delegates to specialized renderers:\n * - WaveformPanelRenderer: Drawing waveforms with auto-scaling\n * - SimilarityPlotRenderer: Drawing similarity history plots\n * - PositionMarkerRenderer: Drawing position markers on buffer canvas\n * - OffsetOverlayRenderer: Drawing phase marker offset overlay graphs\n */\nexport class ComparisonPanelRenderer {\n  private previousCanvas: HTMLCanvasElement;\n  private currentCanvas: HTMLCanvasElement;\n  private similarityCanvas: HTMLCanvasElement;\n  private bufferCanvas: HTMLCanvasElement;\n  private previousCtx: CanvasRenderingContext2D;\n  private currentCtx: CanvasRenderingContext2D;\n  private similarityCtx: CanvasRenderingContext2D;\n  private bufferCtx: CanvasRenderingContext2D;\n  \n  // Specialized renderers\n  private waveformRenderer: WaveformPanelRenderer;\n  private similarityPlotRenderer: SimilarityPlotRenderer;\n  private positionMarkerRenderer: PositionMarkerRenderer;\n  private offsetOverlayRenderer: OffsetOverlayRenderer;\n\n  constructor(\n    previousCanvas: HTMLCanvasElement,\n    currentCanvas: HTMLCanvasElement,\n    similarityCanvas: HTMLCanvasElement,\n    bufferCanvas: HTMLCanvasElement\n  ) {\n    this.previousCanvas = previousCanvas;\n    this.currentCanvas = currentCanvas;\n    this.similarityCanvas = similarityCanvas;\n    this.bufferCanvas = bufferCanvas;\n\n    const prevCtx = previousCanvas.getContext('2d');\n    const currCtx = currentCanvas.getContext('2d');\n    const simCtx = similarityCanvas.getContext('2d');\n    const buffCtx = bufferCanvas.getContext('2d');\n\n    if (!prevCtx || !currCtx || !simCtx || !buffCtx) {\n      throw new Error('Could not get 2D context for comparison canvases');\n    }\n\n    this.previousCtx = prevCtx;\n    this.currentCtx = currCtx;\n    this.similarityCtx = simCtx;\n    this.bufferCtx = buffCtx;\n\n    // Initialize specialized renderers\n    this.waveformRenderer = new WaveformPanelRenderer();\n    this.similarityPlotRenderer = new SimilarityPlotRenderer();\n    this.positionMarkerRenderer = new PositionMarkerRenderer();\n    this.offsetOverlayRenderer = new OffsetOverlayRenderer();\n\n    // Initialize all canvases\n    this.clearAllCanvases();\n  }\n\n  /**\n   * Clear all comparison canvases\n   */\n  private clearAllCanvases(): void {\n    this.waveformRenderer.clearCanvas(this.previousCtx, this.previousCanvas.width, this.previousCanvas.height);\n    this.waveformRenderer.clearCanvas(this.currentCtx, this.currentCanvas.width, this.currentCanvas.height);\n    this.waveformRenderer.clearCanvas(this.similarityCtx, this.similarityCanvas.width, this.similarityCanvas.height);\n    this.waveformRenderer.clearCanvas(this.bufferCtx, this.bufferCanvas.width, this.bufferCanvas.height);\n  }\n\n  /**\n   * Update all comparison panels\n   * @param previousWaveform - Previous frame's waveform data (null if no previous frame exists)\n   * @param currentWaveform - Full buffer containing current frame's audio data\n   * @param currentStart - Start index of the extracted waveform within currentWaveform\n   * @param currentEnd - End index of the extracted waveform within currentWaveform (exclusive)\n   * @param fullBuffer - Complete frame buffer to display (typically same as currentWaveform)\n   * @param similarity - Correlation coefficient between current and previous waveform (-1 to +1)\n   * @param similarityHistory - Array of similarity values over time for history plot\n   * @param phaseZeroOffsetHistory - Array of relative offset percentages for phase zero marker (issue #236)\n   * @param phaseTwoPiOffsetHistory - Array of relative offset percentages for phase 2π marker (issue #236)\n   */\n  updatePanels(\n    previousWaveform: Float32Array | null,\n    currentWaveform: Float32Array,\n    currentStart: number,\n    currentEnd: number,\n    fullBuffer: Float32Array,\n    similarity: number,\n    similarityHistory: number[] = [],\n    phaseZeroOffsetHistory: number[] = [],\n    phaseTwoPiOffsetHistory: number[] = []\n  ): void {\n    // Clear all canvases\n    this.clearAllCanvases();\n\n    // Draw previous waveform\n    if (previousWaveform) {\n      this.waveformRenderer.drawCenterLine(this.previousCtx, this.previousCanvas.width, this.previousCanvas.height);\n      this.waveformRenderer.drawWaveform(\n        this.previousCtx,\n        this.previousCanvas.width,\n        this.previousCanvas.height,\n        previousWaveform,\n        0,\n        previousWaveform.length,\n        '#ffaa00'\n      );\n    }\n\n    // Draw current waveform with similarity score\n    this.waveformRenderer.drawCenterLine(this.currentCtx, this.currentCanvas.width, this.currentCanvas.height);\n    const currentLength = currentEnd - currentStart;\n    if (currentLength > 0) {\n      this.waveformRenderer.drawWaveform(\n        this.currentCtx,\n        this.currentCanvas.width,\n        this.currentCanvas.height,\n        currentWaveform,\n        currentStart,\n        currentEnd,\n        '#00ff00'\n      );\n    }\n    if (previousWaveform) {\n      this.similarityPlotRenderer.drawSimilarityText(this.currentCtx, this.currentCanvas.width, similarity);\n    }\n    \n    // Draw offset overlay graphs on current waveform (issue #236)\n    this.offsetOverlayRenderer.drawOffsetOverlayGraphs(\n      this.currentCtx,\n      this.currentCanvas.width,\n      this.currentCanvas.height,\n      phaseZeroOffsetHistory,\n      phaseTwoPiOffsetHistory\n    );\n\n    // Draw similarity plot\n    if (similarityHistory.length > 0) {\n      this.similarityPlotRenderer.drawSimilarityPlot(\n        this.similarityCtx,\n        this.similarityCanvas.width,\n        this.similarityCanvas.height,\n        similarityHistory\n      );\n    }\n\n    // Draw full frame buffer with position markers\n    this.waveformRenderer.drawCenterLine(this.bufferCtx, this.bufferCanvas.width, this.bufferCanvas.height);\n    this.waveformRenderer.drawWaveform(\n      this.bufferCtx,\n      this.bufferCanvas.width,\n      this.bufferCanvas.height,\n      fullBuffer,\n      0,\n      fullBuffer.length,\n      '#888888'\n    );\n    this.positionMarkerRenderer.drawPositionMarkers(\n      this.bufferCtx,\n      this.bufferCanvas.width,\n      this.bufferCanvas.height,\n      currentStart,\n      currentEnd,\n      fullBuffer.length\n    );\n  }\n\n  /**\n   * Clear all panels (e.g., when stopped)\n   */\n  clear(): void {\n    this.clearAllCanvases();\n  }\n}\n","/**\n * CycleSimilarityRenderer handles rendering of cycle similarity graphs\n * Displays similarity between consecutive segments for:\n * - 8 divisions (1/2 cycle each)\n * - 4 divisions (1 cycle each)\n * - 2 divisions (2 cycles each)\n */\nexport class CycleSimilarityRenderer {\n  private static readonly HISTORY_SIZE = 100;\n  private static readonly SEGMENT_COLORS = ['#00ff00', '#88ff00', '#ffaa00', '#ff6600', '#ff0000', '#ff00ff', '#00ffff'];\n\n  private canvas8div: HTMLCanvasElement;\n  private canvas4div: HTMLCanvasElement;\n  private canvas2div: HTMLCanvasElement;\n  private ctx8div: CanvasRenderingContext2D;\n  private ctx4div: CanvasRenderingContext2D;\n  private ctx2div: CanvasRenderingContext2D;\n\n  // History buffers for 100 frames\n  private history8div: number[][] = [];\n  private history4div: number[][] = [];\n  private history2div: number[][] = [];\n\n  constructor(\n    canvas8div: HTMLCanvasElement,\n    canvas4div: HTMLCanvasElement,\n    canvas2div: HTMLCanvasElement\n  ) {\n    this.canvas8div = canvas8div;\n    this.canvas4div = canvas4div;\n    this.canvas2div = canvas2div;\n\n    const ctx8 = canvas8div.getContext('2d');\n    const ctx4 = canvas4div.getContext('2d');\n    const ctx2 = canvas2div.getContext('2d');\n\n    if (!ctx8 || !ctx4 || !ctx2) {\n      throw new Error('Could not get 2D context for cycle similarity canvases');\n    }\n\n    this.ctx8div = ctx8;\n    this.ctx4div = ctx4;\n    this.ctx2div = ctx2;\n\n    this.clearAllCanvases();\n  }\n\n  /**\n   * Clear all canvases\n   */\n  private clearAllCanvases(): void {\n    this.clearCanvas(this.ctx8div, this.canvas8div.width, this.canvas8div.height);\n    this.clearCanvas(this.ctx4div, this.canvas4div.width, this.canvas4div.height);\n    this.clearCanvas(this.ctx2div, this.canvas2div.width, this.canvas2div.height);\n  }\n\n  /**\n   * Clear a single canvas\n   */\n  private clearCanvas(ctx: CanvasRenderingContext2D, width: number, height: number): void {\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, width, height);\n  }\n\n  /**\n   * Draw a similarity line graph on a canvas showing history for each segment\n   * @param ctx Canvas context\n   * @param width Canvas width\n   * @param height Canvas height\n   * @param history History of similarity arrays (each array contains similarities for all segments)\n   * @param title Title text for the graph\n   * @param segmentLabel Label for what each segment represents (e.g., \"1/2 cycle\")\n   */\n  private drawSimilarityGraph(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    history: number[][],\n    title: string,\n    segmentLabel: string\n  ): void {\n    ctx.save();\n\n    // Clear and draw background\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw border\n    ctx.strokeStyle = '#ff8800';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, 0, width, height);\n\n    // Title\n    ctx.fillStyle = '#ff8800';\n    ctx.font = 'bold 12px Arial';\n    ctx.fillText(title, 5, 15);\n\n    // Check if we have data\n    if (!history || history.length === 0 || !history[0] || history[0].length === 0) {\n      ctx.fillStyle = '#666666';\n      ctx.font = '11px Arial';\n      ctx.fillText('データなし (No data)', width / 2 - 50, height / 2);\n      ctx.restore();\n      return;\n    }\n\n    // Calculate plot area\n    const plotX = 35;\n    const plotY = 25;\n    const plotWidth = width - 45;\n    const plotHeight = height - 35;\n\n    // Similarity range is -1.0 to 1.0\n    const displayMin = -1.0;\n    const displayMax = 1.0;\n\n    // Draw grid lines\n    ctx.strokeStyle = '#333333';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n\n    // Horizontal grid lines (similarity axis)\n    for (let i = 0; i <= 4; i++) {\n      const y = plotY + (plotHeight / 4) * i;\n      ctx.moveTo(plotX, y);\n      ctx.lineTo(plotX + plotWidth, y);\n    }\n\n    // Vertical grid lines (4 equal divisions, representing 25-frame intervals at full 100-frame history)\n    for (let i = 0; i <= 4; i++) {\n      const x = plotX + (plotWidth / 4) * i;\n      ctx.moveTo(x, plotY);\n      ctx.lineTo(x, plotY + plotHeight);\n    }\n\n    ctx.stroke();\n\n    // Draw Y-axis labels (similarity values)\n    ctx.fillStyle = '#aaaaaa';\n    ctx.font = '10px monospace';\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'middle';\n\n    for (let i = 0; i <= 4; i++) {\n      const similarity = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const label = similarity.toFixed(1);\n      ctx.fillText(label, plotX - 5, y);\n    }\n\n    // Draw zero line (at y = 0)\n    const zeroY = plotY + plotHeight - (0 - displayMin) / (displayMax - displayMin) * plotHeight;\n    ctx.strokeStyle = '#666666';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(plotX, zeroY);\n    ctx.lineTo(plotX + plotWidth, zeroY);\n    ctx.stroke();\n\n    // Number of segments (from first frame)\n    const numSegments = history[0].length;\n\n    // Draw line for each segment\n    for (let segIdx = 0; segIdx < numSegments; segIdx++) {\n      const color = CycleSimilarityRenderer.SEGMENT_COLORS[segIdx % CycleSimilarityRenderer.SEGMENT_COLORS.length];\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n\n      // Calculate X step: if only 1 frame, point is at plotX (left edge);\n      // if multiple frames, spread across width\n      const xStep = history.length > 1 ? plotWidth / (history.length - 1) : 0;\n\n      let hasValidPoint = false;\n      for (let frameIdx = 0; frameIdx < history.length; frameIdx++) {\n        const frame = history[frameIdx];\n        if (frame && frame.length > segIdx) {\n          const similarity = frame[segIdx];\n          const x = plotX + frameIdx * xStep;\n\n          // Clamp similarity to display range\n          const clampedSimilarity = Math.max(displayMin, Math.min(displayMax, similarity));\n\n          // Map similarity to Y coordinate (inverted: high similarity = top)\n          const normalizedSimilarity = (clampedSimilarity - displayMin) / (displayMax - displayMin);\n          const y = plotY + plotHeight - (normalizedSimilarity * plotHeight);\n\n          if (!hasValidPoint) {\n            ctx.moveTo(x, y);\n            hasValidPoint = true;\n          } else {\n            ctx.lineTo(x, y);\n          }\n        }\n      }\n\n      ctx.stroke();\n    }\n\n    // Draw current values for each segment (legend)\n    const lastFrame = history[history.length - 1];\n    if (lastFrame && lastFrame.length > 0) {\n      // Calculate legend dimensions\n      const legendItemHeight = 11; // Reduced from 12 for tighter spacing\n      const legendHeight = lastFrame.length * legendItemHeight + 4; // Add padding\n      const legendWidth = 65;\n      const legendX = plotX + plotWidth - legendWidth - 2;\n      const legendY = plotY + 2;\n      \n      // Draw semi-transparent background for legend to prevent overlap issues\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n      ctx.fillRect(legendX, legendY, legendWidth, legendHeight);\n      \n      // Draw border around legend\n      ctx.strokeStyle = '#555555';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);\n      \n      ctx.font = '9px Arial';\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'top';\n\n      for (let segIdx = 0; segIdx < lastFrame.length; segIdx++) {\n        const color = CycleSimilarityRenderer.SEGMENT_COLORS[segIdx % CycleSimilarityRenderer.SEGMENT_COLORS.length];\n        const similarity = lastFrame[segIdx];\n        \n        // Draw colored box for legend\n        const itemY = legendY + 2 + segIdx * legendItemHeight;\n        ctx.fillStyle = color;\n        ctx.fillRect(legendX + 2, itemY, 8, 8);\n        \n        // Draw segment label and value\n        ctx.fillStyle = '#ffffff';\n        ctx.fillText(`${segIdx + 1}-${segIdx + 2}: ${similarity.toFixed(2)}`, legendX + 12, itemY);\n      }\n    }\n\n    // Draw segment label\n    ctx.fillStyle = '#aaaaaa';\n    ctx.font = '10px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(segmentLabel, plotX + plotWidth / 2, height - 3);\n\n    ctx.restore();\n  }\n\n  /**\n   * Update all cycle similarity graphs\n   * @param similarities8div 8 divisions (1/2 cycle each): 7 similarity values\n   * @param similarities4div 4 divisions (1 cycle each): 3 similarity values\n   * @param similarities2div 2 divisions (2 cycles each): 1 similarity value\n   */\n  updateGraphs(\n    similarities8div?: number[],\n    similarities4div?: number[],\n    similarities2div?: number[]\n  ): void {\n    // Update history buffers\n    if (similarities8div && similarities8div.length > 0) {\n      this.history8div.push(similarities8div);\n      if (this.history8div.length > CycleSimilarityRenderer.HISTORY_SIZE) {\n        this.history8div.shift(); // Remove oldest frame\n      }\n    }\n\n    if (similarities4div && similarities4div.length > 0) {\n      this.history4div.push(similarities4div);\n      if (this.history4div.length > CycleSimilarityRenderer.HISTORY_SIZE) {\n        this.history4div.shift();\n      }\n    }\n\n    if (similarities2div && similarities2div.length > 0) {\n      this.history2div.push(similarities2div);\n      if (this.history2div.length > CycleSimilarityRenderer.HISTORY_SIZE) {\n        this.history2div.shift();\n      }\n    }\n\n    // 8 divisions graph\n    this.drawSimilarityGraph(\n      this.ctx8div,\n      this.canvas8div.width,\n      this.canvas8div.height,\n      this.history8div,\n      '8分割 (1/2周期)',\n      '連続する1/2周期間の類似度'\n    );\n\n    // 4 divisions graph\n    this.drawSimilarityGraph(\n      this.ctx4div,\n      this.canvas4div.width,\n      this.canvas4div.height,\n      this.history4div,\n      '4分割 (1周期)',\n      '連続する1周期間の類似度'\n    );\n\n    // 2 divisions graph\n    this.drawSimilarityGraph(\n      this.ctx2div,\n      this.canvas2div.width,\n      this.canvas2div.height,\n      this.history2div,\n      '2分割 (2周期)',\n      '連続する2周期間の類似度'\n    );\n  }\n\n  /**\n   * Clear all graphs\n   */\n  clear(): void {\n    this.history8div = [];\n    this.history4div = [];\n    this.history2div = [];\n    this.clearAllCanvases();\n  }\n}\n","/**\n * BasePathResolver - Responsible for determining the application's base path\n * \n * This class follows the Single Responsibility Principle by having one clear purpose:\n * resolving the base path for loading assets (like WASM files) in various deployment scenarios.\n */\nexport class BasePathResolver {\n  // Asset directory patterns used for base path detection\n  private static readonly ASSET_PATTERNS = ['/assets/', '/js/', '/dist/'] as const;\n  \n  private cachedBasePath: string | null = null;\n\n  /**\n   * Determine the base path for the application\n   * This method implements a fallback hierarchy:\n   * 1. Check for <base> tag href attribute\n   * 2. Extract from existing script tags\n   * 3. Check if running in Vite dev mode (import.meta.env.DEV)\n   * 4. Default to '/'\n   * The path is normalized to always end with '/'\n   */\n  getBasePath(): string {\n    // Return cached value if available\n    if (this.cachedBasePath !== null) {\n      return this.cachedBasePath;\n    }\n    \n    // Try <base> tag first\n    let basePath = document.querySelector('base')?.getAttribute('href');\n\n    // If we got a value from <base>, normalize absolute URLs to pathname only\n    if (basePath) {\n      try {\n        const url = new URL(basePath, window.location.href);\n        basePath = url.pathname;\n      } catch {\n        // If parsing fails, keep the original value (likely already a relative path)\n      }\n    }\n    \n    // Fall back to script tag analysis\n    if (!basePath) {\n      basePath = this.getBasePathFromScripts();\n    }\n    \n    // Check if running in Vite dev mode (window.location.pathname contains the base)\n    if (!basePath && window.location.pathname && window.location.pathname !== '/') {\n      // In dev mode, Vite may serve from a base path like /cat-oscilloscope or /cat-oscilloscope/\n      // Extract the first path segment robustly (handles /cat-oscilloscope, /cat-oscilloscope/, /cat-oscilloscope/page, etc.)\n      const pathname = window.location.pathname;\n      const segments = pathname.split('/').filter((segment) => segment.length > 0);\n      if (segments.length > 0) {\n        basePath = `/${segments[0]}/`;\n      }\n    }\n    \n    // Default to root\n    if (!basePath) {\n      basePath = '/';\n    }\n    \n    // Normalize: ensure trailing slash\n    if (!basePath.endsWith('/')) {\n      basePath += '/';\n    }\n    \n    // Cache the result\n    this.cachedBasePath = basePath;\n    return basePath;\n  }\n  \n  /**\n   * Extract base path from existing script tags\n   * This method attempts to infer the base path by looking for script tags with src attributes\n   * that might indicate the deployment path. Falls back to empty string if no clear pattern is found.\n   */\n  private getBasePathFromScripts(): string {\n    const scripts = document.querySelectorAll('script[src]');\n    for (const script of scripts) {\n      const src = script.getAttribute('src');\n      if (src) {\n        try {\n          // Try to parse as URL to handle both absolute and relative paths\n          const url = new URL(src, window.location.href);\n          const pathname = url.pathname;\n          \n          // Look for common asset directory patterns\n          for (const pattern of BasePathResolver.ASSET_PATTERNS) {\n            const index = pathname.indexOf(pattern);\n            if (index >= 0) {\n              // Extract everything before the asset directory\n              // For '/assets/file.js', index=0, return '/' (root directory)\n              // For '/cat-oscilloscope/assets/file.js', index=17, return '/cat-oscilloscope/'\n              return index === 0 ? '/' : pathname.substring(0, index) + '/';\n            }\n          }\n        } catch (error: unknown) {\n          // URL parsing failed - skip this script and try next one\n          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {\n            console.debug('Failed to parse script URL:', src, error);\n          }\n          continue;\n        }\n      }\n    }\n    return '';\n  }\n}\n","// Type definition for WASM processor instance\nexport interface WasmProcessorInstance {\n  setAutoGain(enabled: boolean): void;\n  setNoiseGate(enabled: boolean): void;\n  setNoiseGateThreshold(threshold: number): void;\n  setFrequencyEstimationMethod(method: string): void;\n  setBufferSizeMultiplier(multiplier: number): void;\n  setUsePeakMode(enabled: boolean): void;\n  setZeroCrossMode(mode: string): void;\n  reset(): void;\n  computeFrequencyData(\n    timeDomainData: Float32Array,\n    fftSize: number\n  ): Uint8Array | undefined;\n  processFrame(\n    waveformData: Float32Array,\n    frequencyData: Uint8Array | null,\n    sampleRate: number,\n    fftSize: number,\n    fftDisplayEnabled: boolean\n  ): any;\n}\n\n/**\n * WasmModuleLoader - Responsible for loading and initializing WASM modules\n * \n * This class follows the Single Responsibility Principle by having one clear purpose:\n * dynamically loading the WASM processor module and managing its lifecycle.\n */\nexport class WasmModuleLoader {\n  private wasmProcessor: WasmProcessorInstance | null = null;\n  private isInitialized = false;\n  private readonly LOAD_TIMEOUT_MS = 10000;\n\n  /**\n   * Load WASM module dynamically\n   * @param basePath - Base path for loading WASM files\n   * @returns Promise that resolves when WASM is loaded and initialized\n   */\n  async loadWasmModule(basePath: string): Promise<void> {\n    if (this.isInitialized && this.wasmProcessor) {\n      return; // Already loaded\n    }\n\n    // Check if we're in a test or non-browser-like environment\n    if (typeof window === 'undefined' || window.location.protocol === 'file:') {\n      throw new Error('WASM module not available in test/non-browser environment');\n    }\n\n    return new Promise((resolve, reject) => {\n      // Check if already loaded\n      // @ts-ignore\n      if (window.wasmProcessor && window.wasmProcessor.WasmDataProcessor) {\n        // @ts-ignore\n        this.wasmProcessor = new window.wasmProcessor.WasmDataProcessor();\n        this.isInitialized = true;\n        resolve();\n        return;\n      }\n      \n      // Set up timeout to prevent hanging\n      const timeout = setTimeout(() => {\n        cleanup();\n        reject(new Error(`WASM module loading timed out after ${this.LOAD_TIMEOUT_MS / 1000} seconds`));\n      }, this.LOAD_TIMEOUT_MS);\n      \n      const wasmPath = `${basePath}wasm/signal_processor_wasm.js`;\n      \n      const script = document.createElement('script');\n      script.type = 'module';\n      script.textContent = `\n        import init, { WasmDataProcessor } from '${wasmPath}';\n        await init();\n        window.wasmProcessor = { WasmDataProcessor };\n        window.dispatchEvent(new Event('wasmLoaded'));\n      `;\n      \n      const cleanup = () => {\n        clearTimeout(timeout);\n        window.removeEventListener('wasmLoaded', handleLoad);\n      };\n      \n      const handleLoad = () => {\n        cleanup();\n        // @ts-ignore\n        if (window.wasmProcessor && window.wasmProcessor.WasmDataProcessor) {\n          // @ts-ignore\n          this.wasmProcessor = new window.wasmProcessor.WasmDataProcessor();\n          this.isInitialized = true;\n          resolve();\n        } else {\n          reject(new Error('WASM module loaded but WasmDataProcessor not found'));\n        }\n      };\n      \n      window.addEventListener('wasmLoaded', handleLoad);\n      \n      script.onerror = () => {\n        cleanup();\n        reject(new Error('Failed to load WASM module script'));\n      };\n      \n      document.head.appendChild(script);\n    });\n  }\n\n  /**\n   * Get the loaded WASM processor instance\n   */\n  getProcessor(): WasmProcessorInstance | null {\n    return this.wasmProcessor;\n  }\n\n  /**\n   * Check if WASM module is initialized\n   */\n  isReady(): boolean {\n    return this.isInitialized && this.wasmProcessor !== null;\n  }\n}\n","import { WaveformRenderData } from './WaveformRenderData';\nimport { AudioManager } from './AudioManager';\nimport { GainController } from './GainController';\nimport { FrequencyEstimator } from './FrequencyEstimator';\nimport { WaveformSearcher } from './WaveformSearcher';\nimport { ZeroCrossDetector } from './ZeroCrossDetector';\nimport { BasePathResolver } from './BasePathResolver';\nimport { WasmModuleLoader } from './WasmModuleLoader';\n\n/**\n * WaveformDataProcessor - Coordinates waveform data processing using Rust WASM implementation\n * \n * This class has been refactored to follow the Single Responsibility Principle.\n * Its sole responsibility is now coordinating between JavaScript configuration\n * and the Rust/WASM processor for data processing.\n * \n * Responsibilities delegated to specialized classes:\n * - BasePathResolver: Determines the base path for loading WASM files\n * - WasmModuleLoader: Handles WASM module loading and initialization\n * \n * All actual data processing algorithms (frequency estimation, gain control,\n * zero-cross detection, waveform search) are implemented in Rust WASM.\n */\nexport class WaveformDataProcessor {\n  private audioManager: AudioManager;\n  private gainController: GainController;\n  private frequencyEstimator: FrequencyEstimator;\n  private waveformSearcher: WaveformSearcher;\n  private zeroCrossDetector: ZeroCrossDetector;\n  private basePathResolver: BasePathResolver;\n  private wasmLoader: WasmModuleLoader;\n  \n  // Phase marker offset history for overlay graphs (issue #236, #254)\n  private phaseZeroOffsetHistory: number[] = [];\n  private phaseTwoPiOffsetHistory: number[] = [];\n  private readonly MAX_OFFSET_HISTORY = 100; // Keep last 100 frames of offset data\n  \n  // Previous frame's phase marker positions for delta calculation (issue #254)\n  private previousPhaseZeroIndex: number | undefined = undefined;\n  private previousPhaseTwoPiIndex: number | undefined = undefined;\n\n  constructor(\n    audioManager: AudioManager,\n    gainController: GainController,\n    frequencyEstimator: FrequencyEstimator,\n    waveformSearcher: WaveformSearcher,\n    zeroCrossDetector: ZeroCrossDetector\n  ) {\n    this.audioManager = audioManager;\n    this.gainController = gainController;\n    this.frequencyEstimator = frequencyEstimator;\n    this.waveformSearcher = waveformSearcher;\n    this.zeroCrossDetector = zeroCrossDetector;\n    this.basePathResolver = new BasePathResolver();\n    this.wasmLoader = new WasmModuleLoader();\n  }\n  \n  /**\n   * Initialize the WASM module\n   * Must be called before processFrame\n   */\n  async initialize(): Promise<void> {\n    if (this.wasmLoader.isReady()) {\n      return;\n    }\n    \n    try {\n      // Determine base path and load WASM module\n      const basePath = this.basePathResolver.getBasePath();\n      await this.wasmLoader.loadWasmModule(basePath);\n      \n      // Sync initial configuration to WASM\n      this.syncConfigToWasm();\n    } catch (error) {\n      console.error('Failed to initialize WASM module:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Sync TypeScript configuration to WASM processor\n   */\n  private syncConfigToWasm(): void {\n    const wasmProcessor = this.wasmLoader.getProcessor();\n    if (!wasmProcessor) return;\n    \n    wasmProcessor.setAutoGain(this.gainController.getAutoGainEnabled());\n    wasmProcessor.setNoiseGate(this.gainController.getNoiseGateEnabled());\n    wasmProcessor.setNoiseGateThreshold(this.gainController.getNoiseGateThreshold());\n    wasmProcessor.setFrequencyEstimationMethod(this.frequencyEstimator.getFrequencyEstimationMethod());\n    wasmProcessor.setBufferSizeMultiplier(this.frequencyEstimator.getBufferSizeMultiplier());\n    wasmProcessor.setZeroCrossMode(this.zeroCrossDetector.getZeroCrossMode());\n  }\n  \n  /**\n   * Sync WASM results back to TypeScript objects\n   * \n   * Note: This method accesses private members using type assertions.\n   * This is a temporary solution to maintain compatibility with existing code\n   * that uses getters like getEstimatedFrequency(), getCurrentGain(), etc.\n   * \n   * TODO: Consider adding public setter methods to these classes or\n   * redesigning the synchronization interface for better type safety.\n   */\n  private syncResultsFromWasm(renderData: WaveformRenderData): void {\n    // Update frequency estimator's estimated frequency\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.frequencyEstimator as any).estimatedFrequency = renderData.estimatedFrequency;\n    \n    // Update gain controller's current gain\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.gainController as any).currentGain = renderData.gain;\n    \n    // Update waveform searcher's state\n    if (renderData.previousWaveform) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.waveformSearcher as any).previousWaveform = renderData.previousWaveform;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.waveformSearcher as any).lastSimilarity = renderData.similarity;\n  }\n\n  /**\n   * Process current frame and generate complete render data using WASM\n   */\n  processFrame(fftDisplayEnabled: boolean): WaveformRenderData | null {\n    const wasmProcessor = this.wasmLoader.getProcessor();\n    if (!this.wasmLoader.isReady() || !wasmProcessor) {\n      console.warn('WASM processor not initialized');\n      return null;\n    }\n    \n    // Check if audio is ready\n    if (!this.audioManager.isReady()) {\n      return null;\n    }\n\n    // Get waveform data\n    const dataArray = this.audioManager.getTimeDomainData();\n    if (!dataArray) {\n      return null;\n    }\n    \n    const sampleRate = this.audioManager.getSampleRate();\n    const fftSize = this.audioManager.getFFTSize();\n    \n    // Get frequency data if needed\n    const needsFrequencyData = this.frequencyEstimator.getFrequencyEstimationMethod() === 'fft' || fftDisplayEnabled;\n    let frequencyData = needsFrequencyData ? this.audioManager.getFrequencyData() : null;\n    \n    // If frequency data is needed but not available (e.g., BufferSource mode),\n    // compute it from time-domain data using WASM\n    if (needsFrequencyData && !frequencyData && dataArray) {\n      const computedFreqData = wasmProcessor.computeFrequencyData(dataArray, fftSize);\n      if (computedFreqData) {\n        frequencyData = new Uint8Array(computedFreqData);\n      }\n    }\n    \n    // Sync configuration before processing\n    this.syncConfigToWasm();\n    \n    // Call WASM processor\n    const wasmResult = wasmProcessor.processFrame(\n      dataArray,\n      frequencyData,\n      sampleRate,\n      fftSize,\n      fftDisplayEnabled\n    );\n    \n    if (!wasmResult) {\n      return null;\n    }\n    \n    // Convert WASM result to TypeScript WaveformRenderData\n    const renderData: WaveformRenderData = {\n      waveformData: new Float32Array(wasmResult.waveform_data),\n      displayStartIndex: wasmResult.displayStartIndex,\n      displayEndIndex: wasmResult.displayEndIndex,\n      gain: wasmResult.gain,\n      estimatedFrequency: wasmResult.estimatedFrequency,\n      frequencyPlotHistory: wasmResult.frequencyPlotHistory ? Array.from(wasmResult.frequencyPlotHistory) : [],\n      sampleRate: wasmResult.sampleRate,\n      fftSize: wasmResult.fftSize,\n      frequencyData: wasmResult.frequencyData ? new Uint8Array(wasmResult.frequencyData) : undefined,\n      isSignalAboveNoiseGate: wasmResult.isSignalAboveNoiseGate,\n      maxFrequency: wasmResult.maxFrequency,\n      previousWaveform: wasmResult.previousWaveform ? new Float32Array(wasmResult.previousWaveform) : null,\n      similarity: wasmResult.similarity,\n      similarityPlotHistory: wasmResult.similarityPlotHistory ? Array.from(wasmResult.similarityPlotHistory) : [],\n      usedSimilaritySearch: wasmResult.usedSimilaritySearch,\n      phaseZeroIndex: wasmResult.phaseZeroIndex,\n      phaseTwoPiIndex: wasmResult.phaseTwoPiIndex,\n      phaseMinusQuarterPiIndex: wasmResult.phaseMinusQuarterPiIndex,\n      phaseTwoPiPlusQuarterPiIndex: wasmResult.phaseTwoPiPlusQuarterPiIndex,\n      halfFreqPeakStrengthPercent: wasmResult.halfFreqPeakStrengthPercent,\n      candidate1Harmonics: wasmResult.candidate1Harmonics ? Array.from(wasmResult.candidate1Harmonics) : undefined,\n      candidate2Harmonics: wasmResult.candidate2Harmonics ? Array.from(wasmResult.candidate2Harmonics) : undefined,\n      selectionReason: wasmResult.selectionReason,\n      cycleSimilarities8div: wasmResult.cycleSimilarities8div ? Array.from(wasmResult.cycleSimilarities8div) : undefined,\n      cycleSimilarities4div: wasmResult.cycleSimilarities4div ? Array.from(wasmResult.cycleSimilarities4div) : undefined,\n      cycleSimilarities2div: wasmResult.cycleSimilarities2div ? Array.from(wasmResult.cycleSimilarities2div) : undefined,\n    };\n    \n    // Calculate and update phase marker offset history (issue #236)\n    this.updatePhaseOffsetHistory(renderData);\n    \n    // Add offset history to render data\n    renderData.phaseZeroOffsetHistory = [...this.phaseZeroOffsetHistory];\n    renderData.phaseTwoPiOffsetHistory = [...this.phaseTwoPiOffsetHistory];\n    \n    // Sync results back to TypeScript objects so getters work correctly\n    this.syncResultsFromWasm(renderData);\n    \n    return renderData;\n  }\n  \n  /**\n   * Calculate relative offset percentages for phase markers and update history\n   * Fixed for issue #254: Now tracks frame-to-frame delta instead of absolute position\n   * to avoid spikes when display window shifts/resizes\n   * @param renderData - Render data containing phase indices\n   */\n  private updatePhaseOffsetHistory(renderData: WaveformRenderData): void {\n    // Check if we have valid display indices\n    if (renderData.displayStartIndex === undefined || \n        renderData.displayEndIndex === undefined) {\n      return;\n    }\n    \n    const displayLength = renderData.displayEndIndex - renderData.displayStartIndex;\n    if (displayLength <= 0) {\n      return;\n    }\n    \n    // Update phase zero offset history if available\n    if (renderData.phaseZeroIndex !== undefined) {\n      let phaseZeroPercent: number;\n      \n      if (this.previousPhaseZeroIndex !== undefined) {\n        // Calculate frame-to-frame delta as percentage of display length\n        // This tracks actual marker movement, not position within shifting window\n        const delta = renderData.phaseZeroIndex - this.previousPhaseZeroIndex;\n        phaseZeroPercent = (delta / displayLength) * 100;\n      } else {\n        // First frame: start at 0% (no previous reference)\n        phaseZeroPercent = 0;\n      }\n      \n      this.phaseZeroOffsetHistory.push(phaseZeroPercent);\n      if (this.phaseZeroOffsetHistory.length > this.MAX_OFFSET_HISTORY) {\n        this.phaseZeroOffsetHistory.shift();\n      }\n      \n      // Store current position for next frame's delta calculation\n      this.previousPhaseZeroIndex = renderData.phaseZeroIndex;\n    }\n    \n    // Update phase 2π offset history if available\n    if (renderData.phaseTwoPiIndex !== undefined) {\n      let phaseTwoPiPercent: number;\n      \n      if (this.previousPhaseTwoPiIndex !== undefined) {\n        // Calculate frame-to-frame delta as percentage of display length\n        const delta = renderData.phaseTwoPiIndex - this.previousPhaseTwoPiIndex;\n        phaseTwoPiPercent = (delta / displayLength) * 100;\n      } else {\n        // First frame: start at 0%\n        phaseTwoPiPercent = 0;\n      }\n      \n      this.phaseTwoPiOffsetHistory.push(phaseTwoPiPercent);\n      if (this.phaseTwoPiOffsetHistory.length > this.MAX_OFFSET_HISTORY) {\n        this.phaseTwoPiOffsetHistory.shift();\n      }\n      \n      // Store current position for next frame's delta calculation\n      this.previousPhaseTwoPiIndex = renderData.phaseTwoPiIndex;\n    }\n  }\n  \n  /**\n   * Reset the WASM processor state\n   */\n  reset(): void {\n    const wasmProcessor = this.wasmLoader.getProcessor();\n    if (wasmProcessor) {\n      wasmProcessor.reset();\n    }\n    // Clear phase offset history (issue #236, #254)\n    this.phaseZeroOffsetHistory = [];\n    this.phaseTwoPiOffsetHistory = [];\n    this.previousPhaseZeroIndex = undefined;\n    this.previousPhaseTwoPiIndex = undefined;\n  }\n}\n","import { AudioManager } from './AudioManager';\nimport { GainController } from './GainController';\nimport { FrequencyEstimator } from './FrequencyEstimator';\nimport { WaveformRenderer } from './WaveformRenderer';\nimport { ZeroCrossDetector } from './ZeroCrossDetector';\nimport { WaveformSearcher } from './WaveformSearcher';\nimport { ComparisonPanelRenderer } from './ComparisonPanelRenderer';\nimport { CycleSimilarityRenderer } from './CycleSimilarityRenderer';\nimport { WaveformDataProcessor } from './WaveformDataProcessor';\nimport { WaveformRenderData } from './WaveformRenderData';\nimport { BufferSource } from './BufferSource';\nimport { OverlaysLayoutConfig } from './OverlayLayout';\n\n/**\n * Oscilloscope class - Main coordinator for the oscilloscope functionality\n * Delegates responsibilities to specialized modules:\n * - AudioManager: Web Audio API integration\n * - GainController: Auto-gain and noise gate configuration\n * - FrequencyEstimator: Frequency detection configuration\n * - WaveformRenderer: Canvas rendering\n * - ZeroCrossDetector: Zero-crossing detection configuration\n * - WaveformSearcher: Waveform similarity search state\n * - ComparisonPanelRenderer: Comparison panel rendering\n * - CycleSimilarityRenderer: Cycle similarity graph rendering\n * - WaveformDataProcessor: Data generation and processing (Rust WASM implementation)\n */\nexport class Oscilloscope {\n  private audioManager: AudioManager;\n  private gainController: GainController;\n  private frequencyEstimator: FrequencyEstimator;\n  private renderer: WaveformRenderer;\n  private zeroCrossDetector: ZeroCrossDetector;\n  private waveformSearcher: WaveformSearcher;\n  private comparisonRenderer: ComparisonPanelRenderer;\n  private cycleSimilarityRenderer: CycleSimilarityRenderer | null = null;\n  private dataProcessor: WaveformDataProcessor;\n  private animationId: number | null = null;\n  private isRunning = false;\n  private isPaused = false;\n  private phaseMarkerRangeEnabled = true; // Default: on\n\n  // Frame processing diagnostics\n  private lastFrameTime = 0;\n  private frameProcessingTimes: number[] = [];\n  private readonly MAX_FRAME_TIMES = 100;\n  private readonly TARGET_FRAME_TIME = 16.67; // 60fps target\n  private readonly FPS_LOG_INTERVAL_FRAMES = 60; // Log FPS every 60 frames (approx. 1 second at 60fps)\n\n  /**\n   * Create a new Oscilloscope instance\n   * @param canvas - Main oscilloscope display canvas (recommended: 800x350px)\n   * @param previousWaveformCanvas - Canvas for displaying previous frame's waveform (recommended: 250x120px)\n   * @param currentWaveformCanvas - Canvas for displaying current frame's waveform (recommended: 250x120px)\n   * @param similarityPlotCanvas - Canvas for displaying similarity history plot (recommended: 250x120px)\n   * @param frameBufferCanvas - Canvas for displaying full frame buffer with position markers (recommended: 800x120px)\n   * @param cycleSimilarity8divCanvas - Optional canvas for 8-division cycle similarity graph (recommended: 250x150px)\n   * @param cycleSimilarity4divCanvas - Optional canvas for 4-division cycle similarity graph (recommended: 250x150px)\n   * @param cycleSimilarity2divCanvas - Optional canvas for 2-division cycle similarity graph (recommended: 250x150px)\n   * @param overlaysLayout - Optional layout configuration for debug overlays (FFT, harmonic analysis, frequency plot)\n   */\n  constructor(\n    canvas: HTMLCanvasElement,\n    previousWaveformCanvas: HTMLCanvasElement,\n    currentWaveformCanvas: HTMLCanvasElement,\n    similarityPlotCanvas: HTMLCanvasElement,\n    frameBufferCanvas: HTMLCanvasElement,\n    cycleSimilarity8divCanvas?: HTMLCanvasElement,\n    cycleSimilarity4divCanvas?: HTMLCanvasElement,\n    cycleSimilarity2divCanvas?: HTMLCanvasElement,\n    overlaysLayout?: OverlaysLayoutConfig\n  ) {\n    this.audioManager = new AudioManager();\n    this.gainController = new GainController();\n    this.frequencyEstimator = new FrequencyEstimator();\n    this.renderer = new WaveformRenderer(canvas, overlaysLayout);\n    this.zeroCrossDetector = new ZeroCrossDetector();\n    this.waveformSearcher = new WaveformSearcher();\n    this.comparisonRenderer = new ComparisonPanelRenderer(\n      previousWaveformCanvas,\n      currentWaveformCanvas,\n      similarityPlotCanvas,\n      frameBufferCanvas\n    );\n    \n    // Initialize cycle similarity renderer if canvases are provided\n    if (cycleSimilarity8divCanvas && cycleSimilarity4divCanvas && cycleSimilarity2divCanvas) {\n      this.cycleSimilarityRenderer = new CycleSimilarityRenderer(\n        cycleSimilarity8divCanvas,\n        cycleSimilarity4divCanvas,\n        cycleSimilarity2divCanvas\n      );\n    }\n    \n    this.dataProcessor = new WaveformDataProcessor(\n      this.audioManager,\n      this.gainController,\n      this.frequencyEstimator,\n      this.waveformSearcher,\n      this.zeroCrossDetector\n    );\n  }\n\n  async start(): Promise<void> {\n    try {\n      // Initialize WASM processor if not already initialized\n      await this.dataProcessor.initialize();\n      \n      await this.audioManager.start();\n      this.isRunning = true;\n      this.render();\n    } catch (error) {\n      console.error('Error starting oscilloscope:', error);\n      throw error;\n    }\n  }\n\n  async startFromFile(file: File): Promise<void> {\n    try {\n      // Initialize WASM processor if not already initialized\n      await this.dataProcessor.initialize();\n      \n      await this.audioManager.startFromFile(file);\n      this.isRunning = true;\n      this.render();\n    } catch (error) {\n      console.error('Error loading audio file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start visualization from a static buffer without audio playback\n   * Useful for visualizing pre-recorded audio data or processing results\n   * @param bufferSource - BufferSource instance containing audio data\n   */\n  async startFromBuffer(bufferSource: BufferSource): Promise<void> {\n    try {\n      // Initialize WASM processor if not already initialized\n      await this.dataProcessor.initialize();\n      \n      await this.audioManager.startFromBuffer(bufferSource);\n      this.isRunning = true;\n      this.render();\n    } catch (error) {\n      console.error('Error starting from buffer:', error);\n      throw error;\n    }\n  }\n\n  async stop(): Promise<void> {\n    this.isRunning = false;\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n    await this.audioManager.stop();\n    this.frequencyEstimator.clearHistory();\n    this.zeroCrossDetector.reset();\n    this.waveformSearcher.reset();\n    this.comparisonRenderer.clear();\n    if (this.cycleSimilarityRenderer) {\n      this.cycleSimilarityRenderer.clear();\n    }\n    this.dataProcessor.reset();\n  }\n\n  private render(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    const startTime = performance.now();\n\n    // If paused, skip processing and drawing but continue the animation loop\n    if (!this.isPaused) {\n      // === DATA GENERATION PHASE ===\n      // Process frame and generate all data needed for rendering using WASM processor\n      const renderData = this.dataProcessor.processFrame(this.renderer.getFFTDisplayEnabled());\n      \n      if (renderData) {\n        // === RENDERING PHASE ===\n        // All rendering logic uses only the generated data\n        this.renderFrame(renderData);\n      }\n    }\n\n    // Measure frame processing time\n    const endTime = performance.now();\n    const processingTime = endTime - startTime;\n    this.frameProcessingTimes.push(processingTime);\n    if (this.frameProcessingTimes.length > this.MAX_FRAME_TIMES) {\n      this.frameProcessingTimes.shift();\n    }\n\n    // Warn if frame processing exceeds target (60fps)\n    if (processingTime > this.TARGET_FRAME_TIME) {\n      console.warn(`Frame processing time: ${processingTime.toFixed(2)}ms (target: <${this.TARGET_FRAME_TIME}ms)`);\n    }\n\n    // Calculate and log FPS periodically (every FPS_LOG_INTERVAL_FRAMES frames)\n    if (this.lastFrameTime > 0) {\n      const frameInterval = startTime - this.lastFrameTime;\n      const currentFps = 1000 / frameInterval;\n      \n      if (this.frameProcessingTimes.length === this.FPS_LOG_INTERVAL_FRAMES) {\n        const avgProcessingTime = this.frameProcessingTimes.reduce((a, b) => a + b, 0) / this.frameProcessingTimes.length;\n        console.log(`FPS: ${currentFps.toFixed(1)}, Avg frame time: ${avgProcessingTime.toFixed(2)}ms`);\n      }\n    }\n    this.lastFrameTime = startTime;\n\n    // Continue rendering\n    this.animationId = requestAnimationFrame(() => this.render());\n  }\n\n  /**\n   * Render a single frame using pre-processed data\n   * This method contains only rendering logic - no data processing\n   */\n  private renderFrame(renderData: WaveformRenderData): void {\n    // Determine display range based on phase marker range mode\n    let displayStartIndex = renderData.displayStartIndex;\n    let displayEndIndex = renderData.displayEndIndex;\n    \n    if (this.phaseMarkerRangeEnabled && \n        renderData.phaseMinusQuarterPiIndex !== undefined && \n        renderData.phaseTwoPiPlusQuarterPiIndex !== undefined &&\n        renderData.phaseMinusQuarterPiIndex <= renderData.phaseTwoPiPlusQuarterPiIndex) {\n      // Use phase marker range (orange to orange)\n      displayStartIndex = renderData.phaseMinusQuarterPiIndex;\n      displayEndIndex = renderData.phaseTwoPiPlusQuarterPiIndex;\n    }\n    \n    // Clear canvas and draw grid with measurement labels\n    const displaySamples = displayEndIndex - displayStartIndex;\n    this.renderer.clearAndDrawGrid(\n      renderData.sampleRate,\n      displaySamples,\n      renderData.gain\n    );\n\n    // Draw waveform with calculated gain\n    this.renderer.drawWaveform(\n      renderData.waveformData,\n      displayStartIndex,\n      displayEndIndex,\n      renderData.gain\n    );\n\n    // Draw phase markers\n    this.renderer.drawPhaseMarkers(\n      renderData.phaseZeroIndex,\n      renderData.phaseTwoPiIndex,\n      renderData.phaseMinusQuarterPiIndex,\n      renderData.phaseTwoPiPlusQuarterPiIndex,\n      displayStartIndex,\n      displayEndIndex,\n      {\n        phaseZeroSegmentRelative: renderData.phaseZeroSegmentRelative,\n        phaseZeroHistory: renderData.phaseZeroHistory,\n        phaseZeroTolerance: renderData.phaseZeroTolerance,\n        zeroCrossModeName: renderData.zeroCrossModeName,\n      }\n    );\n\n    // Draw FFT spectrum overlay if enabled and signal is above noise gate\n    if (renderData.frequencyData && this.renderer.getFFTDisplayEnabled() && renderData.isSignalAboveNoiseGate) {\n      this.renderer.drawFFTOverlay(\n        renderData.frequencyData,\n        renderData.estimatedFrequency,\n        renderData.sampleRate,\n        renderData.fftSize,\n        renderData.maxFrequency\n      );\n      \n      // Draw harmonic analysis overlay (only when FFT method is used and data is available)\n      this.renderer.drawHarmonicAnalysis(\n        renderData.halfFreqPeakStrengthPercent,\n        renderData.candidate1Harmonics,\n        renderData.candidate2Harmonics,\n        renderData.candidate1WeightedScore,\n        renderData.candidate2WeightedScore,\n        renderData.selectionReason,\n        renderData.estimatedFrequency\n      );\n    }\n\n    // 右上に周波数プロットを描画\n    this.renderer.drawFrequencyPlot(\n      renderData.frequencyPlotHistory,\n      this.frequencyEstimator.getMinFrequency(),\n      this.frequencyEstimator.getMaxFrequency()\n    );\n\n    // Update comparison panels with similarity history\n    // Use original 4-cycle range from WASM (renderData.displayStartIndex/displayEndIndex)\n    // instead of the phase-marker-narrowed range (displayStartIndex/displayEndIndex)\n    this.comparisonRenderer.updatePanels(\n      renderData.previousWaveform,\n      renderData.waveformData,\n      renderData.displayStartIndex,\n      renderData.displayEndIndex,\n      renderData.waveformData,\n      renderData.similarity,\n      renderData.similarityPlotHistory,\n      renderData.phaseZeroOffsetHistory,\n      renderData.phaseTwoPiOffsetHistory\n    );\n    \n    // Update cycle similarity graphs if renderer is available\n    if (this.cycleSimilarityRenderer) {\n      this.cycleSimilarityRenderer.updateGraphs(\n        renderData.cycleSimilarities8div,\n        renderData.cycleSimilarities4div,\n        renderData.cycleSimilarities2div\n      );\n    }\n  }\n\n  // Getters and setters - delegate to appropriate modules\n  getIsRunning(): boolean {\n    return this.isRunning;\n  }\n\n  setAutoGain(enabled: boolean): void {\n    this.gainController.setAutoGain(enabled);\n  }\n\n  getAutoGainEnabled(): boolean {\n    return this.gainController.getAutoGainEnabled();\n  }\n\n  setNoiseGate(enabled: boolean): void {\n    this.gainController.setNoiseGate(enabled);\n  }\n\n  getNoiseGateEnabled(): boolean {\n    return this.gainController.getNoiseGateEnabled();\n  }\n\n  setNoiseGateThreshold(threshold: number): void {\n    this.gainController.setNoiseGateThreshold(threshold);\n  }\n\n  getNoiseGateThreshold(): number {\n    return this.gainController.getNoiseGateThreshold();\n  }\n\n  setFrequencyEstimationMethod(method: 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt'): void {\n    this.frequencyEstimator.setFrequencyEstimationMethod(method);\n  }\n\n  getFrequencyEstimationMethod(): string {\n    return this.frequencyEstimator.getFrequencyEstimationMethod();\n  }\n\n  setBufferSizeMultiplier(multiplier: 1 | 4 | 16): void {\n    this.frequencyEstimator.setBufferSizeMultiplier(multiplier);\n  }\n\n  getBufferSizeMultiplier(): 1 | 4 | 16 {\n    return this.frequencyEstimator.getBufferSizeMultiplier();\n  }\n\n  getEstimatedFrequency(): number {\n    return this.frequencyEstimator.getEstimatedFrequency();\n  }\n\n  setFFTDisplay(enabled: boolean): void {\n    this.renderer.setFFTDisplay(enabled);\n  }\n\n  getFFTDisplayEnabled(): boolean {\n    return this.renderer.getFFTDisplayEnabled();\n  }\n\n  /**\n   * Enable or disable harmonic analysis overlay\n   * When disabled, the yellow-bordered harmonic analysis panel in the top-left corner is hidden\n   * @param enabled - true to show harmonic analysis overlay, false to hide it\n   */\n  setHarmonicAnalysisEnabled(enabled: boolean): void {\n    this.renderer.setHarmonicAnalysisEnabled(enabled);\n  }\n\n  /**\n   * Get the current state of harmonic analysis overlay\n   * @returns true if harmonic analysis overlay is enabled, false otherwise\n   */\n  getHarmonicAnalysisEnabled(): boolean {\n    return this.renderer.getHarmonicAnalysisEnabled();\n  }\n\n  /**\n   * Enable or disable debug overlays (harmonic analysis, frequency plot)\n   * Debug overlays show detailed debugging information with yellow borders (#ffaa00)\n   * including harmonic analysis and frequency history plot\n   * \n   * When using cat-oscilloscope as a library, it's recommended to disable these\n   * overlays for a cleaner, more professional appearance\n   * \n   * @param enabled - true to show debug overlays (default for standalone app),\n   *                  false to hide them (recommended for library usage)\n   */\n  setDebugOverlaysEnabled(enabled: boolean): void {\n    this.renderer.setDebugOverlaysEnabled(enabled);\n  }\n\n  /**\n   * Get the current state of debug overlays\n   * @returns true if debug overlays are enabled, false otherwise\n   */\n  getDebugOverlaysEnabled(): boolean {\n    return this.renderer.getDebugOverlaysEnabled();\n  }\n\n  /**\n   * Set the layout configuration for overlays\n   * Allows external applications to control the position and size of debug overlays\n   * @param layout - Layout configuration for overlays (FFT, harmonic analysis, frequency plot)\n   */\n  setOverlaysLayout(layout: OverlaysLayoutConfig): void {\n    this.renderer.setOverlaysLayout(layout);\n  }\n\n  /**\n   * Get the current overlays layout configuration\n   * @returns Current overlays layout configuration\n   */\n  getOverlaysLayout(): OverlaysLayoutConfig {\n    return this.renderer.getOverlaysLayout();\n  }\n\n  getCurrentGain(): number {\n    return this.gainController.getCurrentGain();\n  }\n  \n  getSimilarityScore(): number {\n    return this.waveformSearcher.getLastSimilarity();\n  }\n  \n  isSimilaritySearchActive(): boolean {\n    return this.waveformSearcher.hasPreviousWaveform();\n  }\n  \n  setUsePeakMode(enabled: boolean): void {\n    this.zeroCrossDetector.setUsePeakMode(enabled);\n  }\n\n  getUsePeakMode(): boolean {\n    return this.zeroCrossDetector.getUsePeakMode();\n  }\n  \n  setZeroCrossMode(mode: 'standard' | 'peak-backtrack-history' | 'bidirectional-nearest' | 'gradient-based' | 'adaptive-step' | 'hysteresis' | 'closest-to-zero'): void {\n    this.zeroCrossDetector.setZeroCrossMode(mode);\n  }\n\n  getZeroCrossMode(): 'standard' | 'peak-backtrack-history' | 'bidirectional-nearest' | 'gradient-based' | 'adaptive-step' | 'hysteresis' | 'closest-to-zero' {\n    return this.zeroCrossDetector.getZeroCrossMode();\n  }\n  \n  setPauseDrawing(paused: boolean): void {\n    this.isPaused = paused;\n  }\n\n  getPauseDrawing(): boolean {\n    return this.isPaused;\n  }\n\n  /**\n   * Enable or disable phase marker range display mode\n   * When enabled (default), displays only the range between orange-red-red-orange markers\n   * When disabled, displays the full waveform segment\n   * @param enabled - true to display only phase marker range, false to display full segment\n   */\n  setPhaseMarkerRangeEnabled(enabled: boolean): void {\n    this.phaseMarkerRangeEnabled = enabled;\n  }\n\n  /**\n   * Get the current state of phase marker range display mode\n   * @returns true if phase marker range display is enabled, false otherwise\n   */\n  getPhaseMarkerRangeEnabled(): boolean {\n    return this.phaseMarkerRangeEnabled;\n  }\n}\n","import { frequencyToNote } from './utils';\n\n/**\n * PianoKeyboardRenderer handles rendering of piano keyboard visualization\n * Displays a piano keyboard for the frequency range 50Hz - 2000Hz\n * Highlights the key corresponding to the fundamental frequency\n */\nexport class PianoKeyboardRenderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  \n  // 周波数範囲 (50Hz～2000Hz)\n  private readonly MIN_FREQ = 50;\n  private readonly MAX_FREQ = 2000;\n  \n  // ピアノ鍵盤の定数\n  private readonly WHITE_KEY_WIDTH = 20;\n  private readonly WHITE_KEY_HEIGHT = 60;\n  private readonly BLACK_KEY_WIDTH = 12;\n  private readonly BLACK_KEY_HEIGHT = 38;\n  \n  // 色定義\n  private readonly WHITE_KEY_COLOR = '#ffffff';\n  private readonly BLACK_KEY_COLOR = '#000000';\n  private readonly WHITE_KEY_HIGHLIGHT = '#00ff00';\n  private readonly BLACK_KEY_HIGHLIGHT = '#00cc00';\n  private readonly KEY_BORDER = '#333333';\n  \n  // 音名パターン定数（配列アロケーションを避けるため）\n  // 白鍵: C(0), D(2), E(4), F(5), G(7), A(9), B(11)\n  private readonly WHITE_KEY_NOTES = [0, 2, 4, 5, 7, 9, 11];\n  // 黒鍵: C#(1), D#(3), F#(6), G#(8), A#(10)\n  private readonly BLACK_KEY_NOTES = [1, 3, 6, 8, 10];\n  \n  // キャッシュされた鍵盤範囲（コンストラクタで一度だけ計算）\n  private readonly keyboardRange: { startNote: number; endNote: number };\n  \n  // センタリング用のオフセット（コンストラクタで一度だけ計算）\n  private readonly xOffset: number;\n  \n  // 白鍵の総数（コンストラクタで一度だけ計算）\n  private readonly whiteKeyCount: number;\n  \n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get 2D context for piano keyboard');\n    }\n    this.ctx = context;\n    \n    // 鍵盤範囲を一度だけ計算してキャッシュ\n    this.keyboardRange = this.calculateKeyboardRange();\n    \n    // 白鍵の数を計算してキャッシュ\n    this.whiteKeyCount = this.countWhiteKeys();\n    \n    // センタリング用のオフセットを計算\n    this.xOffset = this.calculateCenteringOffset();\n  }\n  \n  /**\n   * 周波数から音名情報を取得\n   * utils.tsのfrequencyToNote関数を使用し、内部形式に変換\n   */\n  private frequencyToNoteInfo(frequency: number): { note: number; octave: number; noteInOctave: number } {\n    const noteInfo = frequencyToNote(frequency);\n    \n    if (!noteInfo) {\n      return { note: -1, octave: -1, noteInOctave: -1 };\n    }\n    \n    // noteName (e.g., \"A4\", \"C#3\") から音名とオクターブを抽出\n    const matches = noteInfo.noteName.match(/^([A-G]#?)(\\d+)$/);\n    if (!matches) {\n      return { note: -1, octave: -1, noteInOctave: -1 };\n    }\n    \n    const noteName = matches[1];\n    const octave = parseInt(matches[2], 10);\n    \n    // 音名から noteInOctave (0-11) を計算\n    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const noteInOctave = noteNames.indexOf(noteName);\n    \n    // noteIndex を計算 (C0 = 0)\n    const note = octave * 12 + noteInOctave;\n    \n    return { note, octave, noteInOctave };\n  }\n  \n  /**\n   * 表示する鍵盤の範囲を計算\n   * MIN_FREQからMAX_FREQまでの範囲をカバーする\n   */\n  private calculateKeyboardRange(): { startNote: number; endNote: number } {\n    const startNoteInfo = this.frequencyToNoteInfo(this.MIN_FREQ);\n    const endNoteInfo = this.frequencyToNoteInfo(this.MAX_FREQ);\n    \n    return {\n      startNote: startNoteInfo.note,\n      endNote: endNoteInfo.note\n    };\n  }\n  \n  /**\n   * 白鍵の数をカウント\n   */\n  private countWhiteKeys(): number {\n    const range = this.keyboardRange;\n    let count = 0;\n    for (let note = range.startNote; note <= range.endNote; note++) {\n      const noteInOctave = ((note % 12) + 12) % 12;\n      if (this.WHITE_KEY_NOTES.includes(noteInOctave)) {\n        count++;\n      }\n    }\n    return count;\n  }\n  \n  /**\n   * 鍵盤をセンタリングするためのX座標オフセットを計算\n   */\n  private calculateCenteringOffset(): number {\n    // 鍵盤全体の幅\n    const totalKeyboardWidth = this.whiteKeyCount * this.WHITE_KEY_WIDTH;\n    \n    // センタリング用のオフセット\n    return (this.canvas.width - totalKeyboardWidth) / 2;\n  }\n  \n  /**\n   * ピアノ鍵盤を描画\n   * @param highlightFrequency - ハイライトする周波数 (0の場合はハイライトなし)\n   */\n  render(highlightFrequency: number): void {\n    // キャンバスをクリア\n    this.ctx.fillStyle = '#1a1a1a';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    const range = this.keyboardRange;\n    \n    // ハイライトする音名を計算\n    const highlightNoteInfo = highlightFrequency > 0 ? this.frequencyToNoteInfo(highlightFrequency) : null;\n    \n    // 白鍵を描画\n    let whiteKeyIndex = 0;\n    for (let note = range.startNote; note <= range.endNote; note++) {\n      const noteInOctave = ((note % 12) + 12) % 12;\n      \n      // 白鍵の場合\n      if (this.WHITE_KEY_NOTES.includes(noteInOctave)) {\n        const x = this.xOffset + whiteKeyIndex * this.WHITE_KEY_WIDTH;\n        const isHighlighted = highlightNoteInfo && highlightNoteInfo.note === note;\n        \n        this.ctx.fillStyle = isHighlighted ? this.WHITE_KEY_HIGHLIGHT : this.WHITE_KEY_COLOR;\n        this.ctx.fillRect(x, 0, this.WHITE_KEY_WIDTH, this.WHITE_KEY_HEIGHT);\n        \n        this.ctx.strokeStyle = this.KEY_BORDER;\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x, 0, this.WHITE_KEY_WIDTH, this.WHITE_KEY_HEIGHT);\n        \n        whiteKeyIndex++;\n      }\n    }\n    \n    // 黒鍵を描画（白鍵の上に重ねて描画）\n    whiteKeyIndex = 0;\n    for (let note = range.startNote; note <= range.endNote; note++) {\n      const noteInOctave = ((note % 12) + 12) % 12;\n      \n      // 白鍵の位置をカウント\n      if (this.WHITE_KEY_NOTES.includes(noteInOctave)) {\n        whiteKeyIndex++;\n      }\n      \n      // 黒鍵の場合\n      if (this.BLACK_KEY_NOTES.includes(noteInOctave)) {\n        // 黒鍵は直前の白鍵の右端に配置\n        const x = this.xOffset + whiteKeyIndex * this.WHITE_KEY_WIDTH - this.BLACK_KEY_WIDTH / 2;\n        const isHighlighted = highlightNoteInfo && highlightNoteInfo.note === note;\n        \n        this.ctx.fillStyle = isHighlighted ? this.BLACK_KEY_HIGHLIGHT : this.BLACK_KEY_COLOR;\n        this.ctx.fillRect(x, 0, this.BLACK_KEY_WIDTH, this.BLACK_KEY_HEIGHT);\n        \n        this.ctx.strokeStyle = this.KEY_BORDER;\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x, 0, this.BLACK_KEY_WIDTH, this.BLACK_KEY_HEIGHT);\n      }\n    }\n    \n    // 周波数範囲を表示\n    this.ctx.fillStyle = '#888888';\n    this.ctx.font = '10px monospace';\n    this.ctx.fillText(`${this.MIN_FREQ}Hz`, this.xOffset + 5, this.WHITE_KEY_HEIGHT - 5);\n    \n    // 右端の周波数表示の位置を計算\n    const text = `${this.MAX_FREQ}Hz`;\n    const textWidth = this.ctx.measureText(text).width;\n    const rightEdge = this.xOffset + this.whiteKeyCount * this.WHITE_KEY_WIDTH;\n    this.ctx.fillText(text, rightEdge - textWidth - 5, this.WHITE_KEY_HEIGHT - 5);\n  }\n  \n  /**\n   * キャンバスをクリア\n   */\n  clear(): void {\n    this.ctx.fillStyle = '#1a1a1a';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n","/**\n * BufferSource provides audio data from a static buffer (Float32Array or AudioBuffer)\n * without requiring audio playback through the Web Audio API.\n * This is useful for visualizing pre-recorded audio data or processing results.\n */\nexport class BufferSource {\n  private buffer: Float32Array;\n  private sampleRate: number;\n  private position: number = 0;\n  private chunkSize: number = 4096; // Default FFT size\n  private isLooping: boolean = false;\n\n  /**\n   * Create a BufferSource from Float32Array\n   * @param buffer - Audio data as Float32Array (values typically in range -1.0 to 1.0)\n   * @param sampleRate - Sample rate in Hz (e.g., 44100, 48000)\n   * @param options - Optional configuration\n   */\n  constructor(\n    buffer: Float32Array,\n    sampleRate: number,\n    options?: {\n      chunkSize?: number;\n      loop?: boolean;\n    }\n  ) {\n    // Validate sample rate\n    if (sampleRate <= 0 || !isFinite(sampleRate)) {\n      throw new Error('Sample rate must be a positive finite number');\n    }\n    \n    this.buffer = buffer;\n    this.sampleRate = sampleRate;\n    \n    if (options?.chunkSize !== undefined) {\n      // Validate chunk size\n      if (options.chunkSize <= 0 || !isFinite(options.chunkSize) || !Number.isInteger(options.chunkSize)) {\n        throw new Error('Chunk size must be a positive integer');\n      }\n      this.chunkSize = options.chunkSize;\n    }\n    \n    if (options?.loop !== undefined) {\n      this.isLooping = options.loop;\n    }\n  }\n\n  /**\n   * Create a BufferSource from AudioBuffer\n   * @param audioBuffer - Web Audio API AudioBuffer\n   * @param options - Optional configuration\n   */\n  static fromAudioBuffer(\n    audioBuffer: AudioBuffer,\n    options?: {\n      chunkSize?: number;\n      loop?: boolean;\n      channel?: number;\n    }\n  ): BufferSource {\n    const channelIndex = options?.channel ?? 0;\n    \n    // Validate channel index\n    if (channelIndex < 0 || channelIndex >= audioBuffer.numberOfChannels) {\n      throw new Error(\n        `Invalid channel index ${channelIndex}. AudioBuffer has ${audioBuffer.numberOfChannels} channel(s).`\n      );\n    }\n    \n    const channelData = audioBuffer.getChannelData(channelIndex);\n    \n    return new BufferSource(channelData, audioBuffer.sampleRate, {\n      chunkSize: options?.chunkSize,\n      loop: options?.loop\n    });\n  }\n\n  /**\n   * Get the next chunk of audio data\n   * @returns Float32Array chunk or null if end is reached and not looping\n   */\n  getNextChunk(): Float32Array | null {\n    // Handle empty buffer case - return null even in loop mode to prevent infinite loop\n    if (this.buffer.length === 0) {\n      return null;\n    }\n    \n    if (this.position >= this.buffer.length) {\n      if (this.isLooping) {\n        this.position = 0;\n      } else {\n        return null;\n      }\n    }\n\n    const endPosition = Math.min(this.position + this.chunkSize, this.buffer.length);\n    const chunk = this.buffer.slice(this.position, endPosition);\n    \n    // If chunk is smaller than chunkSize and we're looping, wrap around\n    if (chunk.length < this.chunkSize && this.isLooping) {\n      const remaining = this.chunkSize - chunk.length;\n      // Ensure we don't try to read more than buffer length when wrapping\n      const wrapAmount = Math.min(remaining, this.buffer.length);\n      const wrappedChunk = new Float32Array(this.chunkSize);\n      wrappedChunk.set(chunk, 0);\n      wrappedChunk.set(this.buffer.slice(0, wrapAmount), chunk.length);\n      this.position = wrapAmount;\n      return wrappedChunk;\n    }\n    \n    this.position = endPosition;\n    \n    // If chunk is smaller than expected and we're not looping, pad with zeros\n    if (chunk.length < this.chunkSize) {\n      const paddedChunk = new Float32Array(this.chunkSize);\n      paddedChunk.set(chunk, 0);\n      return paddedChunk;\n    }\n    \n    return chunk;\n  }\n\n  /**\n   * Reset playback position to the beginning\n   */\n  reset(): void {\n    this.position = 0;\n  }\n\n  /**\n   * Seek to a specific position in the buffer\n   * @param positionInSamples - Position in samples\n   */\n  seek(positionInSamples: number): void {\n    this.position = Math.max(0, Math.min(positionInSamples, this.buffer.length));\n  }\n\n  /**\n   * Get current position in samples\n   */\n  getPosition(): number {\n    return this.position;\n  }\n\n  /**\n   * Get total buffer length in samples\n   */\n  getLength(): number {\n    return this.buffer.length;\n  }\n\n  /**\n   * Get sample rate\n   */\n  getSampleRate(): number {\n    return this.sampleRate;\n  }\n\n  /**\n   * Set chunk size\n   */\n  setChunkSize(size: number): void {\n    // Validate chunk size\n    if (size <= 0 || !isFinite(size) || !Number.isInteger(size)) {\n      throw new Error('Chunk size must be a positive integer');\n    }\n    this.chunkSize = size;\n  }\n\n  /**\n   * Get chunk size\n   */\n  getChunkSize(): number {\n    return this.chunkSize;\n  }\n\n  /**\n   * Set looping mode\n   */\n  setLooping(loop: boolean): void {\n    this.isLooping = loop;\n  }\n\n  /**\n   * Get looping mode\n   */\n  isLoop(): boolean {\n    return this.isLooping;\n  }\n\n  /**\n   * Check if end of buffer is reached\n   */\n  isAtEnd(): boolean {\n    return this.position >= this.buffer.length && !this.isLooping;\n  }\n}\n"],"names":["dbToAmplitude","db","amplitudeToDb","amplitude","frequencyToNote","frequency","C0","halfSteps","noteIndex","cents","noteNames","octave","SILENCE_THRESHOLD_DB","trimSilence","audioBuffer","numberOfChannels","sampleRate","length","channelDataCache","peakAmplitude","channel","data","i","threshold","startIndex","isSilent","endIndex","trimmedLength","trimmedBuffer","sourceData","destData","FrameBufferHistory","__publicField","currentBuffer","buffer","multiplier","recentBuffers","totalLength","sum","buf","extendedBuffer","offset","AudioManager","bufferLength","source","error","file","arrayBuffer","bufferSource","track","chunk","_a","GainController","enabled","FrequencyEstimator","method","resolveValue","value","canvasSize","percentage","parsed","DEFAULT_OVERLAYS_LAYOUT","BaseOverlayRenderer","ctx","canvasWidth","canvasHeight","width","height","layout","defaultX","defaultY","defaultWidth","defaultHeight","x","y","resolvedWidth","GridRenderer","displaySamples","gain","horizontalLines","verticalLines","displayTimeMs","timePerDivision","timeMs","label","textWidth","labelX","amplitudePerDivision","sign","absDb","WaveformLineRenderer","dataLength","sliceWidth","centerY","dataIndex","rawY","FFTOverlayRenderer","frequencyData","estimatedFrequency","fftSize","maxFrequency","binFrequency","defaultOverlayWidth","defaultOverlayHeight","defaultOverlayX","defaultOverlayY","overlayX","overlayY","overlayWidth","overlayHeight","maxBin","barWidth","barHeight","frequencyBin","markerX","HarmonicAnalysisRenderer","halfFreqPeakStrengthPercent","candidate1Harmonics","candidate2Harmonics","candidate1WeightedScore","candidate2WeightedScore","selectionReason","lineHeight","currentY","halfFreq","harmonicsStr","weightedStr","v","maxWidth","words","line","word","testLine","FrequencyPlotRenderer","frequencyHistory","minFrequency","plotX","plotY","plotWidth","plotHeight","validFrequencies","f","dataMin","dataMax","rangePadding","displayMin","displayMax","freq","noteInfo","centsSign","xStep","labelInterval","frequencyToY","normalizedFreq","hasValidPoint","isLatestFrame","frameOffset","currentFreq","displayText","PhaseMarkerRenderer","debugOverlaysEnabled","phaseZeroIndex","phaseTwoPiIndex","phaseMinusQuarterPiIndex","phaseTwoPiPlusQuarterPiIndex","displayStartIndex","displayEndIndex","debugInfo","displayLength","drawVerticalLine","sampleIndex","color","lineWidth","relativeIndex","segRel","history","tolerance","text","WaveformRenderer","canvas","overlaysLayout","context","ZeroCrossDetector","mode","WaveformSearcher","WaveformPanelRenderer","peak","clampedStart","clampedEnd","scalingFactor","SimilarityPlotRenderer","similarityHistory","similarity","normalizedSimilarity","currentSimilarity","PositionMarkerRenderer","startX","endX","OffsetOverlayRenderer","phaseZeroOffsetHistory","phaseTwoPiOffsetHistory","innerPadding","innerPlotX","innerPlotY","innerPlotWidth","innerPlotHeight","minPercent","maxPercent","zeroLine","drawOffsetLine","offsetHistory","percent","normalizedPercent","currentZeroOffset","currentTwoPiOffset","ComparisonPanelRenderer","previousCanvas","currentCanvas","similarityCanvas","bufferCanvas","prevCtx","currCtx","simCtx","buffCtx","previousWaveform","currentWaveform","currentStart","currentEnd","fullBuffer","_CycleSimilarityRenderer","canvas8div","canvas4div","canvas2div","ctx8","ctx4","ctx2","title","segmentLabel","zeroY","numSegments","segIdx","frameIdx","frame","lastFrame","legendHeight","legendWidth","legendX","legendY","itemY","similarities8div","similarities4div","similarities2div","CycleSimilarityRenderer","_BasePathResolver","basePath","segments","segment","scripts","script","src","pathname","pattern","index","BasePathResolver","WasmModuleLoader","resolve","reject","timeout","cleanup","wasmPath","handleLoad","WaveformDataProcessor","audioManager","gainController","frequencyEstimator","waveformSearcher","zeroCrossDetector","wasmProcessor","renderData","fftDisplayEnabled","dataArray","needsFrequencyData","computedFreqData","wasmResult","phaseZeroPercent","phaseTwoPiPercent","Oscilloscope","previousWaveformCanvas","currentWaveformCanvas","similarityPlotCanvas","frameBufferCanvas","cycleSimilarity8divCanvas","cycleSimilarity4divCanvas","cycleSimilarity2divCanvas","startTime","processingTime","currentFps","avgProcessingTime","b","paused","PianoKeyboardRenderer","matches","noteName","noteInOctave","startNoteInfo","endNoteInfo","range","count","note","totalKeyboardWidth","highlightFrequency","highlightNoteInfo","whiteKeyIndex","isHighlighted","rightEdge","BufferSource","options","channelIndex","channelData","endPosition","remaining","wrapAmount","wrappedChunk","paddedChunk","positionInSamples","size","loop"],"mappings":"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"}