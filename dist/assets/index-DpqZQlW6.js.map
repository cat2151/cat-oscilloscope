{"version":3,"file":"index-DpqZQlW6.js","sources":["../../src/utils.ts","../../src/AudioManager.ts","../../src/GainController.ts","../../src/FrequencyEstimator.ts","../../src/OverlayLayout.ts","../../src/WaveformRenderer.ts","../../src/ZeroCrossDetector.ts","../../src/WaveformSearcher.ts","../../src/ComparisonPanelRenderer.ts","../../src/WaveformDataProcessor.ts","../../src/Oscilloscope.ts","../../src/PianoKeyboardRenderer.ts","../../src/main.ts"],"sourcesContent":["/**\n * Utility functions for threshold conversions and audio processing\n */\n\n/**\n * Convert dB value to amplitude (linear)\n * @param db - Decibel value (typically -60 to 0)\n * @returns Amplitude value (typically 0.001 to 1.0)\n */\nexport function dbToAmplitude(db: number): number {\n  return Math.pow(10, db / 20);\n}\n\n/**\n * Convert amplitude (linear) to dB value\n * @param amplitude - Amplitude value (typically 0.001 to infinity)\n * @returns Decibel value\n */\nexport function amplitudeToDb(amplitude: number): number {\n  if (amplitude <= 0) {\n    return -Infinity;\n  }\n  return 20 * Math.log10(amplitude);\n}\n\n/**\n * Convert frequency to musical note name and cent deviation\n * @param frequency - Frequency in Hz\n * @returns Object with note name (e.g., \"A4\") and cent deviation (e.g., 0), or null if frequency is invalid\n */\nexport function frequencyToNote(frequency: number): { noteName: string; cents: number } | null {\n  if (frequency <= 0 || !isFinite(frequency)) {\n    return null;\n  }\n\n  // A4 = 440 Hz is our reference\n  const A4 = 440;\n  // C0 is 4 octaves and 9 semitones (4.75 octaves) below A4\n  // Each octave is a factor of 2, so C0 = A4 / 2^4.75\n  const C0 = A4 * Math.pow(2, -4.75);\n\n  // Calculate the number of half steps from C0\n  const halfSteps = 12 * Math.log2(frequency / C0);\n  \n  // Round to nearest half step to get the note\n  const noteIndex = Math.round(halfSteps);\n  \n  // Calculate cent deviation from the nearest note (-50 to +50)\n  const cents = Math.round((halfSteps - noteIndex) * 100);\n  \n  // Note names in chromatic scale\n  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n  \n  // Calculate octave and note name\n  const octave = Math.floor(noteIndex / 12);\n  // Use ((noteIndex % 12) + 12) % 12 to handle negative values correctly\n  const note = noteNames[((noteIndex % 12) + 12) % 12];\n  \n  return {\n    noteName: `${note}${octave}`,\n    cents: cents\n  };\n}\n\n/**\n * Silence threshold in dB relative to peak amplitude\n * Samples below this level relative to the peak are considered silence\n */\nconst SILENCE_THRESHOLD_DB = -48;\n\n/**\n * Trim silence from the beginning and end of an AudioBuffer\n * The threshold is calculated as -48dB relative to the peak amplitude of the entire buffer\n * @param audioBuffer - The audio buffer to trim\n * @returns A new AudioBuffer with silence trimmed, or the original if no trimming is needed\n */\nexport function trimSilence(audioBuffer: AudioBuffer): AudioBuffer {\n  const numberOfChannels = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const length = audioBuffer.length;\n  \n  // Cache channel data for reuse and calculate peak amplitude\n  const channelDataCache: Float32Array[] = [];\n  let peakAmplitude = 0;\n  \n  for (let channel = 0; channel < numberOfChannels; channel++) {\n    const data = audioBuffer.getChannelData(channel);\n    channelDataCache.push(data);\n    \n    for (let i = 0; i < length; i++) {\n      const amplitude = Math.abs(data[i]);\n      if (amplitude > peakAmplitude) {\n        peakAmplitude = amplitude;\n      }\n    }\n  }\n  \n  // If the entire buffer is silent (peak is zero), return the original\n  if (peakAmplitude === 0) {\n    return audioBuffer;\n  }\n  \n  // Calculate threshold as SILENCE_THRESHOLD_DB relative to peak amplitude\n  const threshold = peakAmplitude * Math.pow(10, SILENCE_THRESHOLD_DB / 20);\n  \n  // Find the start index (first non-silent sample across all channels)\n  let startIndex = length; // Initialize to length to detect if no non-silent sample found\n  for (let i = 0; i < length; i++) {\n    let isSilent = true;\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n      if (Math.abs(channelDataCache[channel][i]) > threshold) {\n        isSilent = false;\n        break;\n      }\n    }\n    if (!isSilent) {\n      startIndex = i;\n      break;\n    }\n  }\n  \n  // If entire buffer is silent, return the original\n  if (startIndex >= length) {\n    return audioBuffer;\n  }\n  \n  // Find the end index (last non-silent sample across all channels)\n  let endIndex = length - 1;\n  for (let i = length - 1; i >= startIndex; i--) {\n    let isSilent = true;\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n      if (Math.abs(channelDataCache[channel][i]) > threshold) {\n        isSilent = false;\n        break;\n      }\n    }\n    if (!isSilent) {\n      endIndex = i;\n      break;\n    }\n  }\n  \n  // If no trimming is needed, return the original\n  if (startIndex === 0 && endIndex === length - 1) {\n    return audioBuffer;\n  }\n  \n  // Create a new buffer with the trimmed length\n  const trimmedLength = endIndex - startIndex + 1;\n  const trimmedBuffer = new AudioBuffer({\n    numberOfChannels: numberOfChannels,\n    length: trimmedLength,\n    sampleRate: sampleRate\n  });\n  \n  // Copy the non-silent samples to the new buffer\n  for (let channel = 0; channel < numberOfChannels; channel++) {\n    const sourceData = channelDataCache[channel];\n    const destData = trimmedBuffer.getChannelData(channel);\n    for (let i = 0; i < trimmedLength; i++) {\n      destData[i] = sourceData[startIndex + i];\n    }\n  }\n  \n  return trimmedBuffer;\n}\n","import { trimSilence } from './utils';\nimport { BufferSource } from './BufferSource';\n\n/**\n * AudioManager handles Web Audio API integration\n * Responsible for:\n * - AudioContext lifecycle management\n * - MediaStream management\n * - AnalyserNode configuration\n * - Audio data retrieval\n * - BufferSource support for static buffer visualization\n */\nexport class AudioManager {\n  private audioContext: AudioContext | null = null;\n  private analyser: AnalyserNode | null = null;\n  private mediaStream: MediaStream | null = null;\n  private audioBufferSource: AudioBufferSourceNode | null = null;\n  private bufferSource: BufferSource | null = null;\n  private dataArray: Float32Array | null = null;\n  private frequencyData: Uint8Array | null = null;\n  private frameBufferHistory: Float32Array[] = []; // History of frame buffers for extended FFT\n  private readonly MAX_FRAME_HISTORY = 16; // Support up to 16x buffer size\n\n  /**\n   * Initialize analyser node and data arrays\n   */\n  private initializeAnalyser(): void {\n    if (!this.audioContext) {\n      throw new Error('AudioContext must be initialized before creating analyser');\n    }\n\n    // Create analyser node with high resolution\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = 4096; // Higher resolution for better waveform\n    this.analyser.smoothingTimeConstant = 0; // No smoothing for accurate waveform\n    \n    // Create data array for time domain data\n    const bufferLength = this.analyser.fftSize;\n    this.dataArray = new Float32Array(bufferLength);\n    \n    // Create frequency data array for FFT\n    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);\n  }\n\n  /**\n   * Start audio capture and analysis\n   */\n  async start(): Promise<void> {\n    try {\n      // Request microphone access\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n      // Set up Web Audio API\n      this.audioContext = new AudioContext();\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n      \n      // Initialize analyser and data arrays\n      this.initializeAnalyser();\n      \n      // Connect nodes\n      source.connect(this.analyser!);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start audio playback from file\n   */\n  async startFromFile(file: File): Promise<void> {\n    try {\n      // Read file as ArrayBuffer\n      const arrayBuffer = await file.arrayBuffer();\n      \n      // Close existing AudioContext if present to avoid resource leak\n      if (this.audioContext && this.audioContext.state !== 'closed') {\n        await this.audioContext.close();\n      }\n\n      // Set up Web Audio API\n      this.audioContext = new AudioContext();\n      \n      // Decode audio data\n      let audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n      \n      // Trim silence from the beginning and end to avoid gaps in loop playback\n      audioBuffer = trimSilence(audioBuffer);\n      \n      // Initialize analyser and data arrays\n      this.initializeAnalyser();\n      \n      // Create buffer source for looping playback\n      this.audioBufferSource = this.audioContext.createBufferSource();\n      this.audioBufferSource.buffer = audioBuffer;\n      this.audioBufferSource.loop = true;\n      \n      // Connect nodes: source -> analyser -> destination\n      this.audioBufferSource.connect(this.analyser!);\n      this.analyser!.connect(this.audioContext.destination);\n      \n      // Start playback\n      this.audioBufferSource.start(0);\n    } catch (error) {\n      console.error('Error loading audio file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start visualization from a static buffer without audio playback\n   * Useful for visualizing pre-recorded audio data or processing results\n   * @param bufferSource - BufferSource instance containing audio data\n   */\n  async startFromBuffer(bufferSource: BufferSource): Promise<void> {\n    try {\n      // Close existing AudioContext if present to avoid resource leak\n      if (this.audioContext && this.audioContext.state !== 'closed') {\n        await this.audioContext.close();\n      }\n\n      // Buffer mode does not use AudioContext - it provides data directly\n      this.audioContext = null;\n      \n      // Store the buffer source\n      this.bufferSource = bufferSource;\n      \n      // Set chunk size to match our FFT size\n      this.bufferSource.setChunkSize(4096);\n      \n      // Initialize data arrays manually (no analyser node needed for buffer mode)\n      this.dataArray = new Float32Array(4096);\n      this.frequencyData = new Uint8Array(2048); // Half of FFT size\n      \n      // Note: We don't create an analyser node in buffer mode\n      // The data will be provided directly from the BufferSource\n    } catch (error) {\n      console.error('Error starting from buffer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop audio capture and clean up resources\n   */\n  async stop(): Promise<void> {\n    if (this.audioBufferSource) {\n      try {\n        this.audioBufferSource.stop();\n      } catch (error) {\n        // Ignore error if already stopped or in invalid state\n      }\n      try {\n        this.audioBufferSource.disconnect();\n      } catch (error) {\n        // Ignore disconnect errors\n      }\n      this.audioBufferSource = null;\n    }\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n    if (this.bufferSource) {\n      this.bufferSource.reset();\n      this.bufferSource = null;\n    }\n    if (this.audioContext) {\n      try {\n        await this.audioContext.close();\n      } catch (error) {\n        console.error('Error closing AudioContext:', error);\n      }\n      this.audioContext = null;\n    }\n    this.analyser = null;\n    this.dataArray = null;\n    this.frequencyData = null;\n    this.clearFrameBufferHistory();\n  }\n\n  /**\n   * Get time-domain data (waveform)\n   * Also updates the frame buffer history for extended FFT\n   */\n  getTimeDomainData(): Float32Array | null {\n    // Buffer mode: get data directly from BufferSource\n    if (this.bufferSource && this.dataArray) {\n      const chunk = this.bufferSource.getNextChunk();\n      if (chunk) {\n        this.dataArray.set(chunk);\n        this.updateFrameBufferHistory(this.dataArray);\n        return this.dataArray;\n      }\n      return null;\n    }\n    \n    // Normal mode: get data from analyser node\n    if (!this.analyser || !this.dataArray) {\n      return null;\n    }\n    // @ts-ignore - Web Audio API type definitions issue\n    this.analyser.getFloatTimeDomainData(this.dataArray);\n    \n    // Store a copy of the current frame buffer for history\n    this.updateFrameBufferHistory(this.dataArray);\n    \n    return this.dataArray;\n  }\n  \n  /**\n   * Update frame buffer history with the current frame\n   * Reuses existing buffers to avoid allocating a new Float32Array every frame\n   */\n  private updateFrameBufferHistory(currentBuffer: Float32Array): void {\n    let buffer: Float32Array;\n\n    if (this.frameBufferHistory.length < this.MAX_FRAME_HISTORY) {\n      // Warm-up phase: allocate new buffers until we reach MAX_FRAME_HISTORY\n      buffer = new Float32Array(currentBuffer.length);\n    } else {\n      // Steady state: reuse the oldest buffer\n      buffer = this.frameBufferHistory.shift() as Float32Array;\n      // If FFT size (and thus buffer length) has changed, reallocate\n      if (buffer.length !== currentBuffer.length) {\n        buffer = new Float32Array(currentBuffer.length);\n      }\n    }\n\n    // Copy current data into the buffer\n    buffer.set(currentBuffer);\n\n    // Add updated buffer as most recent\n    this.frameBufferHistory.push(buffer);\n  }\n  \n  /**\n   * Get extended time-domain data by concatenating past frame buffers\n   * @param multiplier - Buffer size multiplier (1, 4, or 16)\n   * @returns Combined buffer or null if insufficient history\n   */\n  getExtendedTimeDomainData(multiplier: 1 | 4 | 16): Float32Array | null {\n    if (multiplier === 1) {\n      // Return current buffer for 1x\n      return this.dataArray;\n    }\n    \n    if (!this.dataArray || this.frameBufferHistory.length < multiplier) {\n      return null; // Not enough history yet\n    }\n    \n    // Get the most recent 'multiplier' buffers\n    const recentBuffers = this.frameBufferHistory.slice(-multiplier);\n    \n    // Concatenate buffers\n    const totalLength = recentBuffers.reduce((sum, buf) => sum + buf.length, 0);\n    const extendedBuffer = new Float32Array(totalLength);\n    \n    let offset = 0;\n    for (const buffer of recentBuffers) {\n      extendedBuffer.set(buffer, offset);\n      offset += buffer.length;\n    }\n    \n    return extendedBuffer;\n  }\n  \n  /**\n   * Clear frame buffer history\n   */\n  clearFrameBufferHistory(): void {\n    this.frameBufferHistory = [];\n  }\n\n  /**\n   * Get frequency-domain data (FFT)\n   * In buffer mode, FFT is computed from time-domain data\n   */\n  getFrequencyData(): Uint8Array | null {\n    // Buffer mode: FFT is not currently supported\n    // Note: FFT could be implemented in the future by computing it from time-domain data\n    // using the same WASM-based FFT that's used for frequency estimation.\n    // This would require integrating with the WaveformDataProcessor's FFT capabilities.\n    // For now, buffer mode focuses on time-domain visualization.\n    if (this.bufferSource && this.dataArray && this.frequencyData) {\n      return null;\n    }\n    \n    // Normal mode: get data from analyser node\n    if (!this.analyser || !this.frequencyData) {\n      return null;\n    }\n    // @ts-ignore - Web Audio API type definitions issue\n    this.analyser.getByteFrequencyData(this.frequencyData);\n    return this.frequencyData;\n  }\n\n  /**\n   * Get sample rate\n   */\n  getSampleRate(): number {\n    if (this.bufferSource) {\n      return this.bufferSource.getSampleRate();\n    }\n    return this.audioContext?.sampleRate || 0;\n  }\n\n  /**\n   * Get FFT size\n   */\n  getFFTSize(): number {\n    if (this.bufferSource) {\n      return 4096; // Fixed FFT size for buffer mode\n    }\n    return this.analyser?.fftSize || 0;\n  }\n\n  /**\n   * Get frequency bin count\n   */\n  getFrequencyBinCount(): number {\n    if (this.bufferSource) {\n      return 2048; // Half of FFT size\n    }\n    return this.analyser?.frequencyBinCount || 0;\n  }\n\n  /**\n   * Check if audio system is ready\n   */\n  isReady(): boolean {\n    // Buffer mode: check if buffer source and data array are ready\n    if (this.bufferSource) {\n      return this.dataArray !== null;\n    }\n    // Normal mode: check if audio context and analyser are ready\n    return this.audioContext !== null && this.analyser !== null;\n  }\n}\n","import { dbToAmplitude } from './utils';\n\n/**\n * GainController - Configuration holder for gain control\n * \n * This class only holds configuration state. All actual gain control\n * and noise gate algorithms are implemented in Rust WASM (wasm-processor module).\n * \n * Responsible for:\n * - Storing auto-gain enabled/disabled state\n * - Storing noise gate enabled/disabled state\n * - Storing noise gate threshold\n * - Holding current gain value (updated by WASM processor)\n */\nexport class GainController {\n  private autoGainEnabled = true;\n  private currentGain = 1.0;\n  \n  private noiseGateEnabled = true;\n  private noiseGateThreshold = dbToAmplitude(-60); // Default threshold (-60dB)\n\n  setAutoGain(enabled: boolean): void {\n    this.autoGainEnabled = enabled;\n  }\n\n  getAutoGainEnabled(): boolean {\n    return this.autoGainEnabled;\n  }\n\n  setNoiseGate(enabled: boolean): void {\n    this.noiseGateEnabled = enabled;\n  }\n\n  getNoiseGateEnabled(): boolean {\n    return this.noiseGateEnabled;\n  }\n\n  setNoiseGateThreshold(threshold: number): void {\n    // Clamp threshold between 0 and 1\n    this.noiseGateThreshold = Math.min(Math.max(threshold, 0), 1);\n  }\n\n  getNoiseGateThreshold(): number {\n    return this.noiseGateThreshold;\n  }\n\n  getCurrentGain(): number {\n    return this.currentGain;\n  }\n}\n","/**\n * FrequencyEstimator - Configuration holder for frequency estimation\n * \n * This class only holds configuration state. All actual frequency estimation\n * algorithms are implemented in Rust WASM (wasm-processor module).\n * \n * Responsible for:\n * - Storing frequency estimation method configuration\n * - Storing buffer size multiplier setting\n * - Holding estimated frequency value (updated by WASM processor)\n * - Holding frequency plot history (updated by WASM processor)\n */\nexport class FrequencyEstimator {\n  private frequencyEstimationMethod: 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt' = 'fft';\n  private estimatedFrequency = 0;\n  private readonly MIN_FREQUENCY_HZ = 20; // Minimum detectable frequency (Hz)\n  private readonly MAX_FREQUENCY_HZ = 5000; // Maximum detectable frequency (Hz)\n  private bufferSizeMultiplier: 1 | 4 | 16 = 16; // Buffer size multiplier for extended FFT\n  private frequencyPlotHistory: number[] = []; // プロット用の推定周波数の履歴\n\n  /**\n   * Clear frequency history (e.g., when stopping)\n   */\n  clearHistory(): void {\n    this.frequencyPlotHistory = [];\n    this.estimatedFrequency = 0;\n  }\n\n  // Getters and setters\n  setFrequencyEstimationMethod(method: 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt'): void {\n    // Only clear frequency history if the method actually changes\n    if (this.frequencyEstimationMethod !== method) {\n      this.frequencyEstimationMethod = method;\n      // Clear frequency history when changing methods\n      this.frequencyPlotHistory = [];\n    }\n  }\n\n  getFrequencyEstimationMethod(): string {\n    return this.frequencyEstimationMethod;\n  }\n\n  setBufferSizeMultiplier(multiplier: 1 | 4 | 16): void {\n    this.bufferSizeMultiplier = multiplier;\n  }\n\n  getBufferSizeMultiplier(): 1 | 4 | 16 {\n    return this.bufferSizeMultiplier;\n  }\n\n  getEstimatedFrequency(): number {\n    return this.estimatedFrequency;\n  }\n\n  getMinFrequency(): number {\n    return this.MIN_FREQUENCY_HZ;\n  }\n\n  getMaxFrequency(): number {\n    return this.MAX_FREQUENCY_HZ;\n  }\n  \n  getFrequencyPlotHistory(): number[] {\n    return this.frequencyPlotHistory;\n  }\n}\n","/**\n * Layout configuration for overlay panels\n * Allows external applications to control the position and size of debug overlays\n */\n\n/**\n * Position configuration for an overlay\n */\nexport interface OverlayPosition {\n  /** X coordinate (in pixels or percentage string like '10%') */\n  x: number | string;\n  /** Y coordinate (in pixels or percentage string like '10%') */\n  y: number | string;\n}\n\n/**\n * Size configuration for an overlay\n */\nexport interface OverlaySize {\n  /** Width (in pixels or percentage string like '35%') */\n  width: number | string;\n  /** Height (in pixels or percentage string like '35%') */\n  height: number | string;\n}\n\n/**\n * Complete layout configuration for an overlay\n */\nexport interface OverlayLayout {\n  position: OverlayPosition;\n  size: OverlaySize;\n}\n\n/**\n * Layout configuration for all overlays\n */\nexport interface OverlaysLayoutConfig {\n  /** FFT spectrum overlay (bottom-left by default) */\n  fftOverlay?: OverlayLayout;\n  /** Harmonic analysis overlay (top-left by default) */\n  harmonicAnalysis?: OverlayLayout;\n  /** Frequency plot overlay (top-right by default) */\n  frequencyPlot?: OverlayLayout;\n}\n\n/**\n * Helper function to resolve position/size value\n * Converts percentage strings to actual pixel values based on canvas dimensions\n * @param value - Value to resolve (number or string)\n * @param canvasSize - Canvas dimension (width or height) in pixels\n * @returns Resolved pixel value\n */\nexport function resolveValue(value: number | string, canvasSize: number): number {\n  if (typeof value === 'string' && value.endsWith('%')) {\n    const percentage = parseFloat(value);\n    // Validate percentage value\n    if (isNaN(percentage)) {\n      console.warn(`Invalid percentage value: ${value}, using 0`);\n      return 0;\n    }\n    if (percentage < 0) {\n      console.warn(`Negative percentage value: ${value}, clamping to 0`);\n      return 0;\n    }\n    return Math.floor(canvasSize * (percentage / 100));\n  }\n  \n  if (typeof value === 'string') {\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed)) {\n      console.warn(`Invalid numeric string: ${value}, using 0`);\n      return 0;\n    }\n    return Math.max(0, parsed); // Clamp negative values to 0\n  }\n  \n  if (typeof value === 'number') {\n    if (isNaN(value)) {\n      console.warn(`Invalid number value: ${value}, using 0`);\n      return 0;\n    }\n    return Math.max(0, Math.floor(value)); // Clamp negative values to 0\n  }\n  \n  return 0;\n}\n\n/**\n * Default layout configuration\n */\nexport const DEFAULT_OVERLAYS_LAYOUT: OverlaysLayoutConfig = {\n  fftOverlay: {\n    position: { x: 10, y: '65%' },\n    size: { width: '35%', height: '35%' }\n  },\n  harmonicAnalysis: {\n    position: { x: 10, y: 10 },\n    size: { width: 500, height: 'auto' }\n  },\n  frequencyPlot: {\n    position: { x: 'right-10', y: 10 },\n    size: { width: 280, height: 120 }\n  }\n};\n","import { amplitudeToDb, frequencyToNote } from './utils';\nimport { OverlaysLayoutConfig, DEFAULT_OVERLAYS_LAYOUT, resolveValue, OverlayLayout } from './OverlayLayout';\n\n/**\n * WaveformRenderer handles all canvas drawing operations\n * Responsible for:\n * - Grid rendering\n * - Waveform visualization\n * - Zero-cross line indicators\n * - FFT spectrum overlay\n * - Canvas coordinate calculations\n */\nexport class WaveformRenderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private fftDisplayEnabled = true;\n  private debugOverlaysEnabled = true; // Control debug overlays (harmonic analysis, frequency plot)\n  private overlaysLayout: OverlaysLayoutConfig; // Layout configuration for overlays\n  private readonly FFT_OVERLAY_HEIGHT_RATIO = 0.9; // Spectrum bar height ratio within overlay (90%)\n  private readonly FFT_MIN_BAR_WIDTH = 1; // Minimum bar width in pixels\n  private readonly FREQ_PLOT_MIN_RANGE_PADDING_HZ = 50; // 周波数範囲の最小パディング (Hz)\n  private readonly FREQ_PLOT_RANGE_PADDING_RATIO = 0.1; // 周波数範囲のパディング比率 (10%)\n\n  constructor(canvas: HTMLCanvasElement, overlaysLayout?: OverlaysLayoutConfig) {\n    this.canvas = canvas;\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get 2D context');\n    }\n    this.ctx = context;\n    this.overlaysLayout = overlaysLayout || DEFAULT_OVERLAYS_LAYOUT;\n  }\n\n  /**\n   * Clear canvas and draw grid with measurement labels\n   * @param sampleRate - Audio sample rate in Hz (optional)\n   * @param displaySamples - Number of samples displayed on screen (optional)\n   * @param gain - Current gain multiplier (optional)\n   */\n  clearAndDrawGrid(sampleRate?: number, displaySamples?: number, gain?: number): void {\n    // Clear canvas\n    this.ctx.fillStyle = '#000000';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Draw grid with labels if measurement data is available\n    this.drawGrid(sampleRate, displaySamples, gain);\n  }\n\n  /**\n   * Draw grid lines with measurement labels\n   * @param sampleRate - Audio sample rate in Hz (optional)\n   * @param displaySamples - Number of samples displayed on screen (optional)\n   * @param gain - Current gain multiplier (optional)\n   */\n  private drawGrid(sampleRate?: number, displaySamples?: number, gain?: number): void {\n    this.ctx.strokeStyle = '#222222';\n    this.ctx.lineWidth = 1;\n    this.ctx.beginPath();\n\n    // Horizontal lines (amplitude divisions)\n    const horizontalLines = 5;\n    for (let i = 0; i <= horizontalLines; i++) {\n      const y = (this.canvas.height / horizontalLines) * i;\n      this.ctx.moveTo(0, y);\n      this.ctx.lineTo(this.canvas.width, y);\n    }\n\n    // Vertical lines (time divisions)\n    const verticalLines = 10;\n    for (let i = 0; i <= verticalLines; i++) {\n      const x = (this.canvas.width / verticalLines) * i;\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.canvas.height);\n    }\n\n    this.ctx.stroke();\n\n    // Center line (zero line)\n    this.ctx.strokeStyle = '#444444';\n    this.ctx.lineWidth = 1;\n    this.ctx.beginPath();\n    this.ctx.moveTo(0, this.canvas.height / 2);\n    this.ctx.lineTo(this.canvas.width, this.canvas.height / 2);\n    this.ctx.stroke();\n\n    // Draw measurement labels if data is available and valid\n    if (sampleRate && sampleRate > 0 && displaySamples && displaySamples > 0 && gain !== undefined && gain > 0) {\n      this.drawGridLabels(sampleRate, displaySamples, gain);\n    }\n  }\n\n  /**\n   * Draw grid measurement labels\n   * @param sampleRate - Audio sample rate in Hz\n   * @param displaySamples - Number of samples displayed on screen\n   * @param gain - Current gain multiplier\n   */\n  private drawGridLabels(sampleRate: number, displaySamples: number, gain: number): void {\n    this.ctx.save();\n    this.ctx.font = '11px monospace';\n    this.ctx.fillStyle = '#666666';\n\n    // Calculate time per division (vertical grid spacing)\n    const displayTimeMs = (displaySamples / sampleRate) * 1000; // Total display time in ms\n    const verticalLines = 10;\n    const timePerDivision = displayTimeMs / verticalLines;\n\n    // Draw time labels at the bottom of the canvas\n    for (let i = 0; i <= verticalLines; i++) {\n      const x = (this.canvas.width / verticalLines) * i;\n      const timeMs = timePerDivision * i;\n      \n      let label: string;\n      if (timeMs >= 1000) {\n        label = `${(timeMs / 1000).toFixed(2)}s`;\n      } else if (timeMs >= 1) {\n        label = `${timeMs.toFixed(1)}ms`;\n      } else {\n        label = `${(timeMs * 1000).toFixed(0)}μs`;\n      }\n      \n      // Draw label at bottom, slightly offset to avoid overlap\n      const textWidth = this.ctx.measureText(label).width;\n      const labelX = Math.max(2, Math.min(x - textWidth / 2, this.canvas.width - textWidth - 2));\n      this.ctx.fillText(label, labelX, this.canvas.height - 3);\n    }\n\n    // Calculate amplitude per division (horizontal grid spacing)\n    // The canvas height represents ±1.0 raw amplitude scaled by gain\n    // Each division from center represents: (canvasHeight/2) / (horizontalLines/2) pixels\n    const horizontalLines = 5;\n    const divisionsFromCenter = horizontalLines / 2; // 2.5 divisions from center to edge\n    const amplitudePerDivision = 1.0 / (divisionsFromCenter * gain); // Raw amplitude per division\n\n    // Draw amplitude labels on the left side (in dB format)\n    for (let i = 0; i <= horizontalLines; i++) {\n      const y = (this.canvas.height / horizontalLines) * i;\n      // Calculate amplitude: center is 0, top is positive, bottom is negative\n      const divisionsFromCenterLine = (horizontalLines / 2) - i;\n      const amplitude = divisionsFromCenterLine * amplitudePerDivision;\n      \n      let label: string;\n      if (amplitude === 0) {\n        // Center line is -Infinity dB in theory, but we show it as a reference\n        label = '0dB*';\n      } else {\n        const db = amplitudeToDb(Math.abs(amplitude));\n        // The sign indicates waveform polarity (top=positive, bottom=negative)\n        // The dB magnitude is calculated from absolute amplitude\n        const sign = amplitude > 0 ? '+' : '-';\n        const absDb = Math.abs(db);\n        if (absDb >= 100) {\n          label = `${sign}${absDb.toFixed(0)}dB`;\n        } else {\n          label = `${sign}${absDb.toFixed(1)}dB`;\n        }\n      }\n      \n      // Draw label on left side with padding\n      this.ctx.fillText(label, 3, y + 10);\n    }\n\n    this.ctx.restore();\n  }\n\n  /**\n   * Draw waveform\n   */\n  drawWaveform(data: Float32Array, startIndex: number, endIndex: number, gain: number): void {\n    const dataLength = endIndex - startIndex;\n    if (dataLength <= 0) return;\n\n    this.ctx.strokeStyle = '#00ff00';\n    this.ctx.lineWidth = 2;\n    this.ctx.beginPath();\n\n    const sliceWidth = this.canvas.width / dataLength;\n    const centerY = this.canvas.height / 2;\n    const baseAmplitude = this.canvas.height / 2;\n    const amplitude = baseAmplitude * gain;\n\n    for (let i = 0; i < dataLength; i++) {\n      const dataIndex = startIndex + i;\n      const value = data[dataIndex];\n      const rawY = centerY - (value * amplitude);\n      const y = Math.min(this.canvas.height, Math.max(0, rawY));\n      const x = i * sliceWidth;\n\n      if (i === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n\n    this.ctx.stroke();\n  }\n\n  /**\n   * Draw FFT spectrum overlay (position and size configurable via overlaysLayout)\n   */\n  drawFFTOverlay(frequencyData: Uint8Array, estimatedFrequency: number, sampleRate: number, fftSize: number, maxFrequency: number): void {\n    if (!this.fftDisplayEnabled) {\n      return;\n    }\n\n    const binFrequency = sampleRate / fftSize;\n\n    // Calculate overlay dimensions using layout config\n    const defaultOverlayWidth = Math.floor(this.canvas.width * 0.35);\n    const defaultOverlayHeight = Math.floor(this.canvas.height * 0.35);\n    const defaultOverlayX = 10;\n    const defaultOverlayY = this.canvas.height - defaultOverlayHeight - 10;\n\n    const { x: overlayX, y: overlayY, width: overlayWidth, height: overlayHeight } = this.calculateOverlayDimensions(\n      this.overlaysLayout.fftOverlay,\n      defaultOverlayX,\n      defaultOverlayY,\n      defaultOverlayWidth,\n      defaultOverlayHeight\n    );\n\n    // Draw semi-transparent background\n    this.ctx.save();\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // Draw border\n    this.ctx.strokeStyle = '#00aaff';\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // Draw spectrum bars (only up to maxFrequency)\n    const maxBin = Math.min(\n      frequencyData.length,\n      Math.ceil(maxFrequency / binFrequency)\n    );\n    const barWidth = overlayWidth / maxBin;\n\n    this.ctx.fillStyle = '#00aaff';\n    for (let i = 0; i < maxBin; i++) {\n      const magnitude = frequencyData[i];\n      const barHeight = (magnitude / 255) * overlayHeight * this.FFT_OVERLAY_HEIGHT_RATIO;\n      const x = overlayX + i * barWidth;\n      const y = overlayY + overlayHeight - barHeight;\n\n      this.ctx.fillRect(x, y, Math.max(barWidth - 1, this.FFT_MIN_BAR_WIDTH), barHeight);\n    }\n\n    // Draw fundamental frequency marker\n    if (estimatedFrequency > 0 && estimatedFrequency <= maxFrequency) {\n      const frequencyBin = estimatedFrequency / binFrequency;\n      const markerX = overlayX + frequencyBin * barWidth;\n\n      this.ctx.strokeStyle = '#ff00ff';\n      this.ctx.lineWidth = 2;\n      this.ctx.beginPath();\n      this.ctx.moveTo(markerX, overlayY);\n      this.ctx.lineTo(markerX, overlayY + overlayHeight);\n      this.ctx.stroke();\n\n      // Draw frequency label\n      this.ctx.fillStyle = '#ff00ff';\n      this.ctx.font = 'bold 12px Arial';\n      const label = `${estimatedFrequency.toFixed(1)} Hz`;\n      const textWidth = this.ctx.measureText(label).width;\n      \n      // Position label to avoid going off canvas\n      let labelX = markerX + 3;\n      if (labelX + textWidth > overlayX + overlayWidth - 5) {\n        labelX = markerX - textWidth - 3;\n      }\n      \n      this.ctx.fillText(label, labelX, overlayY + 15);\n    }\n\n    this.ctx.restore();\n  }\n\n  /**\n   * Draw harmonic analysis information overlay\n   * Displays debugging information about frequency estimation when FFT method is used\n   * Position and size configurable via overlaysLayout\n   */\n  drawHarmonicAnalysis(\n    halfFreqPeakStrengthPercent?: number,\n    candidate1Harmonics?: number[],\n    candidate2Harmonics?: number[],\n    candidate1WeightedScore?: number,\n    candidate2WeightedScore?: number,\n    selectionReason?: string,\n    estimatedFrequency?: number\n  ): void {\n    // Skip if debug overlays are disabled\n    if (!this.debugOverlaysEnabled) {\n      return;\n    }\n    \n    if (!this.fftDisplayEnabled) {\n      return;\n    }\n    \n    // Only display if we have data to show\n    if (halfFreqPeakStrengthPercent === undefined && !candidate1Harmonics && !candidate2Harmonics && !selectionReason) {\n      return;\n    }\n    \n    // Calculate overlay dimensions using layout config\n    const lineHeight = 16;\n    const numLines = 1 + // Title\n                     (halfFreqPeakStrengthPercent !== undefined ? 1 : 0) +\n                     (candidate1Harmonics ? 1 : 0) +\n                     (candidate2Harmonics ? 1 : 0) +\n                     (selectionReason ? 2 : 0); // Selection reason might wrap\n    const defaultOverlayHeight = numLines * lineHeight + 10;\n\n    const { x: overlayX, y: overlayY, width: overlayWidth, height: overlayHeight } = this.calculateOverlayDimensions(\n      this.overlaysLayout.harmonicAnalysis,\n      10,\n      10,\n      500,\n      defaultOverlayHeight\n    );\n\n    let currentY = overlayY;\n    \n    this.ctx.save();\n    \n    // Semi-transparent background\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n    \n    // Border\n    this.ctx.strokeStyle = '#ffaa00';\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n    \n    // Title\n    this.ctx.fillStyle = '#ffaa00';\n    this.ctx.font = 'bold 12px monospace';\n    currentY += 15;\n    this.ctx.fillText('倍音分析 (Harmonic Analysis)', overlayX + 5, currentY);\n    \n    // Half frequency peak strength\n    if (halfFreqPeakStrengthPercent !== undefined && estimatedFrequency) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#00ff00';\n      this.ctx.font = '11px monospace';\n      const halfFreq = estimatedFrequency / 2.0;\n      this.ctx.fillText(\n        `1/2周波数 (${halfFreq.toFixed(1)}Hz) のpeak強度: ${halfFreqPeakStrengthPercent.toFixed(1)}%`,\n        overlayX + 5,\n        currentY\n      );\n    }\n    \n    // Candidate 1 harmonics\n    if (candidate1Harmonics && estimatedFrequency) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#ff00ff';\n      this.ctx.font = '11px monospace';\n      const harmonicsStr = candidate1Harmonics.map((v, i) => `${i+1}x:${v.toFixed(2)}`).join(' ');\n      const weightedStr = candidate1WeightedScore !== undefined ? ` (重み付け: ${candidate1WeightedScore.toFixed(1)})` : '';\n      this.ctx.fillText(\n        `候補1 (${estimatedFrequency.toFixed(1)}Hz) 倍音: ${harmonicsStr}${weightedStr}`,\n        overlayX + 5,\n        currentY\n      );\n    }\n    \n    // Candidate 2 harmonics\n    if (candidate2Harmonics && estimatedFrequency) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#00aaff';\n      this.ctx.font = '11px monospace';\n      const halfFreq = estimatedFrequency / 2.0;\n      const harmonicsStr = candidate2Harmonics.map((v, i) => `${i+1}x:${v.toFixed(2)}`).join(' ');\n      const weightedStr = candidate2WeightedScore !== undefined ? ` (重み付け: ${candidate2WeightedScore.toFixed(1)})` : '';\n      this.ctx.fillText(\n        `候補2 (${halfFreq.toFixed(1)}Hz) 倍音: ${harmonicsStr}${weightedStr}`,\n        overlayX + 5,\n        currentY\n      );\n    }\n    \n    // Selection reason\n    if (selectionReason) {\n      currentY += lineHeight;\n      this.ctx.fillStyle = '#aaaaaa';\n      this.ctx.font = '10px monospace';\n      // Wrap text if too long\n      const maxWidth = overlayWidth - 10;\n      const words = selectionReason.split(' ');\n      let line = '';\n      \n      for (const word of words) {\n        const testLine = line + (line ? ' ' : '') + word;\n        const metrics = this.ctx.measureText(testLine);\n        \n        if (metrics.width > maxWidth && line) {\n          this.ctx.fillText(line, overlayX + 5, currentY);\n          currentY += lineHeight;\n          line = word;\n        } else {\n          line = testLine;\n        }\n      }\n      \n      if (line) {\n        this.ctx.fillText(line, overlayX + 5, currentY);\n      }\n    }\n    \n    this.ctx.restore();\n  }\n\n  /**\n   * Draw frequency plot overlay\n   * Position and size configurable via overlaysLayout\n   * Displays frequency history to detect frequency spikes\n   * One data point is added per frame\n   */\n  drawFrequencyPlot(frequencyHistory: number[], minFrequency: number, maxFrequency: number): void {\n    // Skip if debug overlays are disabled\n    if (!this.debugOverlaysEnabled) {\n      return;\n    }\n    \n    if (!frequencyHistory || frequencyHistory.length === 0) {\n      return;\n    }\n\n    // Calculate overlay dimensions using layout config\n    const { x: overlayX, y: overlayY, width: overlayWidth, height: overlayHeight } = this.calculateOverlayDimensions(\n      this.overlaysLayout.frequencyPlot,\n      this.canvas.width - 280 - 10,\n      10,\n      280,\n      120\n    );\n\n    // Draw semi-transparent background\n    this.ctx.save();\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // Draw border\n    this.ctx.strokeStyle = '#ffaa00';\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);\n\n    // タイトルを描画（フレーム数を含む）\n    this.ctx.fillStyle = '#ffaa00';\n    this.ctx.font = 'bold 12px Arial';\n    this.ctx.fillText(`周波数推移 (${frequencyHistory.length}frame)`, overlayX + 5, overlayY + 15);\n\n    // プロット領域を計算（タイトルと軸ラベルのためのスペースを確保）\n    const plotX = overlayX + 35;\n    const plotY = overlayY + 25;\n    const plotWidth = overlayWidth - 45;\n    const plotHeight = overlayHeight - 45; // X軸ラベル用にスペースを増やす\n\n    // データ内の周波数範囲を検出（ゼロ値を除外）\n    const validFrequencies = frequencyHistory.filter(f => f > 0);\n    if (validFrequencies.length === 0) {\n      this.ctx.restore();\n      return;\n    }\n\n    const dataMin = Math.min(...validFrequencies);\n    const dataMax = Math.max(...validFrequencies);\n    \n    // データ範囲にパディングを追加し、最小/最大周波数制限で制約\n    const rangePadding = (dataMax - dataMin) * this.FREQ_PLOT_RANGE_PADDING_RATIO || this.FREQ_PLOT_MIN_RANGE_PADDING_HZ;\n    const displayMin = Math.max(minFrequency, dataMin - rangePadding);\n    const displayMax = Math.min(maxFrequency, dataMax + rangePadding);\n\n    // グリッド線を描画（実データ範囲に基づく）\n    this.ctx.strokeStyle = '#333333';\n    this.ctx.lineWidth = 1;\n    this.ctx.beginPath();\n    \n    // 水平グリッド線（周波数軸に対応）\n    for (let i = 0; i <= 4; i++) {\n      const y = plotY + (plotHeight / 4) * i;\n      this.ctx.moveTo(plotX, y);\n      this.ctx.lineTo(plotX + plotWidth, y);\n    }\n    \n    // 垂直グリッド線\n    for (let i = 0; i <= 4; i++) {\n      const x = plotX + (plotWidth / 4) * i;\n      this.ctx.moveTo(x, plotY);\n      this.ctx.lineTo(x, plotY + plotHeight);\n    }\n    \n    this.ctx.stroke();\n\n    // Y軸ラベルを描画（周波数値 - 左側）\n    this.ctx.fillStyle = '#aaaaaa';\n    this.ctx.font = '10px monospace';\n    this.ctx.textAlign = 'right';\n    this.ctx.textBaseline = 'middle';\n    \n    for (let i = 0; i <= 4; i++) {\n      const freq = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const label = freq >= 1000 ? `${(freq / 1000).toFixed(1)}k` : `${freq.toFixed(0)}`;\n      this.ctx.fillText(label, plotX - 5, y);\n    }\n\n    // 右Y軸ラベルを描画（cent単位 - 各周波数の最寄り音符からの偏差）\n    this.ctx.fillStyle = '#88ccff';\n    this.ctx.font = '9px monospace';\n    this.ctx.textAlign = 'right';\n    this.ctx.textBaseline = 'middle';\n    \n    for (let i = 0; i <= 4; i++) {\n      const freq = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const noteInfo = frequencyToNote(freq);\n      if (noteInfo) {\n        const centsSign = noteInfo.cents >= 0 ? '+' : '';\n        this.ctx.fillText(`${centsSign}${noteInfo.cents}¢`, plotX + plotWidth - 5, y);\n      }\n    }\n\n    // 周波数プロットの線を描画\n    this.ctx.strokeStyle = '#00ff00';\n    this.ctx.lineWidth = 2;\n    this.ctx.beginPath();\n\n    const xStep = plotWidth / Math.max(frequencyHistory.length - 1, 1);\n    \n    // X軸ラベルのフォント設定を事前に準備\n    const labelInterval = Math.max(1, Math.floor(frequencyHistory.length / 4));\n    \n    // Helper function: 周波数値をY座標に変換\n    const frequencyToY = (freq: number): number => {\n      const clampedFreq = Math.max(displayMin, Math.min(displayMax, freq));\n      const normalizedFreq = (clampedFreq - displayMin) / (displayMax - displayMin);\n      return plotY + plotHeight - (normalizedFreq * plotHeight);\n    };\n    \n    // 線を描画（状態管理が必要なため独立ループ）\n    let hasValidPoint = false;\n    for (let i = 0; i < frequencyHistory.length; i++) {\n      const freq = frequencyHistory[i];\n      const x = plotX + i * xStep;\n      \n      // ゼロ値（無信号）はスキップして描画しない\n      if (freq === 0) {\n        hasValidPoint = false;\n        continue;\n      }\n      \n      const y = frequencyToY(freq);\n      \n      // 線の描画\n      if (!hasValidPoint) {\n        this.ctx.moveTo(x, y);\n        hasValidPoint = true;\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n    \n    this.ctx.stroke();\n    \n    // データポイントマーカーとX軸ラベルを描画（統合ループ）\n    this.ctx.font = '9px monospace';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'top';\n    \n    for (let i = 0; i < frequencyHistory.length; i++) {\n      const freq = frequencyHistory[i];\n      const x = plotX + i * xStep;\n      \n      // データポイントマーカーを描画（周波数値が0でない場合）\n      if (freq !== 0) {\n        const y = frequencyToY(freq);\n        \n        this.ctx.fillStyle = '#00ff00';\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, 2, 0, Math.PI * 2);\n        this.ctx.fill();\n      }\n      \n      // X軸ラベルを描画（labelIntervalごと、または最新フレーム）\n      const isLatestFrame = i === frequencyHistory.length - 1;\n      const shouldDrawLabel = (i % labelInterval === 0) || isLatestFrame;\n      \n      if (shouldDrawLabel) {\n        this.ctx.fillStyle = '#aaaaaa';\n        // 最新のフレームからの相対位置を表示（例：-50, -25, 0）\n        const frameOffset = i - frequencyHistory.length + 1;\n        this.ctx.fillText(`${frameOffset}`, x, plotY + plotHeight + 2);\n      }\n    }\n\n    // 現在の周波数値とcent偏差を描画 (inside plot area at bottom)\n    const currentFreq = frequencyHistory[frequencyHistory.length - 1];\n    if (currentFreq > 0) {\n      const noteInfo = frequencyToNote(currentFreq);\n      this.ctx.fillStyle = '#00ff00';\n      this.ctx.font = 'bold 11px Arial';\n      this.ctx.textAlign = 'left';\n      this.ctx.textBaseline = 'bottom';\n      \n      let displayText = `${currentFreq.toFixed(1)} Hz`;\n      if (noteInfo) {\n        const centsSign = noteInfo.cents >= 0 ? '+' : '';\n        displayText += ` (${noteInfo.noteName} ${centsSign}${noteInfo.cents}¢)`;\n      }\n      this.ctx.fillText(displayText, plotX + 2, plotY + plotHeight - 2);\n    }\n\n    this.ctx.restore();\n  }\n\n  /**\n   * Draw phase markers on the waveform\n   * @param phaseZeroIndex - Sample index for phase 0 (red line)\n   * @param phaseTwoPiIndex - Sample index for phase 2π (red line)\n   * @param phaseMinusQuarterPiIndex - Sample index for phase -π/4 (orange line)\n   * @param phaseTwoPiPlusQuarterPiIndex - Sample index for phase 2π+π/4 (orange line)\n   * @param displayStartIndex - Start index of the displayed region\n   * @param displayEndIndex - End index of the displayed region\n   */\n  drawPhaseMarkers(\n    phaseZeroIndex?: number,\n    phaseTwoPiIndex?: number,\n    phaseMinusQuarterPiIndex?: number,\n    phaseTwoPiPlusQuarterPiIndex?: number,\n    displayStartIndex?: number,\n    displayEndIndex?: number\n  ): void {\n    if (displayStartIndex === undefined || displayEndIndex === undefined) {\n      return;\n    }\n\n    const displayLength = displayEndIndex - displayStartIndex;\n    if (displayLength <= 0) {\n      return;\n    }\n\n    this.ctx.save();\n\n    // Helper function to draw a vertical line at a given sample index\n    const drawVerticalLine = (sampleIndex: number, color: string, lineWidth: number) => {\n      // Convert sample index to canvas x coordinate\n      const relativeIndex = sampleIndex - displayStartIndex;\n      if (relativeIndex < 0 || relativeIndex >= displayLength) {\n        return; // Index is outside the displayed region\n      }\n\n      const x = (relativeIndex / displayLength) * this.canvas.width;\n\n      this.ctx.strokeStyle = color;\n      this.ctx.lineWidth = lineWidth;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x, 0);\n      this.ctx.lineTo(x, this.canvas.height);\n      this.ctx.stroke();\n    };\n\n    // Draw orange lines first (so red lines appear on top)\n    if (phaseMinusQuarterPiIndex !== undefined) {\n      drawVerticalLine(phaseMinusQuarterPiIndex, '#ff8800', 2);\n    }\n\n    if (phaseTwoPiPlusQuarterPiIndex !== undefined) {\n      drawVerticalLine(phaseTwoPiPlusQuarterPiIndex, '#ff8800', 2);\n    }\n\n    // Draw red lines\n    if (phaseZeroIndex !== undefined) {\n      drawVerticalLine(phaseZeroIndex, '#ff0000', 2);\n    }\n\n    if (phaseTwoPiIndex !== undefined) {\n      drawVerticalLine(phaseTwoPiIndex, '#ff0000', 2);\n    }\n\n    this.ctx.restore();\n  }\n\n\n  // Getters and setters\n  setFFTDisplay(enabled: boolean): void {\n    this.fftDisplayEnabled = enabled;\n  }\n\n  getFFTDisplayEnabled(): boolean {\n    return this.fftDisplayEnabled;\n  }\n\n  /**\n   * Enable or disable debug overlays (harmonic analysis, frequency plot)\n   * When disabled, yellow-bordered debug information panels are hidden\n   * Recommended: Set to false when using as a library for cleaner display\n   * @param enabled - true to show debug overlays, false to hide them\n   */\n  setDebugOverlaysEnabled(enabled: boolean): void {\n    this.debugOverlaysEnabled = enabled;\n  }\n\n  /**\n   * Get the current state of debug overlays\n   * @returns true if debug overlays are enabled, false otherwise\n   */\n  getDebugOverlaysEnabled(): boolean {\n    return this.debugOverlaysEnabled;\n  }\n\n  /**\n   * Set the layout configuration for overlays\n   * Allows external applications to control the position and size of debug overlays\n   * @param layout - Layout configuration for overlays\n   */\n  setOverlaysLayout(layout: OverlaysLayoutConfig): void {\n    this.overlaysLayout = { ...this.overlaysLayout, ...layout };\n  }\n\n  /**\n   * Get the current overlays layout configuration\n   * @returns Current overlays layout configuration\n   */\n  getOverlaysLayout(): OverlaysLayoutConfig {\n    return this.overlaysLayout;\n  }\n\n  /**\n   * Helper method to calculate overlay dimensions based on layout config\n   */\n  private calculateOverlayDimensions(layout: OverlayLayout | undefined, defaultX: number, defaultY: number, defaultWidth: number, defaultHeight: number): { x: number; y: number; width: number; height: number } {\n    if (!layout) {\n      return { x: defaultX, y: defaultY, width: defaultWidth, height: defaultHeight };\n    }\n\n    let x = defaultX;\n    let y = defaultY;\n    let width = defaultWidth;\n    let height = defaultHeight;\n\n    // Resolve X position\n    if (layout.position.x !== undefined) {\n      if (typeof layout.position.x === 'string' && layout.position.x.startsWith('right-')) {\n        const offset = parseInt(layout.position.x.substring(6), 10);\n        const resolvedWidth = typeof layout.size.width === 'string' && layout.size.width.endsWith('%')\n          ? resolveValue(layout.size.width, this.canvas.width)\n          : (typeof layout.size.width === 'number' ? layout.size.width : defaultWidth);\n        x = this.canvas.width - resolvedWidth - offset;\n      } else {\n        x = resolveValue(layout.position.x, this.canvas.width);\n      }\n    }\n\n    // Resolve Y position\n    if (layout.position.y !== undefined) {\n      y = resolveValue(layout.position.y, this.canvas.height);\n    }\n\n    // Resolve width\n    if (layout.size.width !== undefined && layout.size.width !== 'auto') {\n      width = resolveValue(layout.size.width, this.canvas.width);\n    }\n\n    // Resolve height\n    if (layout.size.height !== undefined && layout.size.height !== 'auto') {\n      height = resolveValue(layout.size.height, this.canvas.height);\n    }\n\n    return { x, y, width, height };\n  }\n}\n","/**\n * ZeroCrossDetector - Configuration holder for zero-cross/peak detection\n * \n * This class only holds configuration state. All actual zero-crossing and peak\n * detection algorithms are implemented in Rust WASM (wasm-processor module).\n * \n * Responsible for:\n * - Storing peak mode configuration (legacy compatibility)\n */\nexport class ZeroCrossDetector {\n  private usePeakMode: boolean = false;\n\n  /**\n   * Set whether to use peak mode instead of zero-crossing mode\n   */\n  setUsePeakMode(enabled: boolean): void {\n    this.usePeakMode = enabled;\n  }\n\n  /**\n   * Get whether peak mode is enabled\n   */\n  getUsePeakMode(): boolean {\n    return this.usePeakMode;\n  }\n\n  /**\n   * Reset state (e.g., when stopping)\n   */\n  reset(): void {\n    // State is maintained in WASM, but this method is kept for API compatibility\n  }\n}\n","/**\n * Constants for waveform storage and search\n */\n\n/** Store 4 cycles worth of waveform data */\nexport const CYCLES_TO_STORE = 4;\n\n/** Search within 4 cycles range */\nexport const CYCLES_TO_SEARCH = 4;\n\n/**\n * WaveformSearcher - Configuration and state holder for waveform similarity search\n * \n * This class only holds state. All actual waveform similarity search\n * algorithms are implemented in Rust WASM (wasm-processor module).\n * \n * Responsible for:\n * - Holding previous waveform data (updated by WASM processor)\n * - Holding last similarity score (updated by WASM processor)\n */\nexport class WaveformSearcher {\n  private previousWaveform: Float32Array | null = null;\n  private lastSimilarity: number = 0;\n\n  /**\n   * Get the last calculated similarity score\n   */\n  getLastSimilarity(): number {\n    return this.lastSimilarity;\n  }\n\n  /**\n   * Reset state (e.g., when stopping)\n   */\n  reset(): void {\n    this.previousWaveform = null;\n    this.lastSimilarity = 0;\n  }\n\n  /**\n   * Check if previous waveform exists\n   */\n  hasPreviousWaveform(): boolean {\n    return this.previousWaveform !== null;\n  }\n\n  /**\n   * Get the previous waveform (for debugging/visualization)\n   */\n  getPreviousWaveform(): Float32Array | null {\n    return this.previousWaveform;\n  }\n}\n","/**\n * ComparisonPanelRenderer handles rendering of the comparison panels\n * Responsible for:\n * - Drawing previous waveform\n * - Drawing current waveform with similarity score\n * - Drawing similarity history plot\n * - Drawing full frame buffer with position indicators\n */\nexport class ComparisonPanelRenderer {\n  private previousCanvas: HTMLCanvasElement;\n  private currentCanvas: HTMLCanvasElement;\n  private similarityCanvas: HTMLCanvasElement;\n  private bufferCanvas: HTMLCanvasElement;\n  private previousCtx: CanvasRenderingContext2D;\n  private currentCtx: CanvasRenderingContext2D;\n  private similarityCtx: CanvasRenderingContext2D;\n  private bufferCtx: CanvasRenderingContext2D;\n  \n  // Auto-scaling constants\n  private readonly TARGET_FILL_RATIO = 0.9;    // Target 90% of distance from center to edge (canvas half-height) for auto-scaled waveforms\n  private readonly MIN_PEAK_THRESHOLD = 0.001; // Minimum peak to trigger auto-scaling (below this uses default)\n  private readonly DEFAULT_AMPLITUDE_RATIO = 0.4; // Default scaling factor when peak is too small\n\n  constructor(\n    previousCanvas: HTMLCanvasElement,\n    currentCanvas: HTMLCanvasElement,\n    similarityCanvas: HTMLCanvasElement,\n    bufferCanvas: HTMLCanvasElement\n  ) {\n    this.previousCanvas = previousCanvas;\n    this.currentCanvas = currentCanvas;\n    this.similarityCanvas = similarityCanvas;\n    this.bufferCanvas = bufferCanvas;\n\n    const prevCtx = previousCanvas.getContext('2d');\n    const currCtx = currentCanvas.getContext('2d');\n    const simCtx = similarityCanvas.getContext('2d');\n    const buffCtx = bufferCanvas.getContext('2d');\n\n    if (!prevCtx || !currCtx || !simCtx || !buffCtx) {\n      throw new Error('Could not get 2D context for comparison canvases');\n    }\n\n    this.previousCtx = prevCtx;\n    this.currentCtx = currCtx;\n    this.similarityCtx = simCtx;\n    this.bufferCtx = buffCtx;\n\n    // Initialize all canvases\n    this.clearAllCanvases();\n  }\n\n  /**\n   * Clear all comparison canvases\n   */\n  private clearAllCanvases(): void {\n    this.clearCanvas(this.previousCtx, this.previousCanvas.width, this.previousCanvas.height);\n    this.clearCanvas(this.currentCtx, this.currentCanvas.width, this.currentCanvas.height);\n    this.clearCanvas(this.similarityCtx, this.similarityCanvas.width, this.similarityCanvas.height);\n    this.clearCanvas(this.bufferCtx, this.bufferCanvas.width, this.bufferCanvas.height);\n  }\n\n  /**\n   * Clear a single canvas\n   */\n  private clearCanvas(ctx: CanvasRenderingContext2D, width: number, height: number): void {\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, width, height);\n  }\n\n  /**\n   * Calculate peak amplitude in a given range of data\n   * Used for auto-scaling waveforms to fill the vertical space\n   */\n  private findPeakAmplitude(\n    data: Float32Array,\n    startIndex: number,\n    endIndex: number\n  ): number {\n    let peak = 0;\n    const clampedStart = Math.max(0, startIndex);\n    const clampedEnd = Math.min(data.length, endIndex);\n\n    for (let i = clampedStart; i < clampedEnd; i++) {\n      const value = Math.abs(data[i]);\n      if (value > peak) {\n        peak = value;\n      }\n    }\n\n    return peak;\n  }\n\n  /**\n   * Draw a waveform on a canvas with auto-scaling\n   * Waveforms are automatically scaled so that peaks reach 90% of the distance\n   * from the vertical center line to the top/bottom edge (i.e. 90% of half the height).\n   * For example, if peak amplitude is 0.01, it will be scaled 90x relative to that center-to-edge range.\n   */\n  private drawWaveform(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    data: Float32Array,\n    startIndex: number,\n    endIndex: number,\n    color: string\n  ): void {\n    const dataLength = endIndex - startIndex;\n    if (dataLength <= 0) return;\n\n    // Find peak amplitude for auto-scaling\n    const peak = this.findPeakAmplitude(data, startIndex, endIndex);\n    \n    ctx.strokeStyle = color;\n    ctx.lineWidth = 1.5;\n    ctx.beginPath();\n\n    const sliceWidth = width / dataLength;\n    const centerY = height / 2;\n    \n    // Auto-scale so peaks reach 90% of distance from center to edge (90% of half-height)\n    // If peak is 0 or very small (< MIN_PEAK_THRESHOLD), use default scaling to avoid division by zero\n    let amplitude: number;\n    \n    if (peak > this.MIN_PEAK_THRESHOLD) {\n      // Calculate scaling factor so peak reaches TARGET_FILL_RATIO of the distance from center to edge\n      const scalingFactor = this.TARGET_FILL_RATIO / peak;\n      amplitude = (height / 2) * scalingFactor;\n    } else {\n      // For very small or zero signals, use default scaling\n      amplitude = height * this.DEFAULT_AMPLITUDE_RATIO;\n    }\n\n    for (let i = 0; i < dataLength; i++) {\n      const dataIndex = startIndex + i;\n      if (dataIndex >= data.length) break;\n      \n      const value = data[dataIndex];\n      const rawY = centerY - (value * amplitude);\n      const y = Math.min(height, Math.max(0, rawY));\n      const x = i * sliceWidth;\n\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    ctx.stroke();\n  }\n\n  /**\n   * Draw center line on canvas\n   */\n  private drawCenterLine(ctx: CanvasRenderingContext2D, width: number, height: number): void {\n    ctx.strokeStyle = '#444444';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(0, height / 2);\n    ctx.lineTo(width, height / 2);\n    ctx.stroke();\n  }\n\n  /**\n   * Draw similarity score text\n   */\n  private drawSimilarityText(similarity: number): void {\n    this.currentCtx.fillStyle = '#00aaff';\n    this.currentCtx.font = 'bold 14px Arial';\n    const text = `Similarity: ${similarity.toFixed(3)}`;\n    const textWidth = this.currentCtx.measureText(text).width;\n    const x = (this.currentCanvas.width - textWidth) / 2;\n    this.currentCtx.fillText(text, x, 20);\n  }\n\n  /**\n   * Draw similarity history plot on similarity canvas\n   * 類似度の時系列変化を表示し、瞬間的な類似度低下を検出しやすくする\n   * \n   * @param similarityHistory Array of correlation coefficients (-1.0 to 1.0).\n   *                          Values are ordered chronologically from oldest to newest.\n   */\n  private drawSimilarityPlot(similarityHistory: number[]): void {\n    if (!similarityHistory || similarityHistory.length === 0) {\n      return;\n    }\n\n    const ctx = this.similarityCtx;\n    const width = this.similarityCanvas.width;\n    const height = this.similarityCanvas.height;\n\n    // Clear and draw background\n    ctx.save();\n    ctx.fillStyle = '#000000';\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw border\n    ctx.strokeStyle = '#00aaff';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, 0, width, height);\n\n    // Title\n    ctx.fillStyle = '#00aaff';\n    ctx.font = 'bold 12px Arial';\n    ctx.fillText('類似度推移 (Similarity)', 5, 15);\n\n    // Calculate plot area (reserve space for title and axis labels)\n    const plotX = 40;\n    const plotY = 25;\n    const plotWidth = width - 50;\n    const plotHeight = height - 35;\n\n    // Similarity range is -1.0 to 1.0 (correlation coefficient range)\n    const displayMin = -1.0;\n    const displayMax = 1.0;\n\n    // Draw grid lines\n    ctx.strokeStyle = '#333333';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    \n    // Horizontal grid lines (corresponding to similarity axis)\n    for (let i = 0; i <= 4; i++) {\n      const y = plotY + (plotHeight / 4) * i;\n      ctx.moveTo(plotX, y);\n      ctx.lineTo(plotX + plotWidth, y);\n    }\n    \n    // Vertical grid lines\n    for (let i = 0; i <= 4; i++) {\n      const x = plotX + (plotWidth / 4) * i;\n      ctx.moveTo(x, plotY);\n      ctx.lineTo(x, plotY + plotHeight);\n    }\n    \n    ctx.stroke();\n\n    // Draw Y-axis labels (similarity values)\n    ctx.fillStyle = '#aaaaaa';\n    ctx.font = '10px monospace';\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'middle';\n    \n    for (let i = 0; i <= 4; i++) {\n      const similarity = displayMax - (displayMax - displayMin) * (i / 4);\n      const y = plotY + (plotHeight / 4) * i;\n      const label = similarity.toFixed(2);\n      ctx.fillText(label, plotX - 5, y);\n    }\n\n    // Draw similarity plot line\n    ctx.strokeStyle = '#00aaff';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n\n    const xStep = plotWidth / Math.max(similarityHistory.length - 1, 1);\n    \n    for (let i = 0; i < similarityHistory.length; i++) {\n      const similarity = similarityHistory[i];\n      const x = plotX + i * xStep;\n      \n      // Clamp similarity to display range\n      const clampedSimilarity = Math.max(displayMin, Math.min(displayMax, similarity));\n      \n      // Map similarity to Y coordinate (inverted: high similarity = top)\n      const normalizedSimilarity = (clampedSimilarity - displayMin) / (displayMax - displayMin);\n      const y = plotY + plotHeight - (normalizedSimilarity * plotHeight);\n      \n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n    \n    ctx.stroke();\n\n    // Draw current similarity value (inside plot area at bottom left)\n    const currentSimilarity = similarityHistory[similarityHistory.length - 1];\n    ctx.fillStyle = '#00aaff';\n    ctx.font = 'bold 11px Arial';\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'bottom';\n    ctx.fillText(`${currentSimilarity.toFixed(3)}`, plotX + 2, plotY + plotHeight - 2);\n\n    ctx.restore();\n  }\n\n  /**\n   * Draw vertical position markers\n   */\n  private drawPositionMarkers(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    startIndex: number,\n    endIndex: number,\n    totalLength: number\n  ): void {\n    if (totalLength <= 0) return;\n\n    // Calculate x positions for start and end markers\n    const startX = (startIndex / totalLength) * width;\n    const endX = (endIndex / totalLength) * width;\n\n    // Draw start marker (red line)\n    ctx.strokeStyle = '#ff0000';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(startX, 0);\n    ctx.lineTo(startX, height);\n    ctx.stroke();\n\n    // Draw end marker (red line)\n    ctx.beginPath();\n    ctx.moveTo(endX, 0);\n    ctx.lineTo(endX, height);\n    ctx.stroke();\n\n    // Draw labels\n    ctx.fillStyle = '#ff0000';\n    ctx.font = '10px Arial';\n    ctx.fillText('S', startX + 2, 12);\n    ctx.fillText('E', endX + 2, 12);\n  }\n\n  /**\n   * Update all comparison panels\n   * @param previousWaveform - Previous frame's waveform data (null if no previous frame exists)\n   * @param currentWaveform - Full buffer containing current frame's audio data\n   * @param currentStart - Start index of the extracted waveform within currentWaveform\n   * @param currentEnd - End index of the extracted waveform within currentWaveform (exclusive)\n   * @param fullBuffer - Complete frame buffer to display (typically same as currentWaveform)\n   * @param similarity - Correlation coefficient between current and previous waveform (-1 to +1)\n   * @param similarityHistory - Array of similarity values over time for history plot\n   */\n  updatePanels(\n    previousWaveform: Float32Array | null,\n    currentWaveform: Float32Array,\n    currentStart: number,\n    currentEnd: number,\n    fullBuffer: Float32Array,\n    similarity: number,\n    similarityHistory: number[] = []\n  ): void {\n    // Clear all canvases\n    this.clearAllCanvases();\n\n    // Draw previous waveform\n    if (previousWaveform) {\n      this.drawCenterLine(this.previousCtx, this.previousCanvas.width, this.previousCanvas.height);\n      this.drawWaveform(\n        this.previousCtx,\n        this.previousCanvas.width,\n        this.previousCanvas.height,\n        previousWaveform,\n        0,\n        previousWaveform.length,\n        '#ffaa00'\n      );\n    }\n\n    // Draw current waveform with similarity score\n    this.drawCenterLine(this.currentCtx, this.currentCanvas.width, this.currentCanvas.height);\n    const currentLength = currentEnd - currentStart;\n    if (currentLength > 0) {\n      this.drawWaveform(\n        this.currentCtx,\n        this.currentCanvas.width,\n        this.currentCanvas.height,\n        currentWaveform,\n        currentStart,\n        currentEnd,\n        '#00ff00'\n      );\n    }\n    if (previousWaveform) {\n      this.drawSimilarityText(similarity);\n    }\n\n    // Draw similarity plot\n    if (similarityHistory.length > 0) {\n      this.drawSimilarityPlot(similarityHistory);\n    }\n\n    // Draw full frame buffer with position markers\n    this.drawCenterLine(this.bufferCtx, this.bufferCanvas.width, this.bufferCanvas.height);\n    this.drawWaveform(\n      this.bufferCtx,\n      this.bufferCanvas.width,\n      this.bufferCanvas.height,\n      fullBuffer,\n      0,\n      fullBuffer.length,\n      '#888888'\n    );\n    this.drawPositionMarkers(\n      this.bufferCtx,\n      this.bufferCanvas.width,\n      this.bufferCanvas.height,\n      currentStart,\n      currentEnd,\n      fullBuffer.length\n    );\n  }\n\n  /**\n   * Clear all panels (e.g., when stopped)\n   */\n  clear(): void {\n    this.clearAllCanvases();\n  }\n}\n","import { WaveformRenderData } from './WaveformRenderData';\nimport { AudioManager } from './AudioManager';\nimport { GainController } from './GainController';\nimport { FrequencyEstimator } from './FrequencyEstimator';\nimport { WaveformSearcher } from './WaveformSearcher';\n\n// Type definition for WASM processor instance\ninterface WasmProcessorInstance {\n  setAutoGain(enabled: boolean): void;\n  setNoiseGate(enabled: boolean): void;\n  setNoiseGateThreshold(threshold: number): void;\n  setFrequencyEstimationMethod(method: string): void;\n  setBufferSizeMultiplier(multiplier: number): void;\n  setUsePeakMode(enabled: boolean): void;\n  reset(): void;\n  processFrame(\n    waveformData: Float32Array,\n    frequencyData: Uint8Array | null,\n    sampleRate: number,\n    fftSize: number,\n    fftDisplayEnabled: boolean\n  ): any;\n}\n\n/**\n * WaveformDataProcessor - Processes waveform data using Rust WASM implementation\n * \n * This class coordinates between JavaScript configuration and the Rust/WASM \n * implementation for data processing. It maintains TypeScript instances only \n * for configuration and state that needs to be accessed from JS.\n * \n * All actual data processing algorithms (frequency estimation, gain control,\n * zero-cross detection, waveform search) are implemented in Rust WASM.\n */\nexport class WaveformDataProcessor {\n  // Asset directory patterns used for base path detection\n  private static readonly ASSET_PATTERNS = ['/assets/', '/js/', '/dist/'] as const;\n  \n  private audioManager: AudioManager;\n  private gainController: GainController;\n  private frequencyEstimator: FrequencyEstimator;\n  private waveformSearcher: WaveformSearcher;\n\n  private wasmProcessor: WasmProcessorInstance | null = null;\n  private isInitialized = false;\n  private cachedBasePath: string | null = null;\n\n  constructor(\n    audioManager: AudioManager,\n    gainController: GainController,\n    frequencyEstimator: FrequencyEstimator,\n    waveformSearcher: WaveformSearcher\n  ) {\n    this.audioManager = audioManager;\n    this.gainController = gainController;\n    this.frequencyEstimator = frequencyEstimator;\n    this.waveformSearcher = waveformSearcher;\n  }\n  \n  /**\n   * Initialize the WASM module\n   * Must be called before processFrame\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n    \n    // Check if we're in a test or non-browser-like environment\n    if (typeof window === 'undefined' || window.location.protocol === 'file:') {\n      throw new Error('WASM module not available in test/non-browser environment');\n    }\n    \n    try {\n      // Load WASM module using script tag injection (works around Vite restrictions)\n      await this.loadWasmModule();\n      this.isInitialized = true;\n      \n      // Sync initial configuration to WASM\n      this.syncConfigToWasm();\n    } catch (error) {\n      console.error('Failed to initialize WASM module:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Load WASM module dynamically\n   */\n  private async loadWasmModule(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Check if already loaded\n      // @ts-ignore\n      if (window.wasmProcessor && window.wasmProcessor.WasmDataProcessor) {\n        // @ts-ignore\n        this.wasmProcessor = new window.wasmProcessor.WasmDataProcessor();\n        resolve();\n        return;\n      }\n      \n      // Set up timeout to prevent hanging\n      const timeout = setTimeout(() => {\n        cleanup();\n        reject(new Error('WASM module loading timed out after 10 seconds'));\n      }, 10000);\n      \n      // Determine the base path for WASM files\n      const basePath = this.determineBasePath();\n      const wasmPath = `${basePath}wasm/wasm_processor.js`;\n      \n      const script = document.createElement('script');\n      script.type = 'module';\n      script.textContent = `\n        import init, { WasmDataProcessor } from '${wasmPath}';\n        await init();\n        window.wasmProcessor = { WasmDataProcessor };\n        window.dispatchEvent(new Event('wasmLoaded'));\n      `;\n      \n      const cleanup = () => {\n        clearTimeout(timeout);\n        window.removeEventListener('wasmLoaded', handleLoad);\n      };\n      \n      const handleLoad = () => {\n        cleanup();\n        // @ts-ignore\n        if (window.wasmProcessor && window.wasmProcessor.WasmDataProcessor) {\n          // @ts-ignore\n          this.wasmProcessor = new window.wasmProcessor.WasmDataProcessor();\n          resolve();\n        } else {\n          reject(new Error('WASM module loaded but WasmDataProcessor not found'));\n        }\n      };\n      \n      window.addEventListener('wasmLoaded', handleLoad);\n      \n      script.onerror = () => {\n        cleanup();\n        reject(new Error('Failed to load WASM module script'));\n      };\n      \n      document.head.appendChild(script);\n    });\n  }\n  \n  /**\n   * Determine the base path for the application\n   * This method implements a fallback hierarchy:\n   * 1. Check for <base> tag href attribute\n   * 2. Extract from existing script tags\n   * 3. Check if running in Vite dev mode (import.meta.env.DEV)\n   * 4. Default to '/'\n   * The path is normalized to always end with '/'\n   */\n  private determineBasePath(): string {\n    // Return cached value if available\n    if (this.cachedBasePath !== null) {\n      return this.cachedBasePath;\n    }\n    \n    // Try <base> tag first\n    let basePath = document.querySelector('base')?.getAttribute('href');\n\n    // If we got a value from <base>, normalize absolute URLs to pathname only\n    if (basePath) {\n      try {\n        const url = new URL(basePath, window.location.href);\n        basePath = url.pathname;\n      } catch {\n        // If parsing fails, keep the original value (likely already a relative path)\n      }\n    }\n    \n    // Fall back to script tag analysis\n    if (!basePath) {\n      basePath = this.getBasePathFromScripts();\n    }\n    \n    // Check if running in Vite dev mode (window.location.pathname contains the base)\n    if (!basePath && window.location.pathname && window.location.pathname !== '/') {\n      // In dev mode, Vite may serve from a base path like /cat-oscilloscope or /cat-oscilloscope/\n      // Extract the first path segment robustly (handles /cat-oscilloscope, /cat-oscilloscope/, /cat-oscilloscope/page, etc.)\n      const pathname = window.location.pathname;\n      const segments = pathname.split('/').filter((segment) => segment.length > 0);\n      if (segments.length > 0) {\n        basePath = `/${segments[0]}/`;\n      }\n    }\n    \n    // Default to root\n    if (!basePath) {\n      basePath = '/';\n    }\n    \n    // Normalize: ensure trailing slash\n    if (!basePath.endsWith('/')) {\n      basePath += '/';\n    }\n    \n    // Cache the result\n    this.cachedBasePath = basePath;\n    return basePath;\n  }\n  \n  /**\n   * Extract base path from existing script tags\n   * This method attempts to infer the base path by looking for script tags with src attributes\n   * that might indicate the deployment path. Falls back to empty string if no clear pattern is found.\n   */\n  private getBasePathFromScripts(): string {\n    const scripts = document.querySelectorAll('script[src]');\n    for (const script of scripts) {\n      const src = script.getAttribute('src');\n      if (src) {\n        try {\n          // Try to parse as URL to handle both absolute and relative paths\n          const url = new URL(src, window.location.href);\n          const pathname = url.pathname;\n          \n          // Look for common asset directory patterns\n          for (const pattern of WaveformDataProcessor.ASSET_PATTERNS) {\n            const index = pathname.indexOf(pattern);\n            if (index >= 0) {\n              // Extract everything before the asset directory\n              // For '/assets/file.js', index=0, return '/' (root directory)\n              // For '/cat-oscilloscope/assets/file.js', index=17, return '/cat-oscilloscope/'\n              return index === 0 ? '/' : pathname.substring(0, index) + '/';\n            }\n          }\n        } catch (error: unknown) {\n          // URL parsing failed - skip this script and try next one\n          if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {\n            console.debug('Failed to parse script URL:', src, error);\n          }\n          continue;\n        }\n      }\n    }\n    return '';\n  }\n  \n  /**\n   * Sync TypeScript configuration to WASM processor\n   */\n  private syncConfigToWasm(): void {\n    if (!this.wasmProcessor) return;\n    \n    this.wasmProcessor.setAutoGain(this.gainController.getAutoGainEnabled());\n    this.wasmProcessor.setNoiseGate(this.gainController.getNoiseGateEnabled());\n    this.wasmProcessor.setNoiseGateThreshold(this.gainController.getNoiseGateThreshold());\n    this.wasmProcessor.setFrequencyEstimationMethod(this.frequencyEstimator.getFrequencyEstimationMethod());\n    this.wasmProcessor.setBufferSizeMultiplier(this.frequencyEstimator.getBufferSizeMultiplier());\n  }\n  \n  /**\n   * Sync WASM results back to TypeScript objects\n   * \n   * Note: This method accesses private members using type assertions.\n   * This is a temporary solution to maintain compatibility with existing code\n   * that uses getters like getEstimatedFrequency(), getCurrentGain(), etc.\n   * \n   * TODO: Consider adding public setter methods to these classes or\n   * redesigning the synchronization interface for better type safety.\n   */\n  private syncResultsFromWasm(renderData: WaveformRenderData): void {\n    // Update frequency estimator's estimated frequency\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.frequencyEstimator as any).estimatedFrequency = renderData.estimatedFrequency;\n    \n    // Update gain controller's current gain\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.gainController as any).currentGain = renderData.gain;\n    \n    // Update waveform searcher's state\n    if (renderData.previousWaveform) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.waveformSearcher as any).previousWaveform = renderData.previousWaveform;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.waveformSearcher as any).lastSimilarity = renderData.similarity;\n  }\n\n  /**\n   * Process current frame and generate complete render data using WASM\n   */\n  processFrame(fftDisplayEnabled: boolean): WaveformRenderData | null {\n    if (!this.isInitialized || !this.wasmProcessor) {\n      console.warn('WASM processor not initialized');\n      return null;\n    }\n    \n    // Check if audio is ready\n    if (!this.audioManager.isReady()) {\n      return null;\n    }\n\n    // Get waveform data\n    const dataArray = this.audioManager.getTimeDomainData();\n    if (!dataArray) {\n      return null;\n    }\n    \n    const sampleRate = this.audioManager.getSampleRate();\n    const fftSize = this.audioManager.getFFTSize();\n    \n    // Get frequency data if needed\n    const needsFrequencyData = this.frequencyEstimator.getFrequencyEstimationMethod() === 'fft' || fftDisplayEnabled;\n    const frequencyData = needsFrequencyData ? this.audioManager.getFrequencyData() : null;\n    \n    // Sync configuration before processing\n    this.syncConfigToWasm();\n    \n    // Call WASM processor\n    const wasmResult = this.wasmProcessor.processFrame(\n      dataArray,\n      frequencyData,\n      sampleRate,\n      fftSize,\n      fftDisplayEnabled\n    );\n    \n    if (!wasmResult) {\n      return null;\n    }\n    \n    // Convert WASM result to TypeScript WaveformRenderData\n    const renderData: WaveformRenderData = {\n      waveformData: new Float32Array(wasmResult.waveform_data),\n      displayStartIndex: wasmResult.displayStartIndex,\n      displayEndIndex: wasmResult.displayEndIndex,\n      gain: wasmResult.gain,\n      estimatedFrequency: wasmResult.estimatedFrequency,\n      frequencyPlotHistory: wasmResult.frequencyPlotHistory ? Array.from(wasmResult.frequencyPlotHistory) : [],\n      sampleRate: wasmResult.sampleRate,\n      fftSize: wasmResult.fftSize,\n      frequencyData: wasmResult.frequencyData ? new Uint8Array(wasmResult.frequencyData) : undefined,\n      isSignalAboveNoiseGate: wasmResult.isSignalAboveNoiseGate,\n      maxFrequency: wasmResult.maxFrequency,\n      previousWaveform: wasmResult.previousWaveform ? new Float32Array(wasmResult.previousWaveform) : null,\n      similarity: wasmResult.similarity,\n      similarityPlotHistory: wasmResult.similarityPlotHistory ? Array.from(wasmResult.similarityPlotHistory) : [],\n      usedSimilaritySearch: wasmResult.usedSimilaritySearch,\n      phaseZeroIndex: wasmResult.phaseZeroIndex,\n      phaseTwoPiIndex: wasmResult.phaseTwoPiIndex,\n      phaseMinusQuarterPiIndex: wasmResult.phaseMinusQuarterPiIndex,\n      phaseTwoPiPlusQuarterPiIndex: wasmResult.phaseTwoPiPlusQuarterPiIndex,\n      halfFreqPeakStrengthPercent: wasmResult.halfFreqPeakStrengthPercent,\n      candidate1Harmonics: wasmResult.candidate1Harmonics ? Array.from(wasmResult.candidate1Harmonics) : undefined,\n      candidate2Harmonics: wasmResult.candidate2Harmonics ? Array.from(wasmResult.candidate2Harmonics) : undefined,\n      selectionReason: wasmResult.selectionReason,\n    };\n    \n    // Sync results back to TypeScript objects so getters work correctly\n    this.syncResultsFromWasm(renderData);\n    \n    return renderData;\n  }\n  \n  /**\n   * Reset the WASM processor state\n   */\n  reset(): void {\n    if (this.wasmProcessor) {\n      this.wasmProcessor.reset();\n    }\n  }\n}\n","import { AudioManager } from './AudioManager';\nimport { GainController } from './GainController';\nimport { FrequencyEstimator } from './FrequencyEstimator';\nimport { WaveformRenderer } from './WaveformRenderer';\nimport { ZeroCrossDetector } from './ZeroCrossDetector';\nimport { WaveformSearcher } from './WaveformSearcher';\nimport { ComparisonPanelRenderer } from './ComparisonPanelRenderer';\nimport { WaveformDataProcessor } from './WaveformDataProcessor';\nimport { WaveformRenderData } from './WaveformRenderData';\nimport { BufferSource } from './BufferSource';\nimport { OverlaysLayoutConfig } from './OverlayLayout';\n\n/**\n * Oscilloscope class - Main coordinator for the oscilloscope functionality\n * Delegates responsibilities to specialized modules:\n * - AudioManager: Web Audio API integration\n * - GainController: Auto-gain and noise gate configuration\n * - FrequencyEstimator: Frequency detection configuration\n * - WaveformRenderer: Canvas rendering\n * - ZeroCrossDetector: Zero-crossing detection configuration\n * - WaveformSearcher: Waveform similarity search state\n * - ComparisonPanelRenderer: Comparison panel rendering\n * - WaveformDataProcessor: Data generation and processing (Rust WASM implementation)\n */\nexport class Oscilloscope {\n  private audioManager: AudioManager;\n  private gainController: GainController;\n  private frequencyEstimator: FrequencyEstimator;\n  private renderer: WaveformRenderer;\n  private zeroCrossDetector: ZeroCrossDetector;\n  private waveformSearcher: WaveformSearcher;\n  private comparisonRenderer: ComparisonPanelRenderer;\n  private dataProcessor: WaveformDataProcessor;\n  private animationId: number | null = null;\n  private isRunning = false;\n  private isPaused = false;\n\n  // Frame processing diagnostics\n  private lastFrameTime = 0;\n  private frameProcessingTimes: number[] = [];\n  private readonly MAX_FRAME_TIMES = 100;\n  private readonly TARGET_FRAME_TIME = 16.67; // 60fps target\n  private readonly FPS_LOG_INTERVAL_FRAMES = 60; // Log FPS every 60 frames (approx. 1 second at 60fps)\n\n  /**\n   * Create a new Oscilloscope instance\n   * @param canvas - Main oscilloscope display canvas (recommended: 800x350px)\n   * @param previousWaveformCanvas - Canvas for displaying previous frame's waveform (recommended: 250x120px)\n   * @param currentWaveformCanvas - Canvas for displaying current frame's waveform (recommended: 250x120px)\n   * @param similarityPlotCanvas - Canvas for displaying similarity history plot (recommended: 250x120px)\n   * @param frameBufferCanvas - Canvas for displaying full frame buffer with position markers (recommended: 800x120px)\n   * @param overlaysLayout - Optional layout configuration for debug overlays (FFT, harmonic analysis, frequency plot)\n   */\n  constructor(\n    canvas: HTMLCanvasElement,\n    previousWaveformCanvas: HTMLCanvasElement,\n    currentWaveformCanvas: HTMLCanvasElement,\n    similarityPlotCanvas: HTMLCanvasElement,\n    frameBufferCanvas: HTMLCanvasElement,\n    overlaysLayout?: OverlaysLayoutConfig\n  ) {\n    this.audioManager = new AudioManager();\n    this.gainController = new GainController();\n    this.frequencyEstimator = new FrequencyEstimator();\n    this.renderer = new WaveformRenderer(canvas, overlaysLayout);\n    this.zeroCrossDetector = new ZeroCrossDetector();\n    this.waveformSearcher = new WaveformSearcher();\n    this.comparisonRenderer = new ComparisonPanelRenderer(\n      previousWaveformCanvas,\n      currentWaveformCanvas,\n      similarityPlotCanvas,\n      frameBufferCanvas\n    );\n    this.dataProcessor = new WaveformDataProcessor(\n      this.audioManager,\n      this.gainController,\n      this.frequencyEstimator,\n      this.waveformSearcher\n    );\n  }\n\n  async start(): Promise<void> {\n    try {\n      // Initialize WASM processor if not already initialized\n      await this.dataProcessor.initialize();\n      \n      await this.audioManager.start();\n      this.isRunning = true;\n      this.render();\n    } catch (error) {\n      console.error('Error starting oscilloscope:', error);\n      throw error;\n    }\n  }\n\n  async startFromFile(file: File): Promise<void> {\n    try {\n      // Initialize WASM processor if not already initialized\n      await this.dataProcessor.initialize();\n      \n      await this.audioManager.startFromFile(file);\n      this.isRunning = true;\n      this.render();\n    } catch (error) {\n      console.error('Error loading audio file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start visualization from a static buffer without audio playback\n   * Useful for visualizing pre-recorded audio data or processing results\n   * @param bufferSource - BufferSource instance containing audio data\n   */\n  async startFromBuffer(bufferSource: BufferSource): Promise<void> {\n    try {\n      // Initialize WASM processor if not already initialized\n      await this.dataProcessor.initialize();\n      \n      await this.audioManager.startFromBuffer(bufferSource);\n      this.isRunning = true;\n      this.render();\n    } catch (error) {\n      console.error('Error starting from buffer:', error);\n      throw error;\n    }\n  }\n\n  async stop(): Promise<void> {\n    this.isRunning = false;\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n    await this.audioManager.stop();\n    this.frequencyEstimator.clearHistory();\n    this.zeroCrossDetector.reset();\n    this.waveformSearcher.reset();\n    this.comparisonRenderer.clear();\n    this.dataProcessor.reset();\n  }\n\n  private render(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    const startTime = performance.now();\n\n    // If paused, skip processing and drawing but continue the animation loop\n    if (!this.isPaused) {\n      // === DATA GENERATION PHASE ===\n      // Process frame and generate all data needed for rendering using WASM processor\n      const renderData = this.dataProcessor.processFrame(this.renderer.getFFTDisplayEnabled());\n      \n      if (renderData) {\n        // === RENDERING PHASE ===\n        // All rendering logic uses only the generated data\n        this.renderFrame(renderData);\n      }\n    }\n\n    // Measure frame processing time\n    const endTime = performance.now();\n    const processingTime = endTime - startTime;\n    this.frameProcessingTimes.push(processingTime);\n    if (this.frameProcessingTimes.length > this.MAX_FRAME_TIMES) {\n      this.frameProcessingTimes.shift();\n    }\n\n    // Warn if frame processing exceeds target (60fps)\n    if (processingTime > this.TARGET_FRAME_TIME) {\n      console.warn(`Frame processing time: ${processingTime.toFixed(2)}ms (target: <${this.TARGET_FRAME_TIME}ms)`);\n    }\n\n    // Calculate and log FPS periodically (every FPS_LOG_INTERVAL_FRAMES frames)\n    if (this.lastFrameTime > 0) {\n      const frameInterval = startTime - this.lastFrameTime;\n      const currentFps = 1000 / frameInterval;\n      \n      if (this.frameProcessingTimes.length === this.FPS_LOG_INTERVAL_FRAMES) {\n        const avgProcessingTime = this.frameProcessingTimes.reduce((a, b) => a + b, 0) / this.frameProcessingTimes.length;\n        console.log(`FPS: ${currentFps.toFixed(1)}, Avg frame time: ${avgProcessingTime.toFixed(2)}ms`);\n      }\n    }\n    this.lastFrameTime = startTime;\n\n    // Continue rendering\n    this.animationId = requestAnimationFrame(() => this.render());\n  }\n\n  /**\n   * Render a single frame using pre-processed data\n   * This method contains only rendering logic - no data processing\n   */\n  private renderFrame(renderData: WaveformRenderData): void {\n    // Clear canvas and draw grid with measurement labels\n    const displaySamples = renderData.displayEndIndex - renderData.displayStartIndex;\n    this.renderer.clearAndDrawGrid(\n      renderData.sampleRate,\n      displaySamples,\n      renderData.gain\n    );\n\n    // Draw waveform with calculated gain\n    this.renderer.drawWaveform(\n      renderData.waveformData,\n      renderData.displayStartIndex,\n      renderData.displayEndIndex,\n      renderData.gain\n    );\n\n    // Draw phase markers\n    this.renderer.drawPhaseMarkers(\n      renderData.phaseZeroIndex,\n      renderData.phaseTwoPiIndex,\n      renderData.phaseMinusQuarterPiIndex,\n      renderData.phaseTwoPiPlusQuarterPiIndex,\n      renderData.displayStartIndex,\n      renderData.displayEndIndex\n    );\n\n    // Draw FFT spectrum overlay if enabled and signal is above noise gate\n    if (renderData.frequencyData && this.renderer.getFFTDisplayEnabled() && renderData.isSignalAboveNoiseGate) {\n      this.renderer.drawFFTOverlay(\n        renderData.frequencyData,\n        renderData.estimatedFrequency,\n        renderData.sampleRate,\n        renderData.fftSize,\n        renderData.maxFrequency\n      );\n      \n      // Draw harmonic analysis overlay (only when FFT method is used and data is available)\n      this.renderer.drawHarmonicAnalysis(\n        renderData.halfFreqPeakStrengthPercent,\n        renderData.candidate1Harmonics,\n        renderData.candidate2Harmonics,\n        renderData.candidate1WeightedScore,\n        renderData.candidate2WeightedScore,\n        renderData.selectionReason,\n        renderData.estimatedFrequency\n      );\n    }\n\n    // 右上に周波数プロットを描画\n    this.renderer.drawFrequencyPlot(\n      renderData.frequencyPlotHistory,\n      this.frequencyEstimator.getMinFrequency(),\n      this.frequencyEstimator.getMaxFrequency()\n    );\n\n    // Update comparison panels with similarity history\n    this.comparisonRenderer.updatePanels(\n      renderData.previousWaveform,\n      renderData.waveformData,\n      renderData.displayStartIndex,\n      renderData.displayEndIndex,\n      renderData.waveformData,\n      renderData.similarity,\n      renderData.similarityPlotHistory\n    );\n  }\n\n  // Getters and setters - delegate to appropriate modules\n  getIsRunning(): boolean {\n    return this.isRunning;\n  }\n\n  setAutoGain(enabled: boolean): void {\n    this.gainController.setAutoGain(enabled);\n  }\n\n  getAutoGainEnabled(): boolean {\n    return this.gainController.getAutoGainEnabled();\n  }\n\n  setNoiseGate(enabled: boolean): void {\n    this.gainController.setNoiseGate(enabled);\n  }\n\n  getNoiseGateEnabled(): boolean {\n    return this.gainController.getNoiseGateEnabled();\n  }\n\n  setNoiseGateThreshold(threshold: number): void {\n    this.gainController.setNoiseGateThreshold(threshold);\n  }\n\n  getNoiseGateThreshold(): number {\n    return this.gainController.getNoiseGateThreshold();\n  }\n\n  setFrequencyEstimationMethod(method: 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt'): void {\n    this.frequencyEstimator.setFrequencyEstimationMethod(method);\n  }\n\n  getFrequencyEstimationMethod(): string {\n    return this.frequencyEstimator.getFrequencyEstimationMethod();\n  }\n\n  setBufferSizeMultiplier(multiplier: 1 | 4 | 16): void {\n    this.frequencyEstimator.setBufferSizeMultiplier(multiplier);\n  }\n\n  getBufferSizeMultiplier(): 1 | 4 | 16 {\n    return this.frequencyEstimator.getBufferSizeMultiplier();\n  }\n\n  getEstimatedFrequency(): number {\n    return this.frequencyEstimator.getEstimatedFrequency();\n  }\n\n  setFFTDisplay(enabled: boolean): void {\n    this.renderer.setFFTDisplay(enabled);\n  }\n\n  getFFTDisplayEnabled(): boolean {\n    return this.renderer.getFFTDisplayEnabled();\n  }\n\n  /**\n   * Enable or disable debug overlays (harmonic analysis, frequency plot)\n   * Debug overlays show detailed debugging information with yellow borders (#ffaa00)\n   * including harmonic analysis and frequency history plot\n   * \n   * When using cat-oscilloscope as a library, it's recommended to disable these\n   * overlays for a cleaner, more professional appearance\n   * \n   * @param enabled - true to show debug overlays (default for standalone app),\n   *                  false to hide them (recommended for library usage)\n   */\n  setDebugOverlaysEnabled(enabled: boolean): void {\n    this.renderer.setDebugOverlaysEnabled(enabled);\n  }\n\n  /**\n   * Get the current state of debug overlays\n   * @returns true if debug overlays are enabled, false otherwise\n   */\n  getDebugOverlaysEnabled(): boolean {\n    return this.renderer.getDebugOverlaysEnabled();\n  }\n\n  /**\n   * Set the layout configuration for overlays\n   * Allows external applications to control the position and size of debug overlays\n   * @param layout - Layout configuration for overlays (FFT, harmonic analysis, frequency plot)\n   */\n  setOverlaysLayout(layout: OverlaysLayoutConfig): void {\n    this.renderer.setOverlaysLayout(layout);\n  }\n\n  /**\n   * Get the current overlays layout configuration\n   * @returns Current overlays layout configuration\n   */\n  getOverlaysLayout(): OverlaysLayoutConfig {\n    return this.renderer.getOverlaysLayout();\n  }\n\n  getCurrentGain(): number {\n    return this.gainController.getCurrentGain();\n  }\n  \n  getSimilarityScore(): number {\n    return this.waveformSearcher.getLastSimilarity();\n  }\n  \n  isSimilaritySearchActive(): boolean {\n    return this.waveformSearcher.hasPreviousWaveform();\n  }\n  \n  setUsePeakMode(enabled: boolean): void {\n    this.zeroCrossDetector.setUsePeakMode(enabled);\n  }\n\n  getUsePeakMode(): boolean {\n    return this.zeroCrossDetector.getUsePeakMode();\n  }\n  \n  setPauseDrawing(paused: boolean): void {\n    this.isPaused = paused;\n  }\n\n  getPauseDrawing(): boolean {\n    return this.isPaused;\n  }\n}\n","import { frequencyToNote } from './utils';\n\n/**\n * PianoKeyboardRenderer handles rendering of piano keyboard visualization\n * Displays a piano keyboard for the frequency range 50Hz - 2000Hz\n * Highlights the key corresponding to the fundamental frequency\n */\nexport class PianoKeyboardRenderer {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  \n  // 周波数範囲 (50Hz～2000Hz)\n  private readonly MIN_FREQ = 50;\n  private readonly MAX_FREQ = 2000;\n  \n  // ピアノ鍵盤の定数\n  private readonly WHITE_KEY_WIDTH = 20;\n  private readonly WHITE_KEY_HEIGHT = 60;\n  private readonly BLACK_KEY_WIDTH = 12;\n  private readonly BLACK_KEY_HEIGHT = 38;\n  \n  // 色定義\n  private readonly WHITE_KEY_COLOR = '#ffffff';\n  private readonly BLACK_KEY_COLOR = '#000000';\n  private readonly WHITE_KEY_HIGHLIGHT = '#00ff00';\n  private readonly BLACK_KEY_HIGHLIGHT = '#00cc00';\n  private readonly KEY_BORDER = '#333333';\n  \n  // 音名パターン定数（配列アロケーションを避けるため）\n  // 白鍵: C(0), D(2), E(4), F(5), G(7), A(9), B(11)\n  private readonly WHITE_KEY_NOTES = [0, 2, 4, 5, 7, 9, 11];\n  // 黒鍵: C#(1), D#(3), F#(6), G#(8), A#(10)\n  private readonly BLACK_KEY_NOTES = [1, 3, 6, 8, 10];\n  \n  // キャッシュされた鍵盤範囲（コンストラクタで一度だけ計算）\n  private readonly keyboardRange: { startNote: number; endNote: number };\n  \n  // センタリング用のオフセット（コンストラクタで一度だけ計算）\n  private readonly xOffset: number;\n  \n  // 白鍵の総数（コンストラクタで一度だけ計算）\n  private readonly whiteKeyCount: number;\n  \n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get 2D context for piano keyboard');\n    }\n    this.ctx = context;\n    \n    // 鍵盤範囲を一度だけ計算してキャッシュ\n    this.keyboardRange = this.calculateKeyboardRange();\n    \n    // 白鍵の数を計算してキャッシュ\n    this.whiteKeyCount = this.countWhiteKeys();\n    \n    // センタリング用のオフセットを計算\n    this.xOffset = this.calculateCenteringOffset();\n  }\n  \n  /**\n   * 周波数から音名情報を取得\n   * utils.tsのfrequencyToNote関数を使用し、内部形式に変換\n   */\n  private frequencyToNoteInfo(frequency: number): { note: number; octave: number; noteInOctave: number } {\n    const noteInfo = frequencyToNote(frequency);\n    \n    if (!noteInfo) {\n      return { note: -1, octave: -1, noteInOctave: -1 };\n    }\n    \n    // noteName (e.g., \"A4\", \"C#3\") から音名とオクターブを抽出\n    const matches = noteInfo.noteName.match(/^([A-G]#?)(\\d+)$/);\n    if (!matches) {\n      return { note: -1, octave: -1, noteInOctave: -1 };\n    }\n    \n    const noteName = matches[1];\n    const octave = parseInt(matches[2], 10);\n    \n    // 音名から noteInOctave (0-11) を計算\n    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const noteInOctave = noteNames.indexOf(noteName);\n    \n    // noteIndex を計算 (C0 = 0)\n    const note = octave * 12 + noteInOctave;\n    \n    return { note, octave, noteInOctave };\n  }\n  \n  /**\n   * 表示する鍵盤の範囲を計算\n   * MIN_FREQからMAX_FREQまでの範囲をカバーする\n   */\n  private calculateKeyboardRange(): { startNote: number; endNote: number } {\n    const startNoteInfo = this.frequencyToNoteInfo(this.MIN_FREQ);\n    const endNoteInfo = this.frequencyToNoteInfo(this.MAX_FREQ);\n    \n    return {\n      startNote: startNoteInfo.note,\n      endNote: endNoteInfo.note\n    };\n  }\n  \n  /**\n   * 白鍵の数をカウント\n   */\n  private countWhiteKeys(): number {\n    const range = this.keyboardRange;\n    let count = 0;\n    for (let note = range.startNote; note <= range.endNote; note++) {\n      const noteInOctave = ((note % 12) + 12) % 12;\n      if (this.WHITE_KEY_NOTES.includes(noteInOctave)) {\n        count++;\n      }\n    }\n    return count;\n  }\n  \n  /**\n   * 鍵盤をセンタリングするためのX座標オフセットを計算\n   */\n  private calculateCenteringOffset(): number {\n    // 鍵盤全体の幅\n    const totalKeyboardWidth = this.whiteKeyCount * this.WHITE_KEY_WIDTH;\n    \n    // センタリング用のオフセット\n    return (this.canvas.width - totalKeyboardWidth) / 2;\n  }\n  \n  /**\n   * ピアノ鍵盤を描画\n   * @param highlightFrequency - ハイライトする周波数 (0の場合はハイライトなし)\n   */\n  render(highlightFrequency: number): void {\n    // キャンバスをクリア\n    this.ctx.fillStyle = '#1a1a1a';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    const range = this.keyboardRange;\n    \n    // ハイライトする音名を計算\n    const highlightNoteInfo = highlightFrequency > 0 ? this.frequencyToNoteInfo(highlightFrequency) : null;\n    \n    // 白鍵を描画\n    let whiteKeyIndex = 0;\n    for (let note = range.startNote; note <= range.endNote; note++) {\n      const noteInOctave = ((note % 12) + 12) % 12;\n      \n      // 白鍵の場合\n      if (this.WHITE_KEY_NOTES.includes(noteInOctave)) {\n        const x = this.xOffset + whiteKeyIndex * this.WHITE_KEY_WIDTH;\n        const isHighlighted = highlightNoteInfo && highlightNoteInfo.note === note;\n        \n        this.ctx.fillStyle = isHighlighted ? this.WHITE_KEY_HIGHLIGHT : this.WHITE_KEY_COLOR;\n        this.ctx.fillRect(x, 0, this.WHITE_KEY_WIDTH, this.WHITE_KEY_HEIGHT);\n        \n        this.ctx.strokeStyle = this.KEY_BORDER;\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x, 0, this.WHITE_KEY_WIDTH, this.WHITE_KEY_HEIGHT);\n        \n        whiteKeyIndex++;\n      }\n    }\n    \n    // 黒鍵を描画（白鍵の上に重ねて描画）\n    whiteKeyIndex = 0;\n    for (let note = range.startNote; note <= range.endNote; note++) {\n      const noteInOctave = ((note % 12) + 12) % 12;\n      \n      // 白鍵の位置をカウント\n      if (this.WHITE_KEY_NOTES.includes(noteInOctave)) {\n        whiteKeyIndex++;\n      }\n      \n      // 黒鍵の場合\n      if (this.BLACK_KEY_NOTES.includes(noteInOctave)) {\n        // 黒鍵は直前の白鍵の右端に配置\n        const x = this.xOffset + whiteKeyIndex * this.WHITE_KEY_WIDTH - this.BLACK_KEY_WIDTH / 2;\n        const isHighlighted = highlightNoteInfo && highlightNoteInfo.note === note;\n        \n        this.ctx.fillStyle = isHighlighted ? this.BLACK_KEY_HIGHLIGHT : this.BLACK_KEY_COLOR;\n        this.ctx.fillRect(x, 0, this.BLACK_KEY_WIDTH, this.BLACK_KEY_HEIGHT);\n        \n        this.ctx.strokeStyle = this.KEY_BORDER;\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x, 0, this.BLACK_KEY_WIDTH, this.BLACK_KEY_HEIGHT);\n      }\n    }\n    \n    // 周波数範囲を表示\n    this.ctx.fillStyle = '#888888';\n    this.ctx.font = '10px monospace';\n    this.ctx.fillText(`${this.MIN_FREQ}Hz`, this.xOffset + 5, this.WHITE_KEY_HEIGHT - 5);\n    \n    // 右端の周波数表示の位置を計算\n    const text = `${this.MAX_FREQ}Hz`;\n    const textWidth = this.ctx.measureText(text).width;\n    const rightEdge = this.xOffset + this.whiteKeyCount * this.WHITE_KEY_WIDTH;\n    this.ctx.fillText(text, rightEdge - textWidth - 5, this.WHITE_KEY_HEIGHT - 5);\n  }\n  \n  /**\n   * キャンバスをクリア\n   */\n  clear(): void {\n    this.ctx.fillStyle = '#1a1a1a';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n","import { Oscilloscope } from './Oscilloscope';\nimport { dbToAmplitude, frequencyToNote } from './utils';\nimport { PianoKeyboardRenderer } from './PianoKeyboardRenderer';\n\n// Main application logic\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst previousWaveformCanvas = document.getElementById('previousWaveformCanvas') as HTMLCanvasElement;\nconst currentWaveformCanvas = document.getElementById('currentWaveformCanvas') as HTMLCanvasElement;\nconst similarityPlotCanvas = document.getElementById('similarityPlotCanvas') as HTMLCanvasElement;\nconst frameBufferCanvas = document.getElementById('frameBufferCanvas') as HTMLCanvasElement;\nconst pianoKeyboardCanvas = document.getElementById('pianoKeyboardCanvas') as HTMLCanvasElement;\nconst startButton = document.getElementById('startButton') as HTMLButtonElement;\nconst loadFileButton = document.getElementById('loadFileButton') as HTMLButtonElement;\nconst fileInput = document.getElementById('fileInput') as HTMLInputElement;\nconst autoGainCheckbox = document.getElementById('autoGainCheckbox') as HTMLInputElement;\nconst noiseGateCheckbox = document.getElementById('noiseGateCheckbox') as HTMLInputElement;\nconst fftDisplayCheckbox = document.getElementById('fftDisplayCheckbox') as HTMLInputElement;\nconst pauseDrawingCheckbox = document.getElementById('pauseDrawingCheckbox') as HTMLInputElement;\nconst noiseGateThreshold = document.getElementById('noiseGateThreshold') as HTMLInputElement;\nconst thresholdValue = document.getElementById('thresholdValue') as HTMLSpanElement;\nconst statusElement = document.getElementById('status') as HTMLSpanElement;\nconst frequencyMethod = document.getElementById('frequencyMethod') as HTMLSelectElement;\nconst bufferSizeMultiplier = document.getElementById('bufferSizeMultiplier') as HTMLSelectElement;\nconst frequencyValue = document.getElementById('frequencyValue') as HTMLSpanElement;\nconst noteValue = document.getElementById('noteValue') as HTMLSpanElement;\nconst gainValue = document.getElementById('gainValue') as HTMLSpanElement;\nconst similarityValue = document.getElementById('similarityValue') as HTMLSpanElement;\n\n// Validate all required DOM elements\nconst requiredElements = [\n  { element: canvas, name: 'canvas' },\n  { element: previousWaveformCanvas, name: 'previousWaveformCanvas' },\n  { element: currentWaveformCanvas, name: 'currentWaveformCanvas' },\n  { element: similarityPlotCanvas, name: 'similarityPlotCanvas' },\n  { element: frameBufferCanvas, name: 'frameBufferCanvas' },\n  { element: pianoKeyboardCanvas, name: 'pianoKeyboardCanvas' },\n  { element: startButton, name: 'startButton' },\n  { element: loadFileButton, name: 'loadFileButton' },\n  { element: fileInput, name: 'fileInput' },\n  { element: autoGainCheckbox, name: 'autoGainCheckbox' },\n  { element: noiseGateCheckbox, name: 'noiseGateCheckbox' },\n  { element: fftDisplayCheckbox, name: 'fftDisplayCheckbox' },\n  { element: pauseDrawingCheckbox, name: 'pauseDrawingCheckbox' },\n  { element: noiseGateThreshold, name: 'noiseGateThreshold' },\n  { element: thresholdValue, name: 'thresholdValue' },\n  { element: statusElement, name: 'status' },\n  { element: frequencyMethod, name: 'frequencyMethod' },\n  { element: bufferSizeMultiplier, name: 'bufferSizeMultiplier' },\n  { element: frequencyValue, name: 'frequencyValue' },\n  { element: noteValue, name: 'noteValue' },\n  { element: gainValue, name: 'gainValue' },\n  { element: similarityValue, name: 'similarityValue' },\n];\n\nfor (const { element, name } of requiredElements) {\n  if (!element) {\n    throw new Error(`Required DOM element not found: ${name}`);\n  }\n}\n\n// Helper function to convert slider value (-60 to 0) to threshold amplitude (0.001-1.00)\n// Returns both dB and amplitude to avoid redundant parsing\nfunction sliderValueToThreshold(sliderValue: string): { db: number; amplitude: number } {\n  const db = parseFloat(sliderValue);\n  \n  if (Number.isNaN(db)) {\n    throw new Error(`Invalid slider value for noise gate threshold: \"${sliderValue}\"`);\n  }\n  \n  return { db, amplitude: dbToAmplitude(db) };\n}\n\n// Helper function to format threshold display\nfunction formatThresholdDisplay(db: number, amplitude: number): string {\n  return `${db.toFixed(0)} dB (${amplitude.toFixed(3)})`;\n}\n\nconst oscilloscope = new Oscilloscope(canvas, previousWaveformCanvas, currentWaveformCanvas, similarityPlotCanvas, frameBufferCanvas);\nconst pianoKeyboardRenderer = new PianoKeyboardRenderer(pianoKeyboardCanvas);\n\n// 初期状態で空の鍵盤を描画\npianoKeyboardRenderer.render(0);\n\n// Startボタンに初期focusを設定（spaceキーで即座に起動可能にする）\nstartButton.focus();\n\n// Synchronize checkbox state with oscilloscope's autoGainEnabled\noscilloscope.setAutoGain(autoGainCheckbox.checked);\n\n// Synchronize noise gate controls\noscilloscope.setNoiseGate(noiseGateCheckbox.checked);\nconst initialThreshold = sliderValueToThreshold(noiseGateThreshold.value);\noscilloscope.setNoiseGateThreshold(initialThreshold.amplitude);\nthresholdValue.textContent = formatThresholdDisplay(initialThreshold.db, initialThreshold.amplitude);\n\n// Synchronize FFT display control\noscilloscope.setFFTDisplay(fftDisplayCheckbox.checked);\n\n// Synchronize pause drawing control\noscilloscope.setPauseDrawing(pauseDrawingCheckbox.checked);\n\n// Auto gain checkbox handler\nautoGainCheckbox.addEventListener('change', () => {\n  oscilloscope.setAutoGain(autoGainCheckbox.checked);\n});\n\n// Noise gate checkbox handler\nnoiseGateCheckbox.addEventListener('change', () => {\n  oscilloscope.setNoiseGate(noiseGateCheckbox.checked);\n});\n\n// FFT display checkbox handler\nfftDisplayCheckbox.addEventListener('change', () => {\n  oscilloscope.setFFTDisplay(fftDisplayCheckbox.checked);\n});\n\n// Pause drawing checkbox handler\npauseDrawingCheckbox.addEventListener('change', () => {\n  oscilloscope.setPauseDrawing(pauseDrawingCheckbox.checked);\n});\n\n// Noise gate threshold slider handler\nnoiseGateThreshold.addEventListener('input', () => {\n  const threshold = sliderValueToThreshold(noiseGateThreshold.value);\n  oscilloscope.setNoiseGateThreshold(threshold.amplitude);\n  thresholdValue.textContent = formatThresholdDisplay(threshold.db, threshold.amplitude);\n});\n\n// Frequency estimation method selector handler\nfrequencyMethod.addEventListener('change', () => {\n  const method = frequencyMethod.value as 'zero-crossing' | 'autocorrelation' | 'fft' | 'stft' | 'cqt';\n  oscilloscope.setFrequencyEstimationMethod(method);\n});\n\n// Buffer size multiplier selector handler\nbufferSizeMultiplier.addEventListener('change', () => {\n  const value = parseInt(bufferSizeMultiplier.value, 10);\n  if (value === 1 || value === 4 || value === 16) {\n    oscilloscope.setBufferSizeMultiplier(value);\n  } else {\n    console.error('Invalid buffer size multiplier:', value);\n    // Reset to default\n    bufferSizeMultiplier.value = '1';\n    oscilloscope.setBufferSizeMultiplier(1);\n  }\n});\n\n// Update frequency display periodically\nlet frequencyUpdateInterval: number | null = null;\n\nfunction startFrequencyDisplay(): void {\n  if (frequencyUpdateInterval === null) {\n    frequencyUpdateInterval = window.setInterval(() => {\n      const frequency = oscilloscope.getEstimatedFrequency();\n      if (frequency > 0) {\n        frequencyValue.textContent = `${frequency.toFixed(1)} Hz`;\n        \n        // Update note display\n        const noteInfo = frequencyToNote(frequency);\n        if (noteInfo) {\n          const centsSign = noteInfo.cents >= 0 ? '+' : '';\n          noteValue.textContent = `${noteInfo.noteName}${centsSign}${noteInfo.cents}cent`;\n        } else {\n          noteValue.textContent = '---';\n        }\n        \n        // Update piano keyboard\n        pianoKeyboardRenderer.render(frequency);\n      } else {\n        frequencyValue.textContent = '--- Hz';\n        noteValue.textContent = '---';\n        pianoKeyboardRenderer.render(0);\n      }\n      \n      // Update gain display\n      const gain = oscilloscope.getCurrentGain();\n      gainValue.textContent = `${gain.toFixed(2)}x`;\n      \n      // Update similarity display - show value if similarity search is active\n      if (oscilloscope.isSimilaritySearchActive()) {\n        const similarity = oscilloscope.getSimilarityScore();\n        similarityValue.textContent = similarity.toFixed(3);\n      } else {\n        similarityValue.textContent = '---';\n      }\n    }, 100); // Update every 100ms (10 Hz)\n  }\n}\n\nfunction stopFrequencyDisplay(): void {\n  if (frequencyUpdateInterval !== null) {\n    clearInterval(frequencyUpdateInterval);\n    frequencyUpdateInterval = null;\n    frequencyValue.textContent = '--- Hz';\n    noteValue.textContent = '---';\n    gainValue.textContent = '---x';\n    similarityValue.textContent = '---';\n    pianoKeyboardRenderer.clear();\n  }\n}\n\nstartButton.addEventListener('click', async () => {\n  if (!oscilloscope.getIsRunning()) {\n    try {\n      startButton.disabled = true;\n      loadFileButton.disabled = true;\n      statusElement.textContent = 'Requesting microphone access...';\n      \n      await oscilloscope.start();\n      \n      startButton.textContent = 'Stop';\n      startButton.disabled = false;\n      statusElement.textContent = 'Running - Microphone active';\n      startFrequencyDisplay();\n    } catch (error) {\n      console.error('Failed to start oscilloscope:', error);\n      statusElement.textContent = 'Error: Could not access microphone';\n      startButton.disabled = false;\n      loadFileButton.disabled = false;\n    }\n  } else {\n    try {\n      stopFrequencyDisplay();\n      await oscilloscope.stop();\n      startButton.textContent = 'Start';\n      loadFileButton.disabled = false;\n      statusElement.textContent = 'Stopped';\n    } catch (error) {\n      console.error('Failed to stop oscilloscope:', error);\n      statusElement.textContent = 'Stopped (with errors)';\n      startButton.textContent = 'Start';\n      loadFileButton.disabled = false;\n    }\n  }\n});\n\n// Load file button handler\nloadFileButton.addEventListener('click', () => {\n  fileInput.click();\n});\n\n// File input handler\nfileInput.addEventListener('change', async () => {\n  const file = fileInput.files?.[0];\n  if (!file) {\n    return;\n  }\n  \n  // Stop if already running\n  if (oscilloscope.getIsRunning()) {\n    stopFrequencyDisplay();\n    await oscilloscope.stop();\n  }\n  \n  try {\n    startButton.disabled = true;\n    loadFileButton.disabled = true;\n    statusElement.textContent = `Loading file: ${file.name}...`;\n    \n    await oscilloscope.startFromFile(file);\n    \n    startButton.textContent = 'Stop';\n    startButton.disabled = false;\n    statusElement.textContent = `Playing: ${file.name} (loop)`;\n    startFrequencyDisplay();\n  } catch (error) {\n    console.error('Failed to load audio file:', error);\n    statusElement.textContent = 'Error: Could not load audio file';\n    startButton.textContent = 'Start';\n    startButton.disabled = false;\n    loadFileButton.disabled = false;\n  }\n  \n  // Clear file input to allow loading the same file again\n  fileInput.value = '';\n});\n"],"names":["dbToAmplitude","db","amplitudeToDb","amplitude","frequencyToNote","frequency","C0","halfSteps","noteIndex","cents","noteNames","octave","SILENCE_THRESHOLD_DB","trimSilence","audioBuffer","numberOfChannels","sampleRate","length","channelDataCache","peakAmplitude","channel","data","i","threshold","startIndex","isSilent","endIndex","trimmedLength","trimmedBuffer","sourceData","destData","AudioManager","__publicField","bufferLength","source","error","file","arrayBuffer","bufferSource","track","chunk","currentBuffer","buffer","multiplier","recentBuffers","totalLength","sum","buf","extendedBuffer","offset","_a","GainController","enabled","FrequencyEstimator","method","resolveValue","value","canvasSize","percentage","parsed","DEFAULT_OVERLAYS_LAYOUT","WaveformRenderer","canvas","overlaysLayout","context","displaySamples","gain","horizontalLines","y","verticalLines","x","displayTimeMs","timePerDivision","timeMs","label","textWidth","labelX","amplitudePerDivision","sign","absDb","dataLength","sliceWidth","centerY","dataIndex","rawY","frequencyData","estimatedFrequency","fftSize","maxFrequency","binFrequency","defaultOverlayWidth","defaultOverlayHeight","defaultOverlayX","defaultOverlayY","overlayX","overlayY","overlayWidth","overlayHeight","maxBin","barWidth","barHeight","frequencyBin","markerX","halfFreqPeakStrengthPercent","candidate1Harmonics","candidate2Harmonics","candidate1WeightedScore","candidate2WeightedScore","selectionReason","lineHeight","currentY","halfFreq","harmonicsStr","v","weightedStr","maxWidth","words","line","word","testLine","frequencyHistory","minFrequency","plotX","plotY","plotWidth","plotHeight","validFrequencies","f","dataMin","dataMax","rangePadding","displayMin","displayMax","freq","noteInfo","centsSign","xStep","labelInterval","frequencyToY","normalizedFreq","hasValidPoint","isLatestFrame","frameOffset","currentFreq","displayText","phaseZeroIndex","phaseTwoPiIndex","phaseMinusQuarterPiIndex","phaseTwoPiPlusQuarterPiIndex","displayStartIndex","displayEndIndex","displayLength","drawVerticalLine","sampleIndex","color","lineWidth","relativeIndex","layout","defaultX","defaultY","defaultWidth","defaultHeight","width","height","resolvedWidth","ZeroCrossDetector","WaveformSearcher","ComparisonPanelRenderer","previousCanvas","currentCanvas","similarityCanvas","bufferCanvas","prevCtx","currCtx","simCtx","buffCtx","ctx","peak","clampedStart","clampedEnd","scalingFactor","similarity","text","similarityHistory","normalizedSimilarity","currentSimilarity","startX","endX","previousWaveform","currentWaveform","currentStart","currentEnd","fullBuffer","_WaveformDataProcessor","audioManager","gainController","frequencyEstimator","waveformSearcher","resolve","reject","timeout","cleanup","wasmPath","script","handleLoad","basePath","segments","segment","scripts","src","pathname","pattern","index","renderData","fftDisplayEnabled","dataArray","wasmResult","WaveformDataProcessor","Oscilloscope","previousWaveformCanvas","currentWaveformCanvas","similarityPlotCanvas","frameBufferCanvas","startTime","processingTime","currentFps","avgProcessingTime","a","b","paused","PianoKeyboardRenderer","matches","noteName","noteInOctave","startNoteInfo","endNoteInfo","range","count","note","totalKeyboardWidth","highlightFrequency","highlightNoteInfo","whiteKeyIndex","isHighlighted","rightEdge","pianoKeyboardCanvas","startButton","loadFileButton","fileInput","autoGainCheckbox","noiseGateCheckbox","fftDisplayCheckbox","pauseDrawingCheckbox","noiseGateThreshold","thresholdValue","statusElement","frequencyMethod","bufferSizeMultiplier","frequencyValue","noteValue","gainValue","similarityValue","requiredElements","element","name","sliderValueToThreshold","sliderValue","formatThresholdDisplay","oscilloscope","pianoKeyboardRenderer","initialThreshold","frequencyUpdateInterval","startFrequencyDisplay","stopFrequencyDisplay"],"mappings":"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"}